{"cases":{"index":[0,{"t":"h","c":"快速开始"},{"t":"p","c":"要开始使用，只需通过引入 CDN 地址将项目 ofajs 集成到你的项目中："},0,{"t":"p","c":"这是一个简单的示例，演示了如何使用 ofa.js 修改 DOM 元素的内容："},{"t":"h","c":"使用方法"},{"t":"p","c":"引入了 ofa.js 后，全局作用域中将注册 $ 符号。通过 $('xxx') 来选择符合条件的第一个元素，其中 xxx 是标准的 CSS 选择器 内容。"},{"t":"p","c":"在上述示例中，我们使用了 $ 符号来选择三个具有不同 id 的元素，并通过设置 text 、 html 和 value 属性来修改其内容。"},{"t":"p","c":"要了解更多可用的属性和方法，请查阅 API 文档。"}],"event":[0,{"t":"h","c":"事件响应"},{"t":"p","c":"您可以使用 on 方法来绑定事件。事件 是开发中最基础的概念，应用通过事件的触发才能产生反馈，从而实现互动性。"},{"t":"p","c":"以下示例演示了如何绑定点击事件："},{"t":"p","c":"在这个示例中，我们通过使用 $ 选择了 button 元素，并使用 on 方法绑定了 click 事件。当按钮被点击时，会触发回调函数，将 target 元素的文本内容更改为 \"你好，世界！\"。"},{"t":"p","c":"如果您想了解更多可用的事件类型，请参考 Events 文档。"}],"simple-component":[0,{"t":"h","c":"组件的创建和使用"},{"t":"p","c":"一旦完成对 ofa.js 的加载，全局会注册一个名为 load-module 的组件，你可以使用缩写 l-m 来引用它。其使用方式类似于 script 标签，通过 src 属性来引用你开发好的组件地址。"},{"t":"p","c":"现在，让我们开始制作自己的组件。首先，创建一个 HTML 文件，文件名需要与组件名保持一致。"},{"t":"p","c":"在组件文件中，首先添加一个 template 元素，并添加 component属性。将组件需要渲染的内容放置在这个 template 元素内。最终，这些内容将被渲染到组件的 Shadow DOM 内，Shadow DOM 与外部环境隔离，以防止污染外部环境。"},{"t":"p","c":"接下来，只需使用 l-m 组件来引用你开发好的组件。在页面上，直接使用你定义的组件标签即可。"},{"t":"p","c":"需要注意的是，注册的组件名只能使用小写英文字母和 - 符号，并且必须包含至少一个 -。这个命名规则需要遵循。"},{"t":"p","c":"通过本示例，你可以了解如何创建一个名为 my-comp 的组件，并在另一个页面中使用它。同时可以通过链接外部的 CSS 文件来设置组件的样式。"}],"slot":[0,{"t":"h","c":"组件插槽"},{"t":"p","c":"通过在模板中添加 <slot></slot> 标签，可以在使用组件时，将内容放置在对应组件标签内的插槽中。"},{"t":"p","c":"自定义的组件在默认情况下没有定义 display 属性，因此需要手动为组件定义。在组件的样式中，可以使用 :host 选择器来添加组件自身的样式。"},{"t":"p","c":"这个示例展示了如何创建一个名为 simple-btn 的组件。组件的模板中包含一个插槽，可以将内容插入到组件中。通过为组件的样式添加 :host 选择器，为组件添加样式。在另一个页面中，使用 l-m 组件引用 simple-btn 组件，并在其中插入内容。"}],"render-text":[0,{"t":"h","c":"文本渲染"},{"t":"p","c":"在组件文件中，你可以添加一个 script 标签来编写组件的逻辑代码。通过暴露的 default 对象，可以设置组件参数。"},{"t":"p","c":"其中，data 参数用于定义组件元素的默认数据。一旦实例化完成，你就可以使用模板语法。"},{"t":"p","c":"文本渲染采用双大括号进行包裹，即 {{xxx}}，其中的 xxx 表示组件的属性名；"},{"t":"p","c":"案例演示了如何渲染组件元素的 val 属性："}],"attribute-transmission":[0,{"t":"h","c":"特性传递"},{"t":"p","c":"attrs 参数和 data 参数在功能上类似，设置在 attrs 中的数据会合并到 data 中，但是 attrs 上的数据会体现在组件自身的特性上。"},0,{"t":"p","c":"在外部使用组件时，也可以通过特性将数据传递到组件内部。需要注意的是，通过特性传递的数据只能是字符串类型。"}],"get-set-comp":[0,{"t":"h","c":"获取和修改组件实例的值"},{"t":"p","c":"从外部也可以获取或修改组件的数据。"},{"t":"p","c":"示例展示了如何在外部操作组件的数据；"}],"property-transmission":[0,{"t":"h","c":"属性传递"},{"t":"p","c":"通过使用属性传递的模板语法，您可以将组件的数据应用于模板内的元素属性。"},{"t":"p","c":"使用方法是在元素上添加特性 :name=\"key\"，其中 name 为目标元素要设置的属性名，key 则为您自定义组件中要传递的属性键名。"},{"t":"p","c":"之前在提到了<a href='./index.html' olink>使用选择器的方式来设置属性</a>，而这里介绍的是属性传递语法设置属性；"}],"bind-event":[0,{"t":"h","c":"事件绑定"},{"t":"p","c":"在组件内部，您可以通过 on 属性来绑定事件，让组件具备交互能力。这里演示了如何在组件中绑定事件以实现交互效果。"},{"t":"p","c":"proto 参数用于定义组件自身的方法，这些方法可以在组件内部使用，也可以在外部通过选择器获取组件后运行。"},{"t":"p","c":"on:click=\"xxx\" 后面的 xxx 可以是组件内部定义的方法名，也可以是函数表达式。如果使用函数表达式，无需显式写出 this 关键字，变量的作用域会自动绑定到组件自身；"},{"t":"p","c":"如果您想了解更多可用的事件类型，请参考 Events 文档。"}],"nested-component":[0,{"t":"h","c":"嵌套组件"},{"t":"p","c":"全部过多的逻辑放到一个组件上，不是一个明智的选择；我们可以将逻辑分到另外的组件，在通过 l-m 方式导入另一个组件来使用；"},{"t":"p","c":"案例中通过 <l-m src=\"./comp-two.html\"></l-m> 引入了名为 CompTwo 的嵌套组件。"},{"t":"p","c":"通过 <comp-two :txt=\"val\"></comp-two> 使用了嵌套组件，并将当前组件的 val 属性作为 txt 属性传递给嵌套组件。这样，嵌套组件可以使用传递过来的数据进行渲染。"},{"t":"p","c":"在 <comp-two></comp-two> 中，我们在不传递任何属性的情况下使用了嵌套组件。这里的使用方式取决于嵌套组件本身的逻辑和设计。"},{"t":"p","c":"只要一个组件加载成功，无论在何处，都可以使用相应名称的组件。即使在多个地方多次使用 l-m 组件加载相同的组件，也不会导致组件被多次加载。这种机制保证了组件的重用和一致性。"}],"inject-host":[0,{"t":"h","c":"inject-host 组件"},{"t":"p","c":"鉴于 Web Components 的隔离性，很难直接修改组件插槽内元素的样式。为了应对这个问题，ofa.js 提供了一个名为 inject-host 的组件；inject-host 组件会向宿主层注入样式，从而更灵活地配置组件的外观。"},{"t":"p","c":"需要注意的是，使用此组件可能会影响宿主层的样式。因此，在侵入样式时应保持命名的规范性，以避免影响宿主的样式。"},{"t":"p","c":"示例中，我们定义了 comp-two 组件，内部使用了 inject-host 组件来注入样式。这使得我们可以通过注入的样式对 comp-two 组件内的元素进行样式设置，而不会影响到其他组件。"},{"t":"p","c":"同时，以下内容也需要特别注意："},{"t":"l","c":"- 通过在 inject-host 内添加 <style> 标签，我们可以定义组件内的特定样式。这些样式只会影响到当前组件的元素，而不会波及到其他组件。\n- 在注入样式时，应当避免使用过于普通的选择器，以免影响到其他组件的样式。需要保持选择器的唯一性和特定性。\n- inject-host 也可以注入外部的样式表文件，通过 <link rel=\"stylesheet\" href=\"target/style.css\"> 的方式。"},{"t":"p","c":"在整个示例中，通过使用 comp-two 组件内的 inject-host，我们可以在不破坏其他组件样式的情况下，灵活地设置并应用组件内部的样式。"}],"event-passing":[0,{"t":"h","c":"事件传递"},{"t":"p","c":"除了监听原生事件，on 还可以用于监听自定义事件，这在组件间实现事件通信时非常重要。自定义事件通过 emit 方法来触发。通过触发自定义事件，可以将自定义数据传递给接收方。"},{"t":"p","c":"如果需要跨越组件的 Shadow DOM 边界，以触发事件，可以添加 composed 属性。"},{"t":"p","c":"在下面的案例中，我们将学习如何使用 emit 方法在嵌套的组件之间进行事件传递。"}],"sync":[0,{"t":"h","c":"双向数据绑定"},{"t":"p","c":"通过使用 sync 语法，您可以在用户界面的交互元素（例如输入框或自定义组件）与数据模型之间建立实时的双向关联。"},{"t":"p","c":"以下示例演示了如何在组件中使用 sync 属性来实现输入框与数据模型之间的双向数据绑定："},{"t":"l","c":"- 在 data 参数中，我们定义了名为 testText 的数据，并为其设置初始值为 \"I am testText\"。\n- 使用 sync:value=\"testText\" 表示输入框的值与 testText 数据之间建立了双向数据绑定。因此，当用户在输入框中输入内容时，testText 数据会实时更新，反之亦然。\n- 同样，使用 sync:txt=\"testText\" 表示自定义组件的 txt 属性与 testText 数据之间建立了双向数据绑定。组件的 txt 属性发生变化时，testText 数据会实时更新，反之亦然。"},{"t":"p","c":"通过双向数据绑定，您可以轻松地在用户界面和数据模型之间建立联系，使得数据的变化能够自动反映在界面上，同时用户在界面上的输入也能立即影响到数据模型。"},{"t":"p","c":"值得注意的是，数据同步只能传递 字符串 或 数字，无法传递其他数据类型。"}],"condition":[0,{"t":"h","c":"条件渲染"},{"t":"p","c":"模板内除了有模板语法，也有模板组件；"},0,{"t":"p","c":"条件渲染允许您在特定条件下，动态地在组件中插入不同的内容。以下是一个演示如何在组件内使用条件渲染的示例。"},{"t":"p","c":"在这个示例中，我们创建了一个名为 test-demo 的组件。组件内包含一个按钮，点击按钮会使 count 属性自增。通过 <x-if>、<x-else-if> 和 <x-else> 标签，我们实现了条件渲染的逻辑。"},{"t":"l","c":"- <x-if> 标签接受一个 value 属性，用于定义条件。如果 value 的值为 true，则渲染 <x-if> 内部的内容。在这个示例中，如果 count 为偶数，将显示红色文本。\n- <x-else-if> 标签也接受一个 value 属性，用于定义条件。如果前面的条件不满足且 value 的值为 true，则渲染 <x-else-if> 内部的内容。在这个示例中，如果 count 为 3 的倍数，将显示蓝色文本。\n- <x-else> 标签不需要 value 属性，它会在前面的条件都不满足时渲染其内部的内容。在这个示例中，如果 count 既不是偶数也不是 3 的倍数，将显示绿色文本。使用 x-else 时也可以紧跟在 x-if 后面；"},{"t":"p","c":"通过这种方式，您可以根据不同的条件动态地渲染不同的内容，实现灵活的交互和展示效果。"}],"fill":[0,{"t":"h","c":"填充渲染"},{"t":"p","c":"填充渲染（x-fill）模板在前端框架中类似于列表渲染的概念，它允许您根据数据集合动态地渲染一组微型组件。"},{"t":"p","c":"在填充渲染过程中，您可以使用以下特殊变量："},{"t":"l","c":"- $data：代表填充项的数据。通过操作 $data，您可以获取或修改每个填充项的数据。\n- $index：代表当前数据项在数据集合中的索引。\n- $host：代表当前组件自身。如果您想要获取组件的数据或调用组件的方法，需要使用 $host 来访问组件。"}],"fill-temp":[0,{"t":"h","c":"递归填充渲染"},{"t":"p","c":"填充渲染允许您使用独立的模板来渲染数据，并通过 <template> 元素添加 name 属性进行命名。这种方式使得您可以实现嵌套结构的数据渲染，从而创建更复杂的组件。"},{"t":"p","c":"在使用 x-fill 进行填充渲染时，只需将对应的模板名称传递给 name 属性，即可渲染独立模板的内容。此外，填充渲染还支持递归填充，即在模板内部可以继续使用相同的模板名称，实现嵌套填充。"},{"t":"p","c":"在示例中，我们定义了一个名为 item 的独立模板，并在 x-fill 使用时传递了相应的模板名称。这样，数据中的每个项都将使用这个模板进行渲染，而且模板内部可以再次使用相同的模板名称进行递归填充。这种方式使得您可以灵活地处理具有嵌套结构的数据，实现更加复杂的组件渲染。"}],"life-cycle":[0,{"t":"h","c":"生命周期"},{"t":"p","c":"生命周期钩子函数提供了在组件不同阶段执行代码的机会。在 ofa.js 中，有五个主要的生命周期钩子函数，它们分别是：created、ready、watch、attached 和 detached。"},{"t":"l","c":"- created(): 在组件被创建时调用，此时 shadow root 尚未开始渲染。可以在这里执行一些初始化设置，但不能访问 shadow root 中的元素。\n  \n- ready(): 在 shadow root 渲染完成后调用，一般用于组件的初始化逻辑。在这个阶段，您可以访问并操作 shadow root 内的元素，以及执行其他需要在渲染完成后执行的操作。\n\n- watch: 通过定义 watch 对象来监听数据的变化。在 ready 完成后，会触发一次 watch，对应着 data 上的值。之后，每次对应的键的值发生变动后，都会触发 watch 内对应的函数。\n\n- attached(): 当组件被添加到 document 中时调用，此时可以进行与外部环境交互的操作，如获取组件外观或初始化共享数据的逻辑。\n\n- detached(): 当组件从 document 中移除时调用。在这个阶段，您可以执行清理工作，取消与外部环境的交互，并释放资源。"}],"form-data":[0,{"t":"h","c":"表单数据"},{"t":"p","c":"在许多应用中，处理表单数据是一项常见的任务。为了简化这个过程，ofa.js 对表单数据的处理进行了二次抽象，提供了 formData 方法。通过这个方法，您可以轻松地将表单元素的值映射到一个对象上，并且在表单元素的值发生变化时，自动更新这个对象的数据，反之亦然。"},{"t":"p","c":"通过使用 shadow 属性，您可以获取到组件的 Shadow DOM 根节点的内容。这可以让您在组件内部访问和操作 Shadow DOM 中的元素和样式。"},{"t":"p","c":"在这个示例中，我们可以看到如何利用 formData 方法将表单数据自动映射到对象 fdata 上。这使得您可以通过操作 fdata 对象来获取或修改表单元素的值，而这些变动也会自动同步到对应的表单元素上。"}],"custom-form-element":[0,{"t":"h","c":"自定义表单组件"},{"t":"p","c":"使用 ofa.js，您可以轻松地开发自定义的表单元素组件，使其具有标准的表单特性。只需要为自定义组件添加 value 属性并设置 name 特性，您的自制组件就能够作为标准表单元素来使用。通过更新组件的 value 属性，您就能实现与表单元素的交互。"},{"t":"p","c":"初始化 formData 时，需要将自定义组件的选择器特征添加到参数中（尽管 formData 方法默认的参数为 \"input,select,textarea\"）。这样，formData 就能够与自定义组件进行联动。"},{"t":"p","c":"在这个示例中，我们通过自定义组件 custom-input 来实现一个可编辑的文本输入框。该组件被用作表单元素，并使用 value 属性进行数据交互。使用 formData 方法时，我们将 \"input,custom-input\" 添加为参数，以便正确地初始化表单数据。"}],"use-page":[0,{"t":"h","c":"使用页面组件"},{"t":"p","c":"一旦加载了 ofa.js，全局会自动添加一个名为 o-page 的页面组件。这个组件用于加载页面模块，页面模块是一种特殊的组件模块，不会注册为自定义标签，而是通过 o-page 组件来加载。"},{"t":"p","c":"页面模块类似于组件模块，但是有一些不同之处。页面模块使用 page 属性来定义模板，而不是 component 属性。页面模块的开发逻辑和组件模块一样，使用相同的模板语法和模板组件等。然而，页面模块不能使用 attrs 特性，因为页面的参数通常通过 URL 传递，而不是通过 data 或 attrs。"},{"t":"p","c":"在示例中，o-page 组件用于加载 page.html 页面模块。页面模块中使用 page 属性定义模板，然后通过 JavaScript 函数返回一个对象来设置数据。URL 中的查询参数 count 会被传递到页面模块中，并被用于初始化数据。页面内的按钮点击事件可以更新数据并在页面中呈现。"}],"use-app":[0,{"t":"h","c":"使用 app 组件"},{"t":"p","c":"在 ofa.js 中，您可以使用 o-app 组件来创建整个应用的布局结构，并在其中加载不同的页面模块。通过使用 o-app 组件、o-page 组件和页面模块，您可以构建整个应用的页面结构，并实现页面之间的导航"},{"t":"p","c":"当 o-page 组件位于 o-app 内部时，您可以使用带有 olink 属性的 <a> 标签来实现页面跳转。这种跳转不会影响当前页面，而是只会在 o-app 内部进行跳转，类似于使用 <iframe>。"},{"t":"p","c":"如果 o-page 组件在 o-app 内部，您还可以使用以下方法："},{"t":"l","c":"- goto 方法来进行页面跳转\n- back 方法返回上一页\n- replace 方法进行当前页面的替换式跳转"},{"t":"p","c":"通过使用 o-app 组件，您可以构建整个应用的布局结构，并在其中加载不同的页面模块。同时，o-app 提供的路由功能使得页面之间的跳转变得更加方便和灵活。"},{"t":"p","c":"在这个示例中，我们通过 o-app 组件创建了一个应用布局，然后在其中加载了一个页面模块 page1.html。"},{"t":"p","c":"在 page1.html 页面模块中，我们定义了一个标题和一个按钮，点击按钮会跳转到另一个页面模块 page2.html。我们还添加了一个带有 olink 属性的链接，点击链接同样会导航到 page2.html。"},{"t":"p","c":"在 page2.html 页面模块中，我们同样定义了一个标题和一个按钮，点击按钮会返回上一页，实现页面导航。"}],"app-config":[0,{"t":"h","c":"配置 app 参数"},{"t":"p","c":"您可以通过为 o-app 标签单独设置外部模块来配置应用的参数。"},{"t":"p","c":"这些参数是一个 ES 模块，您可以配置以下参数："},{"t":"l","c":"- home: 应用的首页，即初始加载时显示的页面。\n- loading: 在应用页面点击跳转时，在未完成模块加载前，显示的加载中内容。您可以通过返回一个字符串作为 loading 内容。\n- pageAnime: 页面跳转时的动画效果，使用的是一个包含 CSS 样式属性的对象。\n  - current: 表示页面处于当前页时的样式。\n  - next: 表示页面在未进场时的样式。\n  - previous: 表示页面在要退出时的样式。"},{"t":"p","c":"通过这种方式，您可以根据应用的需要，自定义首页、加载中样式和页面跳转动画等参数，从而为应用带来更加个性化的体验。"}],"app-loading":[0,{"t":"h","c":"为 app 定制 loading"},{"t":"p","c":"以下是一个为 o-app 组件定制 loading 的示例。在这个示例中，我们为 loading 创建了一个漂亮的进度条，它会在页面加载期间逐渐增长，加载完成后会直接到达 100%，然后将 loading 元素删除。"},{"t":"p","c":"您可以将以下代码复制并用于定制您的应用的 loading 效果："},0,{"t":"p","c":"通过这段代码，您可以为您的应用添加一个独特的加载效果，让用户在页面切换过程中有更好的体验。"}],"set404":[0,{"t":"h","c":"配置404页面"},{"t":"p","c":"在应用的配置模块中，通过设置 fail 函数，以自定义在页面加载失败时所展示的内容；"},{"t":"p","c":"在这个示例中，当页面加载失败时，将显示加载错误信息的第一行内容；"},0],"use-hash-router":[0,{"t":"h","c":"使用 hash router"},{"t":"p","c":"只需使用 o-router 组件，即可将 app 组件内的路由与当前网页关联起来。一旦页面与路由绑定，即使进行页面刷新，也能保持页面的路由状态。"},{"t":"p","c":"在这个示例中，请点击  <span style='font-family: \"iconfont\"'>&#xe7cb;</span>  按钮，以新页面的方式打开并尝试。"},0],"use-scsr":[0,{"t":"h","c":"使用 SCSR 方案"},{"t":"p","c":"在这个示例中，请点击 <span style='font-family: \"iconfont\"'>&#xe7cb;</span> 按钮，以新页面的方式打开并尝试；"},{"t":"p","c":"SCSR 的全称是 Static Client-Side Rendering，又称为静态客户端渲染。它是 CSR（Client-Side Rendering）的一种变种，在保留了 CSR 用户体验的基础上，还能够让页面在静态状态下被搜索引擎爬取。"},{"t":"p","c":"当前网站采用的正是 SCSR 方案构建；"},{"t":"p","c":"SCSR 通过直接运行单文件模式的页面模块，无需使用 o-page 标签，实现在页面上进行渲染。具体而言，就是将页面模块的模板代码直接嵌套在 o-app 内。"},{"t":"h","c":"注意事项"},{"t":"p","c":"对于所有采用 SCSR 方案的页面，除了页面描述性的内容（如 title、meta:description、keywords）和页面模板内容外，其他引用的资源必须保持一致，以确保在页面跳转和刷新后的用户体验一致。"}]},"docs":{"introduce":[{"t":"h","c":"ofa.js - 渐进式前端框架"},{"t":"h","c":"什么是 ofa.js"},{"t":"p","c":"ofa.js是一个渐进式前端框架，旨在让开发者以最低成本进入前端开发和使用流程。它提供了一系列简单而强大的工具和API，让前端开发变得更加高效和便捷。"},{"t":"h","c":"存在目的"},{"t":"h","c":"取代 jQuery"},{"t":"p","c":"在许多小型项目中，我们可能并不需要引入像React和Vue这样的大型框架，而是倾向于使用jQuery进行简单的前端操作。ofa.js改进了jQuery的API，并将jQuery的许多方法替代为属性，使得使用ofa.js在很多场景下更为合适。"},{"t":"h","c":"简化前端开发和使用流程"},{"t":"p","c":"ofa.js的目标是简化繁琐的前端开发流程。它允许开发者无需学习复杂的Node.js、npm和脚手架等工具，从而更快地搭建前端应用。使用它，你可以回归到只需引入一个库即可进行开发的体验。"},{"t":"h","c":"成为银弹型前端开发框架"},{"t":"p","c":"ofa.js旨在成为一种\"银弹\"，即能够解决多种前端开发问题，并提供全面的解决方案。它不仅仅是一个工具库，更是一种全面的前端开发框架。"},{"t":"h","c":"特点"},{"t":"h","c":"易上手的组件开发"},{"t":"p","c":"使用ofa.js开发的组件几乎没有学习成本。ofa.js提供了简洁而直观的API，让开发者可以快速创建和集成组件，同时保持代码的整洁和易于维护。"},{"t":"h","c":"内置模块化、状态更新和应用集成方案"},{"t":"p","c":"ofa.js内部已经集成了模块化、状态更新和应用集成等解决方案，使得开发者无需额外寻找第三方库或工具，就可以完成复杂的前端开发任务。"},{"t":"h","c":"官方提供路由和 SSG（静态站点生成）方案"},{"t":"p","c":"ofa.js还为路由和SSG提供了官方解决方案，帮助开发者更好地管理前端路由和生成静态站点，提高应用性能和SEO友好度。"},{"t":"h","c":"精简的代码体积"},{"t":"p","c":"ofa.js的代码经过精心优化，压缩后的.min文件大小只有38kb(gzip下只有14kb)。这使得ofa.js成为一个高效的前端框架，可以在各种网络环境下快速加载和使用。"}],"get-started":{"index":[{"t":"h","c":"上手使用"},{"t":"h","c":"如何使用"},{"t":"h","c":"直接引用"},{"t":"p","c":"你可以通过 CDN 的地址直接将 ofa.js 引用到你的页面上："},0,{"t":"h","c":"通过 npm 安装"},{"t":"p","c":"首先，在你的项目中安装 ofa.js："},0,{"t":"p","c":"然后在项目中引入 ofa.js 模块："},0,{"t":"h","c":"使用"},{"t":"p","c":"在引用资源后，ofa.js 将在全局作用域上设置一个 $ 属性，所有的功能都在 $ 上，后面的教程会详细讲解其用法；"},{"t":"p","c":"通常情况下，我们建议采用直接引用的方式添加 ofa.js，而使用 npm 的方式则用于与类似 React 和 Vue 等框架进行兼容。"}],"hello-world":[{"t":"h","c":"第一个案例"},{"t":"p","c":"以下是一个案例，点击按钮后将文本更改为 \"Hello World\"："},0,{"t":"p","c":"当点击按钮后，将会显示加粗的 \"Hello World\" 文本。"},{"t":"p","c":"现在，让我们详细解释一下基础概念。"},{"t":"h","c":"选择器"},{"t":"p","c":"引用了 ofa.js 后，$ 符号将被注册到全局作用域中。通过 $('xxx') 来选择符合条件的第一个 元素，其中 xxx 是标准的 CSS Selector  内容。你可以点击链接查看具体的选择器内容。"},{"t":"p","c":"以下是一个例子："},0,{"t":"p","c":"在上面的案例中，打开页面一秒后，会分别改变 p标签 、#desk 和 .logger  的文本内容。"},{"t":"h","c":"事件绑定"},{"t":"p","c":"选择元素成功后，你可以为元素绑定事件。就像前面提到的 \"Hello World\" 案例中，我们给 id 为 \"btn\" 的元素绑定了点击事件。当点击按钮后，绑定的函数会被执行。"},{"t":"p","c":"你可以点击跳转查看 事件示例  章节，了解一些事件绑定的案例；"},{"t":"p","c":"所有可用的事件，可以参考 Web Events 来了解完整的事件列表。"},{"t":"h","c":"属性"},{"t":"p","c":"在上面的两个案例中，我们分别展示了 html 和 text 属性的使用。"},{"t":"p","c":"你还可以通过 html 或 text 属性来获取元素的内容，如下所示："},0,{"t":"p","c":"这个例子中，我们将 #t1 元素内的 HTML 内容赋值给了 #t2 和 #t3 元素。"}],"elements-and-events":[{"t":"h","c":"获取元素和事件相关"},{"t":"p","c":"该章节旨在加强对上一章内容的理解，包括选择元素 和 事件绑定。"},{"t":"h","c":"选择元素"},{"t":"p","c":"在之前的章节中，我们已经了解了通过 $ 符号从全局获取某个元素的方法。接下来，我们将介绍其他获取元素的方法。"},{"t":"h","c":"从元素内查找某个元素"},{"t":"h","c":"使用 $(\"xxx\").$('xxxx') 的方式"},{"t":"p","c":"$(\"xxx\").$('xxxx') 是通过先选择一个父元素，然后在其内部查找符合条件的子元素的方式。其中，$(\"xxx\") 选择了一个父元素，然后使用 $('xxxx') 在该父元素内查找符合条件的子元素。"},{"t":"h","c":"示例"},0,{"t":"p","c":"在上面的示例中，首先通过 $(\".parent\") 选择了具有 parent 类的父元素，然后使用 $(\".child\") 在该父元素内查找具有 child 类的子元素。然后修改了子元素的文本内容为 \"Modified child element\"。"},{"t":"h","c":"使用 $('xxx xxxx') 的方式"},{"t":"p","c":"$('xxx xxxx') 是通过在全局范围内查找符合第二个选择器条件的元素，然后在这些元素内部查找符合第一个选择器条件的元素。这种方式可以直接一步到位地查找到符合条件的子元素。"},{"t":"h","c":"示例"},0,{"t":"p","c":"在上面的示例中，直接使用 $('div .child') 查找到具有 child 类的子元素，并修改了子元素的文本内容为 \"Modified child element\"。"},{"t":"h","c":"选择多个元素"},{"t":"h","c":"使用 $.all('xxx') 查找全局的元素"},{"t":"p","c":"$.all('xxx') 方法用于查找页面中所有符合选择器条件的元素，并将它们作为一个元素集合返回。这样可以选择页面中的多个元素进行批量操作。"},{"t":"h","c":"示例"},0,{"t":"p","c":"在上面的示例中，使用 $.all(\"p\") 查找到页面中的所有 p 标签元素，并对它们进行了批量操作，将文本内容修改为 \"Modified Paragraph 1\"、\"Modified Paragraph 2\" 和 \"Modified Paragraph 3\"。"},{"t":"h","c":"从元素内查找所有符合条件的元素"},{"t":"p","c":"除了可以在全局范围内查找元素，还可以从某个元素内查找所有符合条件的子元素，使用方式为：$('xxx').all('xxxx')。"},{"t":"h","c":"示例"},0,{"t":"p","c":"在上面的示例中，首先使用 $(\".container\") 查找到具有 container 类的元素，然后通过 .all(\".item\") 在该容器内查找所有带有 item 类的子元素，并对它们进行了批量操作，将文本内容修改为 \"Modified Item 1\"、\"Modified Item 2\" 和 \"Modified Item 3\"。"},{"t":"h","c":"事件"},{"t":"p","c":"前面已经讲过 on 绑定事件的使用方法，后面介绍几个和事件相关的方法；"},{"t":"h","c":"off 方法的使用文档"},{"t":"p","c":"off 方法用于移除通过 on 方法绑定的事件处理函数。当不再需要某个事件的处理函数时，可以使用 off 方法将其从元素上移除，以避免重复执行或内存泄漏。"},{"t":"h","c":"语法"},0,{"t":"l","c":"- selector: 选择要移除事件处理函数的元素。 \n- eventName: 要移除的事件名称。 \n- eventHandler: 要移除的事件处理函数。"},{"t":"h","c":"示例"},0,{"t":"p","c":"在上面的示例中，当点击按钮时，会弹出一个对话框显示 \"Button clicked!\"。但是在5秒后，通过 off 方法移除了点击事件处理函数，所以按钮再次点击时不会触发弹出对话框。"},{"t":"h","c":"one 方法的使用文档"},{"t":"p","c":"one 方法用于绑定事件处理函数，但该处理函数只会在第一次触发事件时执行一次。在执行一次后，事件处理函数会被自动移除，避免重复触发。"},{"t":"h","c":"语法"},0,{"t":"l","c":"- selector: 选择要绑定事件处理函数的元素。 \n- eventName: 要绑定的事件名称。 \n- eventHandler: 要执行的事件处理函数。"},{"t":"h","c":"示例"},0,{"t":"p","c":"在上面的示例中，当点击按钮时，会弹出一个对话框显示 \"Button clicked once!\"。但是在第一次点击后，事件处理函数就会被移除，所以后续点击按钮不会再触发弹出对话框。"},{"t":"h","c":"emit 方法的使用文档"},{"t":"p","c":"emit 方法用于手动触发元素上绑定的特定事件。通过 emit 方法可以在不进行实际操作的情况下触发事件处理函数的执行。"},{"t":"h","c":"语法"},0,{"t":"l","c":"- selector: 选择要触发事件的元素。 \n- eventName: 要触发的事件名称。"},{"t":"h","c":"示例"},0,{"t":"p","c":"在上面的示例中，通过 emit 方法手动触发了按钮的点击事件，结果会弹出一个对话框显示 \"Button clicked!\"，尽管没有实际点击按钮。"},{"t":"p","c":"注意：使用 emit 方法不会模拟鼠标点击或其他实际事件，它只会直接调用已绑定的事件处理函数。所以，如果你希望在特定情况下触发事件的执行，可以使用 emit 方法。"},{"t":"p","c":"当你绑定事件后，有时你可能希望阻止事件的进一步传播（冒泡）或取消事件的默认行为。下面将介绍如何在事件触发后禁止冒泡和取消默认事件。"},{"t":"h","c":"禁止事件冒泡"},{"t":"p","c":"事件冒泡是指当一个元素上的事件被触发时，它会沿着 DOM 树向上冒泡，依次触发父元素上的同类型事件。如果你希望在特定元素上处理事件后阻止其继续冒泡，可以使用 event.stopPropagation() 方法。"},{"t":"p","c":"示例代码："},0,{"t":"p","c":"在上面的示例中，当你点击按钮 \"Click Me\" 后，它会显示 \"Button Clicked!\"，但不会触发 \"Inner Div Clicked!\" 和 \"Outer Div Clicked!\"。这是因为我们在按钮的点击事件处理程序中调用了 event.stopPropagation()，阻止了事件的进一步传播。"},{"t":"h","c":"取消事件的默认行为"},{"t":"p","c":"有些元素上的事件在触发时会有默认的行为。例如，点击提交按钮会导致表单提交，点击链接会跳转到链接的地址等。如果你希望阻止事件的默认行为，可以使用 event.preventDefault() 方法。"},{"t":"p","c":"示例代码："},0,{"t":"p","c":"在上面的示例中，当你点击提交按钮 \"Submit\" 后，它会显示 \"Hello, {name}! Form submission prevented.\"，但不会触发 \"Form Submitted!\" 的警报。这是因为我们在提交按钮的点击事件处理程序中调用了 event.preventDefault()，阻止了表单的提交默认行为。"}],"basic-concept":[{"t":"h","c":"实例的基础概念"},{"t":"p","c":"$ 实例是对页面上元素的封装，除了用于选择现有的元素外，它还可以直接创建新元素并进行操作。在本章中，我们将介绍如何创建新元素以及对 $ 实例的一些操作。"},{"t":"h","c":"创建新元素"},{"t":"p","c":"通过 $ 实例，我们可以直接创建新的元素并进行操作，例如："},0,{"t":"p","c":"在上面的例子中，我们通过 $('<div style=\"color:red\">I am text</div>') 创建了一个新的 div 元素，并将其添加到了 body 中。"},{"t":"h","c":"获取子元素"},{"t":"p","c":"通过 $ 获取的实例，并不像 DOM 元素那样拥有 children 属性。但是我们可以通过数组索引来访问实例的直接子元素："},0,{"t":"p","c":"在上面的例子中，我们获取了 div 元素，并通过索引来访问第一个和第二个 p 元素。同时，我们还使用了 $div.length 获取了子元素的数量。"},{"t":"h","c":"操作子元素"},{"t":"p","c":"通过 $ 实例，我们还可以直接使用数组的方法来操作子元素，例如 push 和 pop："},0,{"t":"p","c":"在上面的例子中，我们获取了所有 p 元素的 $ 实例，并使用 push 方法添加了一个新的 div 元素作为子元素，然后使用 pop 方法移除了最后一个子元素。"},{"t":"p","c":"通过上述示例，你可以了解 $ 实例的一些基本操作，包括创建新元素和对子元素的访问与操作。 $ 实例提供了简便的方法来操作页面上的元素。"}],"common-properties":[{"t":"h","c":"常用属性"},{"t":"p","c":"在 $ 实例中，除了可以通过选择器选择元素外，还提供了一些常用的属性来方便元素的操作和查找。"},{"t":"h","c":"tag 属性"},{"t":"p","c":"tag 属性用于获取当前元素的标签名（小写形式），类似于 DOM 元素的 tagName 属性。"},0,{"t":"h","c":"ele 属性"},{"t":"p","c":"ele 属性用于获取 $ 实例的实际 DOM 元素，从而可以对该元素进行原生的 JavaScript 操作。"},0,{"t":"h","c":"index 属性"},{"t":"p","c":"index 属性用于获取当前元素在同级元素中的排名索引，从 0 开始计数。"},0,{"t":"h","c":"parent 和 parents 属性"},{"t":"l","c":"- parent 属性用于获取当前元素的直接父元素。 \n- parents 属性用于获取当前元素的所有祖先元素（包括父元素的父元素、父元素的父元素的父元素等）构成的数组。"},0,{"t":"h","c":"next、nexts、prev、prevs、siblings 属性"},{"t":"l","c":"- next 属性用于获取当前元素的下一个兄弟元素。 \n- nexts 属性用于获取当前元素后面的所有兄弟元素构成的数组。 \n- prev 属性用于获取当前元素的前一个兄弟元素。 \n- prevs 属性用于获取当前元素前面的所有兄弟元素构成的数组。 \n- siblings 属性用于获取当前元素的所有兄弟元素，不包括自己。"},0],"common-function":[{"t":"h","c":"常用方法"},{"t":"h","c":"attr"},{"t":"p","c":"attr 方法允许您获取或设置元素的属性。"},0,{"t":"p","c":"在上面的示例中，我们首先选择了一个具有 id 为 \"example\" 的 div 元素。然后，我们使用 attr 方法来获取该元素的 name 属性，并将其打印到控制台。接下来，我们使用 attr 方法来设置该元素的 title 属性为 \"change title\"。"}],"css":[{"t":"h","c":"CSS 的用法"},{"t":"p","c":"在 ofa.js 中，你可以通过以下方式来操作元素的 CSS 样式；"},{"t":"h","c":"获取元素的具体 CSS 样式"},{"t":"p","c":"可以使用 $ele.css.xxx 来获取元素的具体 CSS 样式，其中 xxx 是你想要获取的 CSS 属性名。"},{"t":"h","c":"示例"},0,{"t":"h","c":"设置某个样式属性"},{"t":"p","c":"可以使用 $ele.css.xxx = '' 的方式来设置元素的 CSS 样式，其中 xxx 是你想要设置的 CSS 属性名。通过将属性值设为空字符串，可以将指定的样式属性移除。"},{"t":"h","c":"示例"},0,{"t":"h","c":"赋值对象"},{"t":"p","c":"可以使用 $ele.css = {xxx} 的方式来设置元素的 style，其中 xxx 是一个包含 CSS 属性名和属性值的对象。"},{"t":"h","c":"示例"},0,{"t":"h","c":"赋值字符串"},{"t":"p","c":"可以使用 $ele.css = 'color:red;...' 的方式来设置元素的 style，其中 'color:red;...' 是一个包含 CSS 样式规则的字符串。"},{"t":"h","c":"示例"},0,{"t":"h","c":"设置 css 的技巧"},{"t":"p","c":"你可以通过 $ele.css = {...$ele.css, color:'red'} 的方式来修改元素的某个样式属性，而不影响其他样式属性。这种方式可以在不重写整个样式的情况下，只修改其中一个属性。"},{"t":"h","c":"示例"},0,{"t":"p","c":"在上面的示例中，通过使用 { ...myElement.css, color: 'red' }，我们只修改了元素的颜色样式，而将其他样式属性保持不变。这是一个很方便的技巧，可以灵活地修改元素的样式。"}],"classlist-and-data":[{"t":"h","c":"classList 和 data"},{"t":"h","c":"classList"},{"t":"p","c":"在 ofa.js 中，你可以通过以下方式来操作元素的 classList： "},{"t":"l","c":"- $ele.classList: 返回元素的 classList 对象，用于操作元素的类名。"},{"t":"h","c":"classList 增删用法"},{"t":"l","c":"- 添加类名：$ele.classList.add('className')，将指定的类名添加到元素的 classList 中。 \n- 移除类名：$ele.classList.remove('className')，从元素的 classList 中移除指定的类名。 \n- 切换类名：$ele.classList.toggle('className')，如果元素的 classList 中已经存在该类名，则移除它；否则添加该类名。"},{"t":"h","c":"示例"},0,{"t":"p","c":"在这个示例中，有一个带有初始类名 box 的 <div> 元素，以及三个按钮：Add Highlight、Remove Highlight 和 Toggle Highlight。 "},{"t":"l","c":"- 当点击 \"Add Highlight\" 按钮时，通过 classList.add() 方法将 highlight 类名添加到 <div> 元素中，使其具有黄色背景色。 \n- 当点击 \"Remove Highlight\" 按钮时，通过 classList.remove() 方法从 <div> 元素的类名中移除 highlight 类名，恢复原始样式。 \n- 当点击 \"Toggle Highlight\" 按钮时，通过 classList.toggle() 方法切换 <div> 元素的 highlight 类名。如果原本有该类名，则移除它，如果原本没有该类名，则添加它，实现样式的切换。"},{"t":"p","c":"这样，你就可以通过 classList 对象来管理元素的类名，从而实现对元素样式的动态控制。"},{"t":"h","c":"data 的用法"},{"t":"p","c":"在 ofa.js 中，你可以通过以下方式来操作元素的 data 属性： "},{"t":"l","c":"- $ele.data: 返回元素的 dataset 对象，用于操作元素的 data 属性。"},{"t":"h","c":"dataset 的具体用法"},{"t":"p","c":"元素的 data-* 属性可以用于在 HTML 中存储自定义数据，可以通过 data 对象来访问这些属性。"},{"t":"p","c":"例如，如果有一个元素定义了 data-info 属性："},0,{"t":"p","c":"你可以使用 dataset 来访问该属性："},0,{"t":"p","c":"注意：dataset 对象中的属性名会将 \"data-\" 后面的部分转换为驼峰式命名。例如，data-info 变成了 dataset.info。如果要设置 data-* 属性，也可以通过 dataset 对象来实现："},0,{"t":"p","c":"这样就会在元素上添加一个 data-another-info 属性，并设置其值为 \"another value\"。"}],"box-model":[{"t":"h","c":"盒模型"},{"t":"p","c":"在前端开发中，经常会用到一些表示元素尺寸的属性。这些属性包括 width、height、clientWidth、clientHeight、offsetWidth、offsetHeight、outerWidth 和 outerHeight。了解它们的含义和用法对于开发响应式和动态布局非常重要。下面让我们一一解释它们，并通过一个示例来演示。"},{"t":"l","c":"- width：表示元素的内容区域的宽度，不包括内边距、边框和外边距。\n- height：表示元素的内容区域的高度，不包括内边距、边框和外边距。\n- clientWidth：表示元素的可见内容区域的宽度，包括内边距，但不包括边框和外边距。\n- clientHeight：表示元素的可见内容区域的高度，包括内边距，但不包括边框和外边距。\n- offsetWidth：表示元素的整体宽度，包括内容区域、内边距、边框和外边距。\n- offsetHeight：表示元素的整体高度，包括内容区域、内边距、边框和外边距。\n- outerWidth：表示元素的整体宽度，包括内容区域、内边距、边框、外边距，但不包括滚动条的宽度。\n- outerHeight：表示元素的整体高度，包括内容区域、内边距、边框、外边距，但不包括滚动条的高度。"},0],"formdata":[{"t":"h","c":"表单功能"},{"t":"p","c":"$ 实例提供了一些便捷的表单功能，使得处理表单元素更加简单和高效。"},{"t":"h","c":"通过 formData 生成对象"},{"t":"p","c":"formData 方法用于生成包含目标元素内所有表单元素值的对象。该对象会实时反映表单元素的改动。"},0,{"t":"h","c":"监听特定表单元素"},{"t":"p","c":"默认情况下，formData() 监听目标元素内的所有 input、select 和 textarea 元素。你可以通过传递选择器来监听特定的表单元素。"},0,{"t":"h","c":"Stanz 对象"},{"t":"p","c":"formData() 方法返回的对象被称为 Stanz 对象。Stanz 是 $ 扩展库的一部分，提供了对表单数据的高效处理和监听功能。"},{"t":"p","c":"你可以通过访问 https://github.com/kirakiray/stanz 来详细了解 Stanz 的使用教程和功能。"},{"t":"p","c":"通过以上的表单功能，你可以轻松地处理表单元素的值和变化，从而提高表单操作的便捷性和效率。"}]},"create-component":{"index":[{"t":"h","c":"制作和使用组件"},{"t":"p","c":"ofa.js 使用基础的 HTML 和 JavaScript 文件来定义组件，避免引入新的文件类型以减少学习成本。只要你对 HTML 有一定的了解，就能够快速开发和使用 ofa.js 组件。"},{"t":"h","c":"准备创建组件前的步骤"},{"t":"p","c":"在开始创建组件之前，需要注意一些准备工作。由于创建组件涉及到浏览器请求资源的操作，如果你仅仅是双击打开 HTML 文件来查看，会在 \"file\" 协议下进行查看。在 \"file\" 协议下，JavaScript 模块的加载可能会报错。因此，你需要准备一个静态服务器来正确查看组件。"},{"t":"p","c":"如果你使用的是 Visual Studio Code 编辑器，你可以简单地安装一个支持静态服务器的插件。我们推荐使用 Live Server 插件。"},{"t":"p","c":"安装插件后，只需在 demo.html 文件上右键点击，选择 \"Open with Live Server\"，插件将会自动以静态服务器模式打开文件。"},{"t":"p","c":"如果你使用的是其他编辑器，你也可以创建一个 Nginx 或 Apache 服务器，只要能够支持静态 HTML 查看即可。这样做可以确保你能够正常预览和开发你的组件。"},{"t":"h","c":"创建一个按钮组件"},{"t":"p","c":"下面，我们将创建一个简单的按钮组件，命名为 simple-button，它将具有比原生按钮更美观的样式。"},{"t":"p","c":"首先，创建一个名为 simple-button.html 的文件，其中使用 <template> 标签，并添加 component 属性以标识为组件。"},{"t":"p","c":"然后，在 <template> 内部编写组件的模板代码。接着，在模板内容下方，添加一个 <script> 标签，将组件的 JavaScript 代码放入其中。"},0,{"t":"p","c":"在成功引入 ofa.js 后，会自动注册 load-module 组件，这是一个用于声明式引用模块的组件，类似于 script 标签。该组件会代理加载指定 src 的模块，并对需要加载的模块进行预处理。在本案例中，会加载模板并注册 simple-button 组件。"},{"t":"p","c":"load-module 组件还可以使用缩写 l-m，以减少代码量。"},0,{"t":"p","c":"load-module 组件是一个定制的声明式加载器库，提供了强大的功能，可以扩展支持各种类型的文件，或者对 JavaScript 模块进行中转处理。它已经拆分成了一个独立的项目，具体的使用文档在 https://github.com/kirakiray/drill.js。"},{"t":"h","c":"双文件模式"},{"t":"p","c":"双文件模式将 静态模板 和 逻辑代码 分开，使组件更加清晰。"},{"t":"p","c":"逻辑代码放在 js 文件内，这个 js 需要标识 export const type = $.COMP;，以通知页面这是一个组件模块。在这种拆分模式下，模块代码可以使用 import 等 ES Module 的标准语法。"},{"t":"p","c":"按钮组件由两个文件组成："},{"t":"l","c":"1. simple-button.html：按钮组件的 HTML 模板和样式。"},0,{"t":"l","c":"2. simple-button.mjs：按钮组件的注册代码。"},0,{"t":"p","c":"在需要使用该组件的地方，使用 l-m 引入这个模块。以下是使用 simple-button 的案例页面（双文件模式）。"},0],"parameter-description":[{"t":"h","c":"组件的注册参数详解"},{"t":"p","c":"在 ofa.js 中，你可以在组件模块中定义一些特定的注册参数，以便更灵活地配置组件。下面详细说明了每个注册参数，并附带了相应的示例演示。"},{"t":"h","c":"基础参数"},{"t":"p","c":"基础参数是注册组件的最基本配置，包含以下几个属性："},{"t":"h","c":"组件标识"},{"t":"p","c":"组件模块必须带有 export const type = $.COMP，用于标识该模块为组件模块。"},{"t":"p","c":"示例："},0,{"t":"h","c":"tag"},{"t":"p","c":"tag 代表注册的组件名。当没有定义 tag 属性时，注册的组件名与文件名保持一致。"},{"t":"p","c":"示例："},0,{"t":"h","c":"temp"},{"t":"p","c":"temp 是字符串类型的属性，用于定义组件模板的地址。当没有定义 temp 时，默认载入和当前模块同目录下与组件同名的 HTML 文件。"},{"t":"p","c":"示例："},0,{"t":"h","c":"data"},{"t":"p","c":"data 是对象类型属性，用于生成组件后，默认添加的自定义数据。"},{"t":"p","c":"示例："},0,{"t":"h","c":"attrs"},{"t":"p","c":"attrs 是对象类型属性，也属于 data，但是这个数据会反映到 element 的 attributes 上，attributes 上的改动也会动态改动到组件的 data 上。当出现大写的 key 时，反应到组件 attribute 会变成 - 驼峰的命名。"},{"t":"p","c":"示例："},0,{"t":"h","c":"proto"},{"t":"p","c":"在组件的注册参数中，你可以添加一个 proto 对象，用于定义需要添加到组件原型上的方法。这样，在创建组件的实例时，这些属性和方法就会被添加到实例的原型上，从而所有实例都可以访问和共享这些方法。"},0,{"t":"h","c":"watch"},{"t":"p","c":"watch 是对象类型属性，用于监听 data 变化的监听函数放在这里。注册成功后，监听的值会被立刻执行一次。"},{"t":"l","c":"- watch 注册的函数在单次线程改动中，只会被触发一次。因此，在一次线程中，即使多次修改这个监听的值，也只会被触发一次。\n- 第一个参数为当前值。\n- 第二个参数是对象，会带有 watchers 数据集，一般情况下 watchers 上只会有一个对象，可以从这个对象上获取到 oldValue。当单次线程的这个被监听的值被改动过多次，这个数据集会记录多次的变化。"},{"t":"p","c":"示例："},0,{"t":"h","c":"示例代码"},{"t":"p","c":"以下为一个完整的示例代码，包括基础参数的定义和组件模板。"},0,0,0,{"t":"h","c":"default"},{"t":"p","c":"你还可以使用异步函数来定义 default 数据，以便动态地返回组件的注册参数。"},{"t":"p","c":"函数的 function 会带来一个对象，包含"},{"t":"p","c":" load、url 和 query："},{"t":"l","c":"- load 方法是异步加载函数，使用方法和异步 import 加载一致，可以通过 const data = await load(xxx) 加载异步模块。\n- 通过 load 加载的模块，会有和 load-module 加载一样的效果。load 方法相当于 load-module 组件的函数版，具体使用方法可以查阅https://github.com/kirakiray/drill.js的文档。\n- url 是当前模块的文件名。\n- query 是加载这个模块时的 URL 参数转成的对象。"},{"t":"p","c":"以下是使用 default 的示例："},0,{"t":"p","c":"在这个示例中，我们演示了如何使用 ofa.js 的注册参数来定制化组件的行为。通过合理地配置这些参数，你可以更好地适应不同的组件需求，实现更灵活的组件开发。"},{"t":"p","c":"写一下 组件的注册参数 的 proto 使用文档"}],"life-cycle":[{"t":"h","c":"组件的生命周期"},{"t":"p","c":"在 ofa.js 中，组件生命周期是在特定时间点触发的钩子函数。这些钩子函数让你能更精细地控制和交互，ofa.js 有五个关键生命周期钩子：created、ready、watch、loaded、attached 和 detached，分别在不同时刻触发。"},{"t":"h","c":"生命周期钩子"},{"t":"h","c":"created"},{"t":"p","c":"created 生命周期钩子在组件创建时被触发。在此阶段，组件的数据尚未被初始化，模板内容也未被渲染。你可以在这个阶段执行一些初始化操作，或者准备在后续阶段使用的数据。"},{"t":"h","c":"ready"},{"t":"p","c":"ready 生命周期钩子会在组件的数据和模板刚被初始化后触发，表示组件已经准备就绪。在这个阶段，你可以访问组件的数据，并且模板已经渲染完成，可以执行一些与界面交互相关的操作。"},{"t":"p","c":"如果组件模板存在对其他组件的依赖，这个阶段不会等待依赖加载完成。因此，这个阶段适合为组件添加Loading样式，但需要注意等待依赖加载完成后再执行相关操作。"},{"t":"h","c":"watch"},{"t":"p","c":"一旦 ready 阶段完成，与之关联的 watch 对象中的监听函数会被触发一次。随后，当数据的某个值发生变动时，会再次触发相应键（key）的监听函数。"},{"t":"h","c":"loaded"},{"t":"p","c":"loaded 生命周期钩子在组件模板内的所有依赖都加载完成后触发。这个阶段确保在渲染组件之前，所有的依赖都已经加载完毕。这个时候适合去除在 ready 阶段添加的Loading样式。"},{"t":"h","c":"attached"},{"t":"p","c":"attached 生命周期钩子会在组件被添加到文档中时触发。在这个阶段，适合获取组件内元素的尺寸相关信息，进行数据绑定和全局事件的操作。"},{"t":"h","c":"detached"},{"t":"p","c":"detached 生命周期钩子会在组件从文档中移除时触发。在这个阶段，你可以执行一些清理操作，比如取消事件监听或者释放资源，以防止内存泄漏。"},{"t":"h","c":"示例演示"},{"t":"p","c":"以下是一个示例，展示了如何使用这些生命周期钩子："},0,0,0,{"t":"p","c":"在上面的示例中，我们定义了一个名为 lifecycle-demo 的组件，并且在其模板中放置了一个按钮。通过不同的生命周期钩子，我们可以在控制台中观察到各个阶段触发的日志。"},{"t":"h","c":"生命周期流程图"},0],"web-components":[{"t":"h","c":"封装和组件化：组件化常规知识"},{"t":"p","c":"ofa.js 是一个基于 Web Components 技术的封装库，旨在简化和加速组件开发过程。它通过将复杂的技术细节隐藏在背后，让开发者能够更专注地构建高质量的组件和应用。"},{"t":"p","c":"为了更好地开发组件，有必要学习一些 Web Components 的知识。下面介绍的知识点不仅可以在 ofa.js 中应用，还可以让你在其他使用 Web Components 的框架上同样受益。"},{"t":"h","c":"Shadow DOM 容器"},{"t":"p","c":"在 Web Components 中，Shadow DOM 提供了一种隔离的容器，用于封装组件内部的样式和结构。这意味着组件内部的样式和 DOM 结构不会与外部的样式和结构相互干扰，从而确保组件的可预测性和可维护性。"},{"t":"p","c":"在 ofa.js 中，每个组件都有一个 Shadow DOM 容器，用于隔离组件的内部内容。模板内容就是被渲染到这个容器内。通过 $ 获取的组件实例，也可以使用 shadow 属性访问组件内部的 Shadow DOM 容器，从而实现对组件内部元素的操作和访问。"},0,{"t":"h","c":"Web Components 中的常用 CSS 选择器"},{"t":"p","c":"Web Components 提供了一些特殊的 CSS 选择器，用于选择和样式化组件内部的不同部分。以下是一些常用的选择器："},{"t":"h","c":":host 选择器"},{"t":"p","c":":host 选择器用于选择组件自身的外部容器。可以通过这个选择器来定义组件的样式。"},0,{"t":"h","c":"::slotted() 选择器"},{"t":"p","c":"::slotted() 选择器用于选择被插槽内容包裹的元素。可以在组件内部的样式中使用这个选择器来样式化被插槽的内容。"},0,{"t":"h","c":"插槽（Slot）的使用"},{"t":"p","c":"插槽是 Web Components 中用于在组件内部嵌入外部内容的机制。插槽允许开发者将自定义的内容传递到组件内部，实现更灵活的组件结构。"},{"t":"h","c":"单个插槽"},{"t":"p","c":"在组件模板中，可以使用 <slot> 元素来定义插槽。外部传入的内容会被插入到插槽内部。"},0,0,{"t":"h","c":"多个命名插槽"},{"t":"p","c":"除了默认插槽外，还可以定义多个命名插槽。命名插槽允许开发者将不同的内容插入到不同的插槽位置。"},0,0,{"t":"h","c":"slotchange 事件的使用"},{"t":"p","c":"slotchange 事件在插槽内容变化时触发。可以通过监听这个事件来执行一些与插槽内容相关的操作。"},0],"template-syntax":[{"t":"h","c":"模板语法"},{"t":"p","c":"ofa.js 提供了一系列强大的模板语法，使你能够更灵活地操作组件的界面元素和数据。这些模板语法能够帮助你实现丰富的界面效果和交互体验。"},{"t":"h","c":"渲染文本语法"},{"t":"p","c":"通过使用 {{key}} 的渲染文本语法，你可以将数据渲染为文本内容，并将其嵌入到组件的模板中。当数据发生变化时，对应的文本内容也会自动更新。"},{"t":"p","c":"以下是一个使用文本渲染语法的示例："},0,0,{"t":"p","c":"在上述示例中，{{username}} 将会被组件的 data 中的 username 属性值所替代，从而在界面上显示出 \"Welcome, JohnDoe!\"。"},{"t":"h","c":"属性绑定语法"},{"t":"p","c":"使用 :xxx='yyy' 的属性绑定语法，你可以将组件的属性绑定到模板内元素的属性上。这种绑定是单向的，属性的变化会影响到模板内元素的属性，但不会反过来影响组件的属性。"},{"t":"p","c":"以下是一些常见的属性绑定示例："},0,0,{"t":"p","c":"在上述示例中，:text=\"greeting\" 将组件的 data 中的 greeting 属性值绑定到 <p> 元素的文本内容上。:value=\"inputValue\" 将组件的 data 中的 inputValue 属性值绑定到 <input> 元素的 value 属性上。对于自定义组件，custom-prop 是自定义组件的属性名，它将组件的 data 中的 customValue 属性值传递给自定义组件。"},{"t":"h","c":"事件绑定"},{"t":"p","c":"使用 on:click=\"yyy\" 的形式，你可以将目标元素的指定事件（例如 click）绑定到宿主组件的属性 yyy 上。这样，当目标元素触发指定事件时，会调用宿主组件中相应的属性方法。"},{"t":"p","c":"以下是一个示例："},0,0,{"t":"p","c":"在上述示例中，当按钮被点击时，会调用宿主组件的 increaseCount 方法，从而增加 count 属性的值。"},{"t":"h","c":"attributes 绑定"},{"t":"p","c":"通过 attr:xxx=\"yyy\" 的形式，你可以将目标元素的指定属性 xxx 绑定到宿主组件的属性 yyy 上。这样，目标元素的属性会随着宿主组件的属性变化而变化。"},0,0,{"t":"p","c":"在上述示例中，attr:fontcolor=\"val\" 会将宿主组件的 val 属性绑定到 <div> 元素的 fontcolor attribute上。"},{"t":"h","c":"动态类名绑定"},{"t":"p","c":"使用 class:xxx=\"yyy\" 的形式，你可以根据宿主组件的属性值来动态地为目标元素添加或移除类名。当宿主组件的 yyy 属性为 true 时，目标元素会添加类名 xxx；否则，会移除该类名。"},0,0,{"t":"p","c":"在上述示例中，如果 isActive 属性为 true，则按钮会添加 active 类名，从而应用特定的样式。"},{"t":"h","c":"双向数据绑定"},{"t":"p","c":"通过 sync:xxx='yyy' 的形式，你可以实现双向数据绑定。这使得目标元素的属性 xxx 和宿主组件的属性 yyy 保持同步，即目标属性的变化会反映到宿主属性上，宿主属性的变化也会同步到目标属性上。"},{"t":"p","c":"以下是一个示例："},0,0,{"t":"p","c":"在上述示例中，sync:value=\"inputValue\" 实现了一个双向数据绑定，当输入框的值发生变化时，inputValue 会自动更新；反之，当 inputValue 发生变化时，输入框的值也会随之变化。"}],"template-component":[{"t":"h","c":"模板渲染组件"},{"t":"p","c":"除了能够使用模板语法，ofa.js 还提供了专用于模板内部的渲染组件，包括条件渲染组件和填充渲染组件。"},{"t":"h","c":"条件渲染组件"},{"t":"h","c":"x-if 组件"},{"t":"p","c":"x-if 组件是用来根据条件动态渲染内容的组件。它接受一个 value 属性，根据该属性的值来判断是否渲染其子元素。如果 value 为 true，则渲染子元素，否则不渲染。"},{"t":"p","c":"以下是一个使用 x-if 的示例，用于根据条件渲染不同的内容："},0,0,{"t":"h","c":"x-else 组件"},{"t":"p","c":"x-if 可以与 x-else 配合使用，实现条件切换渲染。"},{"t":"p","c":"以下是一个使用 x-if 和 x-else 的示例，根据不同的条件切换渲染的内容："},0,0,{"t":"h","c":"x-if + x-else-if + x-else 组件"},{"t":"p","c":"x-if 还可以与 x-else-if 和 x-else 组合使用，实现多条件的渲染。"},{"t":"p","c":"以下是一个使用 x-if、x-else-if 和 x-else 的示例，根据多个条件切换渲染的内容："},0,0,{"t":"p","c":"在上述示例中，根据 condition 的不同值，会渲染不同的内容，实现了多条件切换渲染的效果。"},{"t":"h","c":"模板组件之：x-fill"},{"t":"p","c":"x-fill 组件允许你在模板中动态填充内容，可以根据宿主组件的属性值来生成不同的内容。x-fill 组件使用 name 属性来指定要使用的填充模板，并通过 value 属性传递数据给填充模板。"},{"t":"h","c":"x-fill 填充数组字符串的示例"},{"t":"p","c":"以下是一个使用 x-fill 填充数组字符串的示例，通过循环填充不同的字符串内容："},0,{"t":"p","c":"在上述示例中，x-fill 使用名为 fillTemplate 的填充模板，并传递一个数组给它。填充模板中使用了 {{ $data }} 来渲染数组中的每个元素，从而实现了循环填充不同的字符串内容。"},{"t":"h","c":"x-fill 填充对象并且能自举填充的示例"},{"t":"p","c":"x-fill 还可以填充包含更复杂结构的对象，并且支持自嵌套填充。"},{"t":"p","c":"以下是一个使用 x-fill 填充对象并且能自嵌套填充的示例，展示了如何生成嵌套的内容："},0,0,{"t":"p","c":"在上述示例中，x-fill 使用名为 nestedFillTemplate 的填充模板，并传递一个复杂的嵌套对象给它。填充模板中使用了 {{ $data.title }} 来渲染对象的标题，同时又使用了嵌套的 x-fill 来填充子项的内容，实现了嵌套的内容生成。"},{"t":"h","c":"$data、$ele、$host 在模板内的含义"},{"t":"p","c":"在填充模板内，你可以使用特殊的标识符来访问不同的数据："},{"t":"l","c":"- {{ $data }}：表示传递给填充模板的数据，即 value 属性的值。\n- {{ $ele }}：表示当前填充模板所在的元素，可以用于访问元素的属性和样式。\n- {{ $host }}：表示宿主组件的实例，可以用于访问宿主组件的属性和方法。"},{"t":"p","c":"这些特殊标识符可以帮助你在填充模板内动态地访问和渲染不同的数据。在示例中，你可以看到如何使用 {{ $data.title }} 来访问传递的数据的标题，以及如何使用 {{ $host.num }} 来访问宿主组件的属性。"}]},"create-app":{"index":[{"t":"h","c":"开发应用"},{"t":"p","c":"除了可以开发组件，ofa.js 还可以用于开发功能完整的应用程序。"},{"t":"p","c":"ofa.js 将应用程序集成为一个 o-app 组件，通过直接使用这个标签，你就能够快速创建应用程序。这种方式使应用的创建变得简单且高效。"},{"t":"p","c":"此外，ofa.js 官方还提供了完整的路由和SSG（静态页面生成）方案，帮助开发者构建更健全的应用程序。这些功能能够加速开发流程，让你能够专注于应用程序的逻辑和用户体验，而不必过多担心底层细节。"},0,{"t":"p","c":"上面是一个简单的应用教程代码示例，接下来会逐步讲解应用的开发过程。"}],"page":[{"t":"h","c":"开发页面"},{"t":"p","c":"在 ofa.js 内部，我们构建了一个名为 o-page 的自定义组件，旨在为页面的开发提供便利。这个组件在应用开发中扮演着关键的角色。当你想要使用组件的模板语法，但又不想创建全新的组件时，o-page 组件将成为你的最佳选择。"},{"t":"h","c":"页面模块"},{"t":"p","c":"创建一个单文件页面模块时，类似于创建组件模块。使用 template 标签来包裹页面的模板代码，并添加 page 属性。在该标签内部，可以自由使用模板语法与其他组件或页面模块进行交互。"},0,{"t":"p","c":"在 HTML 文件中，使用 o-page 标签的 src 属性指定页面模块的文件路径。页面内容将在该组件内部进行渲染。"},0,{"t":"h","c":"双文件模式"},{"t":"p","c":"双文件模式将 静态模板 和 逻辑代码 分开，使页面的内容更加清晰。"},{"t":"p","c":"以下是使用 o-page 组件和页面模块的步骤："},{"t":"l","c":"1. 创建页面模块："},{"t":"p","c":"与创建组件模块类似，创建一个页面模块，但将 type 属性设置为 $.PAGE。页面模块可用的参数包括 temp、data、proto 和 watch。"},0,{"t":"l","c":"2. 创建页面模板："},{"t":"p","c":"在与页面模块相同的目录下，创建一个名为 my-page-template.html 的页面模板文件。在这个模板文件中，你可以使用模板语法进行交互，用法与前面提到的组件模板语法类似。"},0,{"t":"p","c":"在你的 HTML 文件中，通过 <o-page> 标签来使用 o-page 组件，通过 src 属性引用页面模块的文件路径。页面的内容将会在这个组件内部渲染。"},0,{"t":"p","c":"这样，当你打开页面时，o-page 组件会动态加载 my-page.mjs 这个页面模块，并根据模块中的模板和数据渲染页面内容。页面模块的生命周期和模板语法与组件模块保持一致，使得页面的开发和管理变得更加统一和灵活。"},{"t":"h","c":"判断页面是否加载完成"},{"t":"p","c":"在某些情况下，你可能需要判断页面是否已经完全加载完成，以便执行一些特定的操作。ofa.js 提供了几种方式来判断页面是否加载完成。"},{"t":"h","c":"使用 page._loaded 属性"},{"t":"p","c":"在页面模块中，page._loaded 是一个布尔属性，当页面内容加载完成后，该属性会变为 true。你可以使用这个属性来判断页面是否加载完成。"},0,{"t":"h","c":"使用 page._rendered 属性"},{"t":"p","c":"另一种方式是使用 page.rendered 属性，它是一个 Promise。当页面加载完成后，这个 Promise 会进入 resolve 状态。你可以通过 await page.rendered 来等待页面加载完成，然后执行相应的操作。"},0],"app":[{"t":"h","c":"制作应用"},{"t":"p","c":"使用 o-app 标签可以轻松地创建一个完整的应用程序窗口。下面是如何制作一个应用并配置它的步骤："},{"t":"h","c":"基础代码"},{"t":"l","c":"1. 创建一个 HTML 文件，设置 o-app 标签为应用的显示窗口。确保为 o-app 设置全屏的样式，以使应用占据整个视口。"},0,{"t":"l","c":"2. 创建一个 es 模块，用于设置应用的配置数据。配置数据包括以下选项：\n\n   - home：字符串类型，应用的首页的页面模块地址。\n   - loading：函数类型，应用在加载新页面时，会运行这个函数，得到的内容会插入到应用中，作为加载时的提示，等到页面加载完成后，会自动去除这个 loading 元素。\n   - fail：函数类型，应用加载页面失败时，会运行这个函数，返回得到的值会显示在应用中作为加载失败的提示。函数会带有加载失败页面的 src 地址和错误报错对象。\n   - pageAnime：页面之间切换时的动画配置。"},{"t":"p","c":"下面是应用的配置数据示例："},0,{"t":"l","c":"3. 在 HTML 文件中使用 o-app 标签，并通过 src 属性引用配置数据的 es 模块。"},0,{"t":"p","c":"通过以上步骤，你已经成功制作了一个使用 o-app 组件的应用程序窗口。o-app 组件会根据配置数据中的设置加载页面，展示加载中的提示或加载失败的提示，并支持页面切换动画。这样，你可以快速搭建一个功能完整且具有交互性的应用程序。"},{"t":"h","c":"路由跳转"},{"t":"p","c":"在 o-app 应用中，你可以轻松地实现路由跳转，从一个页面模块跳转到另一个页面模块。下面介绍几种不同的方式来进行路由跳转。"},{"t":"h","c":"使用 <a> 标签进行路由跳转"},{"t":"p","c":"你可以在页面的 HTML 中使用 <a> 标签来实现路由跳转。需要将 href 属性指定为目标页面模块的路径，并添加 olink 属性，以告知 o-app 组件这是一个路由链接。"},0,{"t":"h","c":"goto"},{"t":"p","c":"你可以在页面模板中使用 on:click 属性来绑定点击事件，并调用模块上的 goto 方法进行路由跳转。"},0,{"t":"p","c":"又或者直接卸载目标元素上："},0,{"t":"h","c":"替换跳转和返回页面"},{"t":"p","c":"除了 goto 方法外，o-app 还支持 replace 和 back 方法。"},{"t":"l","c":"- replace 方法用于替换跳转，它会取代当前页面的路由，使新页面成为当前页面的路由。"},0,{"t":"l","c":"- back 方法用于返回到前一个页面。"},0,{"t":"p","c":"需要注意的是，应用内会保持组件的路由状态，但路由数据不会绑定到当前浏览器标签上。这样，你可以方便地在应用中实现页面之间的跳转和导航。"},{"t":"p","c":"如果你想实现路由和页面的绑定，可以使用 o-router 组件，我们将在后面的章节中详细介绍。"},{"t":"p","c":"通过以上方法，你可以在 o-app 应用中实现灵活的路由跳转，让用户能够方便地浏览不同的页面内容。"},{"t":"h","c":"访问应用和当前页面"},{"t":"p","c":"在应用内的各个元素（包括组件），你通过 app 属性来获取它们所在的 o-app 实例。这对于需要与整个应用进行交互的操作非常有用。"},{"t":"p","c":"通过 app.current 属性，你可以获取当前激活的页面模块的地址。"},{"t":"p","c":"以下是一个使用示例："},0,{"t":"p","c":"在上面的示例中，通过选择器 .app 获取了应用标签，然后通过访问 app.current 属性获取了当前激活的页面地址。"},{"t":"h","c":"使用技巧：提前缓存下一页"},{"t":"p","c":"在一些场景下，你可能已经预知用户即将跳转到下一页。为了提高用户体验，你可以提前缓存下一页的页面模块，这样在实际跳转时可以立即加载，减少用户等待的时间，让用户体验更加流畅。。"},{"t":"p","c":"在当前页面的 JavaScript 代码中，调用 load 方法并传入下一页的模块路径，该模块将被加载并缓存。"},0],"subrouting":[{"t":"h","c":"子路由模式"},{"t":"p","c":"在 ofa.js 中，设置子路由与一些前端框架的做法略有不同。ofa.js 使用一种更加直观的方式，通过在页面模块上设置父页面来作为容器，从而实现子路由的需求。"},{"t":"h","c":"设置父页面容器"},{"t":"p","c":"要创建子路由，首先需要在子页面的页面模块上设置 parent 参数，指定父页面的页面模块地址。这样，在子页面加载时，ofa.js 会自动将子页面包裹在父页面容器中。"},0,{"t":"p","c":"在上述示例中，子页面的页面模块通过 parent 参数指定了父页面容器的地址。"},{"t":"h","c":"父页面容器模板设置"},{"t":"p","c":"父页面容器的模板需要设置一个 <slot> 元素，以便子页面能够插入到父页面的指定位置。同时，确保 <slot> 元素的容器元素设置为 position: relative，这是非常重要的，因为子页面会在父页面容器中绝对定位。"},{"t":"p","c":"以下是一个父页面容器的示例模板："},0,{"t":"p","c":"在上述示例中，通过设置一个带有 slot 的容器元素，子页面会被插入到该容器中。确保容器元素具有相对定位，这样子页面可以根据容器定位。"},{"t":"p","c":"通过使用这种方式，你可以更直观地配置子路由，通过设置父页面容器和子页面的关联，来实现子页面的加载和渲染。"},{"t":"h","c":"父页面的路由监听"},{"t":"p","c":"在某些情况下，多个页面共用同一个父页面作为容器，当这些页面之间进行跳转时，父页面不会被刷新。这种情况下，父页面仍然可以监听路由的变动，以便在不刷新页面的情况下执行相应的操作。"},{"t":"h","c":"监听路由变动"},{"t":"p","c":"父页面模块可以设置一个 routerChange 函数，用于监听路由的变动。当页面发生路由切换且不刷新父页面时，将触发 routerChange 事件。这个事件会传递当前页面的信息，以及跳转的方式（type）。"},{"t":"p","c":"以下是一个父页面模块的示例，展示了如何设置 routerChange 函数来监听路由变动："},0,{"t":"p","c":"在上述示例中，routerChange 函数接收两个参数，current 表示当前页面的地址，type 表示跳转的方式。当页面发生路由切换时，该函数会被触发，并输出相应的信息。"}],"o-router":[{"t":"h","c":"o-router 组件的使用"},{"t":"p","c":"o-router 组件是一个用于将 o-app 内的路由绑定到当前浏览器标签页的组件，它能够帮助你更方便地管理页面路由和展示。"},{"t":"h","c":"引用 o-router 组件"},{"t":"p","c":"首先，你需要在页面中引用 o-router 组件。你可以通过以下方式引用 router.mjs 文件："},0,{"t":"h","c":"使用 o-router 组件"},{"t":"p","c":"使用 o-router 组件是通过将其包裹在 o-app 组件外部来实现的。这样可以将应用内的路由绑定到当前浏览器标签上。"},0,{"t":"h","c":"fix-body 属性"},{"t":"p","c":"o-router 组件还提供了 fix-body 属性，当你设置了该属性后，组件会自动为 <html> 标签添加样式，使应用的尺寸等于页面的大小，从而让应用的内容充满整个窗口。"},0],"scsr":[{"t":"h","c":"静态客户端渲染(SCSR)"},{"t":"h","c":"什么是 SCSR？"},{"t":"p","c":"SCSR 全名 Static Client-Side Rendering，称为静态客户端渲染；静态客户端渲染（SCSR）是 CSR（Client-Side Rendering）的一种变种，它在保留了 CSR 用户体验的基础上，还能够让页面在静态状态下被爬虫获取。"},{"t":"h","c":"如何使用 SCSR"},{"t":"p","c":"你可以通过以下方式引用 SCSR 库："},0,{"t":"h","c":"SCSR 的工作原理"},{"t":"p","c":"SCSR 是通过直接运行单文件模式的页面模块，而无需使用 o-page 标签，从而实现在页面上进行渲染。具体来说，就是将页面模块的模板代码直接放在 o-app 内。"},{"t":"p","c":"以下是一个 SCSR 示例，展示了如何在页面上直接渲染页面模块的内容："},0,{"t":"p","c":"通过 SCSR，template 标签内的内容会被直接渲染到页面上，而这部分内容实际上就是单文件模式的页面模块。"},{"t":"p","c":"继续以上面的 home.html 页面为例，我们创建一个 help 页面："},0,{"t":"p","c":"在 home.html 页面中点击 \"GO TO HELP\" 后，将平滑跳转到 help.html 页面，实现了客户端渲染的平滑跳转效果。"},{"t":"h","c":"注意事项"},{"t":"p","c":"所有采用 SCSR 方案的页面，除页面描述性的内容（如 title、meta:description、keywords）和页面模板内容外，其他引用资源必须保持一致，以确保在页面跳转和刷新后的体验一致。"},{"t":"h","c":"关于 SSR 方案"},{"t":"p","c":"当前的 SCSR 方案实际上更类似于一种 SSG（Static Site Generation）方案，因为它将页面预先渲染成静态内容，然后再通过客户端进行交互。ofa.js 已经提供了相对独立的组件封装方案，使得前端开发人员可以将组件封装好，然后结合传统的后端渲染页面方案（如 Node.js、Go、Java、PHP 等语言的网站渲染框架），后端开发人员可以快速使用这些封装好的组件来构建优质的网页。"},{"t":"p","c":"我们计划在未来提供一个完整的 SSR（Server-Side Rendering）方案。这个方案的原理大致是先获取下一页的元素内容，然后与当前页的标签内容进行对比，从而进行动态的增加、删除和修改属性值等操作。不过需要注意的是，这个 SSR 方案会比较耗费时间，因为这个过程涉及到复杂的元素比较和修改操作。"},{"t":"p","c":"ofa.js 是一个新兴的框架，而且作者的业余时间也有限，暂时还没有完整开发出这个 SSR 方案。但如果未来 ofa.js 能够得到更多的用户使用，并且出现了对于 SSR 方案的强烈需求时，作者会继续完善并开发这个方案。目前，作者会专注于框架的稳定性和功能扩展，同时也欢迎用户的反馈和建议，以便未来更好地满足用户的需求。"}]},"others":{"data-sharing":[{"t":"h","c":"数据共享"},{"t":"p","c":"ofa.js与其他第三方框架不同，不采用传统的状态管理模式。作者认为状态更新应该是无感知的，即改变数据后应自动触发数据更新。"},{"t":"p","c":"ofa.js天生就具备出色的数据共享能力，它的实例基于数据共享库 Stanz 进行开发。实例上的对象都是可同步的。如果要实现数据共享，只需创建一个独立的 Stanz 对象，然后让所有组件直接引用即可。"},{"t":"p","c":"下面的案例展示了如何共享数据："},0,0,0,0,{"t":"p","c":"在上述示例中，两个组件在 attached 生命周期时，将数据写入到组件本身。然后，组件的 obj 就成为共享数据。在 detached 生命周期后，将之前共享的数据设置为 null，以确保数据得到回收。"},{"t":"h","c":"注意事项"},{"t":"p","c":"由于数据是共享的，务必要确保在适当的时候回收数据，以避免内存泄漏。"},0],"about-micro-frontend":[{"t":"h","c":"关于微前端"},{"t":"p","c":"微前端是一种前端架构模式，旨在帮助团队更好地构建和维护大型、复杂的前端应用程序。它借鉴了微服务架构的思想，将前端应用程序拆分为更小的独立部分，每个部分都可以由不同的团队开发、测试和部署。"},{"t":"p","c":"在传统的单体前端应用不断扩展的过程中，可能会变得难以维护和扩展。微前端的目标是通过将应用拆分成更小、更可管理的模块，使得开发团队能够独立地开发和部署这些模块，从而提高团队的效率和应用的可维护性。"},{"t":"p","c":"ofa.js 天生具备微前端的特性，它与其它框架的不同之处在于，基于 ofa.js 开发的组件、页面和应用无需预编译。相比于一些框架如 React、Vue 和 Angular 等，它们需要在 Node.js 环境下进行一次构建，生成用于客户端的代码。然而，ofa.js 的开发代码可以直接放置在静态服务器上，无需额外的构建步骤，就能实时查看、使用和运行。"},{"t":"p","c":"ofa.js 符合了微前端的五个核心特点："},{"t":"l","c":"1. 独立部署：每个组件和页面都可以独立地开发、测试和部署，这使得团队能够更迅速地发布新功能和解决问题。\n\n2. 集成：基于 ofa.js 开发的应用，可以将不同的模块组合在一起。这可以通过应用、页面、组件等方式共享组合。\n\n3. 独立团队：每个前端模块（组件/页面/应用）可以由独立的团队进行开发和维护，从而鼓励团队的自主性和创新。\n\n4. 共享资源：在 ofa.js 项目中，通常会存在一些共享的资源，如样式、组件、页面等，以确保一致性和效率。\n\n5. 按需加载：ofa.js 的应用可以根据需要加载模块，从而提升应用的性能和加载速度。"},{"t":"p","c":"尽管 ofa.js 无法直接使用 Vue 和 React 等框架开发的组件，但基于 ofa.js 开发的组件可以被 Vue 和 React 使用，这为不同技术栈的开发人员提供了更强的灵活性和扩展性。"},{"t":"p","c":"在 Vue 中使用 Web Components："},{"t":"l","c":"- Vue Web Component Wrapper\n- 将 Vue 与 Web Components 集成\n- 如何在 Vue 中使用 Web Components"},{"t":"p","c":"在 React 中使用 Web Components："},{"t":"l","c":"- 与 React 一起使用 Web Components\n- 在 React 中使用 Web Components\n- 将 Web Components 集成到 React 中"}]}},"others":{"data-sharing":[{"t":"h","c":"数据共享"},{"t":"p","c":"ofa.js与其他第三方框架不同，不采用传统的状态管理模式。作者认为状态更新应该是无感知的，即改变数据后应自动触发数据更新。"},{"t":"p","c":"ofa.js天生就具备出色的数据共享能力，它的实例基于数据共享库 Stanz 进行开发。实例上的对象都是可同步的。如果要实现数据共享，只需创建一个独立的 Stanz 对象，然后让所有组件直接引用即可。"},{"t":"p","c":"下面的案例展示了如何共享数据："},0,0,0,0,{"t":"p","c":"在上述示例中，两个组件在 attached 生命周期时，将数据写入到组件本身。然后，组件的 obj 就成为共享数据。在 detached 生命周期后，将之前共享的数据设置为 null，以确保数据得到回收。"},{"t":"h","c":"注意事项"},{"t":"p","c":"由于数据是共享的，务必要确保在适当的时候回收数据，以避免内存泄漏。"},0],"about-micro-frontend":[{"t":"h","c":"关于微前端"},{"t":"p","c":"微前端是一种前端架构模式，旨在帮助团队更好地构建和维护大型、复杂的前端应用程序。它借鉴了微服务架构的思想，将前端应用程序拆分为更小的独立部分，每个部分都可以由不同的团队开发、测试和部署。"},{"t":"p","c":"在传统的单体前端应用不断扩展的过程中，可能会变得难以维护和扩展。微前端的目标是通过将应用拆分成更小、更可管理的模块，使得开发团队能够独立地开发和部署这些模块，从而提高团队的效率和应用的可维护性。"},{"t":"p","c":"ofa.js 天生具备微前端的特性，它与其它框架的不同之处在于，基于 ofa.js 开发的组件、页面和应用无需预编译。相比于一些框架如 React、Vue 和 Angular 等，它们需要在 Node.js 环境下进行一次构建，生成用于客户端的代码。然而，ofa.js 的开发代码可以直接放置在静态服务器上，无需额外的构建步骤，就能实时查看、使用和运行。"},{"t":"p","c":"ofa.js 符合了微前端的特点："},{"t":"l","c":"1. 独立部署：每个组件和页面都可以独立地开发、测试和部署，这使得团队能够更迅速地发布新功能和解决问题。\n\n2. 集成：基于 ofa.js 开发的应用，可以将不同的模块组合在一起。这可以通过应用、页面、组件等方式共享组合。\n\n3. 独立团队：每个前端模块（组件/页面/应用）可以由独立的团队进行开发和维护，从而鼓励团队的自主性和创新。\n\n4. 共享资源：在 ofa.js 项目中，通常会存在一些共享的资源，如样式、组件、页面等，以确保一致性和效率。\n\n5. 按需加载：ofa.js 的应用可以根据需要加载模块，从而提升应用的性能和加载速度。"},{"t":"p","c":"尽管 ofa.js 无法直接使用 Vue 和 React 等框架开发的组件，但基于 ofa.js 开发的组件可以被 Vue 和 React 使用，这为不同技术栈的开发人员提供了更强的灵活性和扩展性。"},{"t":"p","c":"在 Vue 中使用 Web Components："},{"t":"l","c":"- Vue Web Component Wrapper\n- 将 Vue 与 Web Components 集成\n- 如何在 Vue 中使用 Web Components"},{"t":"p","c":"在 React 中使用 Web Components："},{"t":"l","c":"- 与 React 一起使用 Web Components\n- 在 React 中使用 Web Components\n- 将 Web Components 集成到 React 中"}]}}