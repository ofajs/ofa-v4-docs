{"cases":{"index":[0,{"t":"h","c":"Empezar rápido"},{"t":"p","c":"Para empezar, simplemente integra el proyecto ofajs en tu proyecto mediante la URL del CDN:"},0,{"t":"p","c":"Esta es un ejemplo sencillo que muestra cómo usar ofa.js para modificar el contenido de elementos DOM:"},{"t":"h","c":"Método de uso"},{"t":"p","c":"Después de importar ofa.js, se registrará el símbolo $ en el ámbito global. Puedes seleccionar el primer elemento que cumpla con la condición usando $('xxx'), donde xxx es el contenido estándar de selector CSS."},{"t":"p","c":"En el ejemplo anterior, utilizamos el símbolo $ para seleccionar tres elementos con diferentes id, y modificamos su contenido estableciendo las propiedades text, html y value."},{"t":"p","c":"Para obtener más información sobre las propiedades y métodos disponibles, consulte la documentación de la API."}],"event":[0,{"t":"h","c":"Respuesta a eventos"},{"t":"p","c":"Puede utilizar el método on para vincular eventos. Los eventos son el concepto más básico en el desarrollo, ya que las aplicaciones requieren eventos para generar respuestas y lograr la interactividad."},{"t":"p","c":"A continuación se muestra un ejemplo de cómo vincular eventos de clic:"},{"t":"p","c":"En este ejemplo, seleccionamos el elemento 'button' usando '$' y vinculamos el evento 'click' usando el método 'on'. Cuando se hace clic en el botón, se activará una función de devolución de llamada para cambiar el contenido de texto del elemento 'target' a '¡Hola, mundo!'. "},{"t":"p","c":"Si quieres conocer más tipos de eventos disponibles, consulta la documentación de Eventos."}],"simple-component":[0,{"t":"h","c":"Component creation and usage"},{"t":"p","c":"Una vez que se complete la carga de ofa.js, se registrará globalmente un componente llamado load-module, que se puede referenciar utilizando la abreviatura l-m. Su uso es similar a la etiqueta script, mediante el uso del atributo src para referenciar la dirección de tu componente desarrollado."},{"t":"p","c":"Now, let's start creating our own component. Firstly, create an HTML file with a name that matches the component name."},{"t":"p","c":"En el archivo del componente, primero agregue un elemento template y agregue el atributo component. Coloque el contenido que el componente necesita renderizar dentro de este elemento template. Finalmente, este contenido se renderizará en el Shadow DOM del componente, el cual está aislado del entorno externo para evitar contaminar el entorno externo."},{"t":"p","c":"Next, simply use the 'l-m' component to reference your developed component. On the page, directly use the component tag that you have defined."},{"t":"p","c":"It is important to note that the registered component name can only use lowercase letters and the hyphen '-' symbol, and must contain at least one '-'. This naming rule must be followed."},{"t":"p","c":"A través de este ejemplo, puedes aprender cómo crear un componente llamado my-comp y usarlo en otra página. También puedes establecer el estilo del componente mediante la vinculación de una hoja de estilo externa."}],"attribute-transmission":[0,{"t":"h","c":"Transmisión de características"},{"t":"p","c":"El parámetro attrs y el parámetro data son similares en funcionalidad, los datos establecidos en attrs se fusionarán en data, pero los datos en attrs se mostrarán en las propias características del componente."},0,{"t":"p","c":"Cuando se utiliza un componente externo, también se pueden pasar datos al interior del componente a través de atributos. Es importante tener en cuenta que los datos pasados a través de atributos solo pueden ser de tipo cadena de caracteres."}],"slot":[0,{"t":"h","c":"Component slots"},{"t":"p","c":"By adding '<slot></slot>' tags in the template, the content can be placed in the slot inside the corresponding component tag when using the component."},{"t":"p","c":"Custom components do not have the 'display' property defined by default, so it needs to be manually defined for the component. In the component's style, the ':host' selector can be used to add styles to the component itself."},{"t":"p","c":"Este ejemplo muestra cómo crear un componente llamado simple-btn. La plantilla del componente incluye un slot donde puedes insertar contenido en el componente. Puedes añadir estilos al componente mediante el selector :host. En otra página, puedes utilizar el componente l-m para referenciar el componente simple-btn e insertar contenido en él."}],"render-text":[0,{"t":"h","c":"Renderizado de Texto"},{"t":"p","c":"En el archivo del componente, se puede agregar una etiqueta script para escribir el código lógico del componente. A través del objeto default expuesto, se pueden configurar los parámetros del componente."},{"t":"p","c":"Entre ellas. data parámetro es utilizado para definir los datos predeterminados de los componentes. Una vez que se ha instanciado, puedes utilizar la sintaxis de plantilla."},{"t":"p","c":"La representación de texto se realiza mediante llaves dobles, es decir {{xxx}}, donde xxx representa el nombre del atributo del componente."},{"t":"p","c":"El caso de uso demuestra cómo representar la propiedad \"val\" de elementos de componentes:"}],"get-set-comp":[0,{"t":"h","c":"Obtener y modificar los valores de la instancia del componente"},{"t":"p","c":"Desde el exterior, también puedes obtener o modificar los datos del componente."},{"t":"p","c":"El ejemplo muestra cómo manipular los datos del componente desde el exterior;"}],"property-transmission":[0,{"t":"h","c":"Propiedad de Transmisión"},{"t":"p","c":"Con la sintaxis de propiedad de transmisión, se puede aplicar los datos del componente a los atributos de los elementos en la plantilla."},{"t":"p","c":"La forma de utilizarlo es agregar el atributo :name=\"key\" en el elemento, donde name es el nombre del atributo que se desea establecer en el elemento de destino, y key es el nombre clave de la propiedad que se pasa desde el componente personalizado."},{"t":"p","c":"Antes mencioné <a href='./index.html' olink>la forma de utilizar selectores para establecer atributos</a>, mientras que lo que se presenta aquí es la sintaxis de transmisión de atributos para establecer atributos;"}],"bind-event":[0,{"t":"h","c":"Bindings de eventos"},{"t":"p","c":"Dentro de un componente, puedes usar la propiedad on para realizar bindings de eventos y dotar al componente de capacidad interactiva. Aquí se muestra cómo realizar bindings de eventos dentro de un componente para lograr efectos interactivos."},{"t":"p","c":"El parámetro proto se utiliza para definir los métodos propios del componente, estos métodos se pueden utilizar dentro del componente o ejecutarse desde el exterior después de obtener el componente a través del selector."},{"t":"p","c":"El xxx después de on:click=\"xxx\" puede ser el nombre del método definido dentro del componente o una expresión de función. Si se utiliza una expresión de función, no es necesario escribir explícitamente la palabra clave this, el ámbito de la variable se enlazará automáticamente con el propio componente."},{"t":"p","c":"Si quieres conocer más tipos de eventos disponibles, consulta la documentación de Eventos."}],"nested-component":[0,{"t":"h","c":"Componentes anidados"},{"t":"p","c":"Poner toda la lógica en un solo componente no es una elección sabia; podemos dividir la lógica en componentes separados y luego importar otro componente mediante l-m para usarlo;"},{"t":"p","c":"En el ejemplo, se importa un componente anidado llamado CompTwo utilizando <l-m src=\"./comp-two.html\"></l-m>."},{"t":"p","c":"Se utiliza el componente anidado mediante <comp-two :txt=\"val\"></comp-two> y se pasa la propiedad val del componente actual como propiedad txt al componente anidado. De esta manera, el componente anidado puede utilizar los datos pasados para renderizar."},{"t":"p","c":"En <comp-two></comp-two>, se utiliza el componente anidado sin pasar ninguna propiedad. La forma en que se utiliza depende de la lógica y el diseño del componente anidado en sí."},{"t":"p","c":"Una vez que un componente se carga correctamente, se puede utilizar en cualquier lugar utilizando su nombre correspondiente. Incluso si se carga el mismo componente varias veces en diferentes lugares usando el componente 'l-m', no se volverá a cargar. Este mecanismo garantiza la reutilización y consistencia de los componentes."}],"inject-host":[0,{"t":"h","c":"Componente inject-host"},{"t":"p","c":"Debido al aislamiento de los Web Components, es difícil modificar directamente el estilo de los elementos en el slot de un componente. Para hacer frente a este problema, ofa.js proporciona un componente llamado inject-host; este componente inyectará estilos en la capa principal para configurar la apariencia del componente de forma más flexible."},{"t":"p","c":"Es importante tener en cuenta que el uso de este componente puede afectar el estilo de la capa principal. Por lo tanto, al invadir el estilo, se debe mantener una convención de nomenclatura para evitar afectar el estilo de la capa principal."},{"t":"p","c":"En el ejemplo, definimos un componente llamado comp-two, que utiliza el componente inject-host para inyectar estilos. Esto nos permite ajustar los estilos de los elementos dentro del componente comp-two mediante los estilos inyectados, sin afectar a otros componentes."},{"t":"p","c":"Al mismo tiempo, también debemos tener en cuenta lo siguiente:"},{"t":"l","c":"- Al agregar una etiqueta <style> dentro de inject-host, podemos definir estilos específicos para el componente. Estos estilos solo afectarán a los elementos del componente actual y no se extenderán a otros componentes.\n- Al inyectar estilos, se deben evitar selectores demasiado generales para no afectar el estilo de otros componentes. Es importante mantener la singularidad y especificidad de los selectores.\n- inject-host también puede inyectar hojas de estilo externas usando la siguiente sintaxis: <link rel=\"stylesheet\" href=\"target/style.css\">."},{"t":"p","c":"En todo el ejemplo, utilizando el componente 'comp-two' dentro de 'inject-host', podemos establecer y aplicar de manera flexible los estilos internos del componente sin interferir con los estilos de otros componentes."}],"event-passing":[0,{"t":"h","c":"Evento de transferencia"},{"t":"p","c":"Además de escuchar eventos nativos, on también se puede utilizar para escuchar eventos personalizados, lo cual es importante para la comunicación de eventos entre componentes. Los eventos personalizados se desencadenan mediante el método emit. Al desencadenar un evento personalizado, se pueden enviar datos personalizados al receptor."},{"t":"p","c":"Si es necesario atravesar los límites del Shadow DOM del componente para desencadenar un evento, se puede agregar el atributo composed."},{"t":"p","c":"En el siguiente ejemplo, aprenderemos cómo utilizar el método emit para pasar eventos entre componentes anidados."}],"sync":[0,{"t":"h","c":"Doble enlace de datos"},{"t":"p","c":"Al utilizar la sintaxis sync, puede establecer una asociación bidireccional en tiempo real entre los elementos interactivos de la interfaz de usuario (como cuadros de texto o componentes personalizados) y el modelo de datos."},{"t":"p","c":"El siguiente ejemplo muestra cómo utilizar la propiedad sync en un componente para lograr una sincronización bidireccional entre un cuadro de texto y un modelo de datos:"},{"t":"l","c":"- En el parámetro data, se define el dato con el nombre testText y se le asigna un valor inicial de \"Soy testText\".\n- La declaración sync:value=\"testText\" establece una vinculación bidireccional entre el valor del cuadro de texto y el dato testText. Por lo tanto, cuando el usuario ingresa contenido en el cuadro de texto, el dato testText se actualiza en tiempo real y viceversa.\n- De manera similar, la declaración sync:txt=\"testText\" establece una vinculación bidireccional entre la propiedad txt del componente personalizado y el dato testText. Cuando la propiedad txt del componente cambia, el dato testText se actualiza en tiempo real y viceversa."},{"t":"p","c":"A través de la sincronización bidireccional de datos, puede establecer fácilmente una conexión entre la interfaz de usuario y el modelo de datos, lo que permite que los cambios en los datos se reflejen automáticamente en la interfaz y que las entradas del usuario en la interfaz afecten de inmediato al modelo de datos."},{"t":"p","c":"Es importante tener en cuenta que la sincronización de datos solo puede transferir cadenas de texto o números, no puede transferir otros tipos de datos."}],"condition":[0,{"t":"h","c":"renderizado condicional"},{"t":"p","c":"Dentro de las plantillas hay componentes de plantilla además de la sintaxis de plantilla;"},0,{"t":"p","c":"La renderización condicional le permite insertar contenido diferente en un componente dinámicamente en función de una condición específica. A continuación se muestra un ejemplo de cómo utilizar la renderización condicional dentro de un componente."},{"t":"p","c":"En este ejemplo, creamos un componente llamado test-demo. El componente contiene un botón que, al hacer clic, incrementará la propiedad count. Usando las etiquetas <x-if>, <x-else-if> y <x-else>, implementamos la lógica de la renderización condicional."},{"t":"l","c":"- La etiqueta <x-if> recibe un atributo value para definir la condición. Si el valor de value es true, se renderiza el contenido dentro de <x-if>. En este ejemplo, si count es par, aparecerá un texto rojo.\n- La etiqueta <x-else-if> también recibe un atributo value para definir la condición. Si la condición anterior no se cumple y el valor de value es true, se renderiza el contenido dentro de <x-else-if>. En este ejemplo, si count es un múltiplo de 3, aparecerá un texto azul.\n- La etiqueta <x-else> no requiere un atributo value, se renderizará su contenido cuando ninguna de las condiciones anteriores se cumpla. En este ejemplo, si count no es par ni un múltiplo de 3, aparecerá un texto verde. También se puede usar x-else inmediatamente después de x-if;"},{"t":"p","c":"De esta manera, puede renderizar contenido diferente dinámicamente según diferentes condiciones, logrando un efecto de interacción y presentación flexible."}],"fill":[0,{"t":"h","c":"Relleno"},{"t":"p","c":"Las plantillas de relleno (x-fill) en un framework frontend son similares al concepto de renderizar listas, ya que le permiten renderizar dinámicamente un conjunto de componentes minúsculos basados en una colección de datos."},{"t":"p","c":"Durante el proceso de relleno, puede utilizar las siguientes variables especiales:"},{"t":"l","c":"- $data: representa los datos del elemento de relleno. Al manipular $data, puede obtener o modificar los datos de cada elemento de relleno.\n- $index: representa el índice del elemento de datos actual en la colección de datos.\n- $host: representa el componente actual en sí mismo. Si desea obtener los datos del componente o llamar a sus métodos, debe utilizar $host para acceder al componente."}],"fill-temp":[0,{"t":"h","c":"Relleno y Renderización recursiva"},{"t":"p","c":"La renderización de relleno le permite utilizar plantillas independientes para renderizar datos y agregarles un nombre usando el elemnto <template> con el atributo name. Esto le permite renderizar datos con estructuras anidadas y crear componentes más complejos."},{"t":"p","c":"Cuando utiliza el relleno x-fill, simplemente necesita pasar el nombre de la plantilla correspondiente al atributo name para renderizar el contenido de la plantilla independiente. Además, la renderización de relleno también admite relleno recursivo, lo que significa que puede seguir utilizando el mismo nombre de plantilla dentro de la plantilla para una renderización anidada."},{"t":"p","c":"En el ejemplo, hemos definido una plantilla independiente llamada item y hemos pasado el nombre de la plantilla correspondiente al usar x-fill. De esta manera, cada elemento en los datos se renderizará utilizando esta plantilla y la plantilla puede volver a usar el mismo nombre para el relleno recursivo. Esto le permite manejar datos con estructuras anidadas de manera flexible y lograr una renderización de componentes más compleja."}],"life-cycle":[0,{"t":"h","c":"Ciclo de vida"},{"t":"p","c":"Los hooks del ciclo de vida proporcionan la oportunidad de ejecutar código en diferentes etapas del componente. En ofa.js, hay cinco hooks principales del ciclo de vida que son: created, ready, watch, attached y detached."},{"t":"l","c":"- created(): Se llama cuando se crea el componente, en este momento el shadow root aún no se ha renderizado. Puede realizar algunas configuraciones de inicialización aquí, pero no puede acceder a los elementos dentro del shadow root.\n  \n- ready(): Se llama después de que se haya completado la renderización del shadow root, generalmente se utiliza para la lógica de inicialización del componente. En esta etapa, puede acceder y manipular los elementos dentro del shadow root, así como realizar otras operaciones que necesite realizar después de la renderización.\n\n- watch: Utilice el objeto watch para estar atento a los cambios en los datos. Después de que se complete ready, se activará una vez el watch correspondiente al valor en data. Luego, cada vez que el valor de la clave correspondiente cambie, se activará la función correspondiente dentro de watch.\n\n- attached(): Se llama cuando el componente se agrega al documento, en este momento puede realizar operaciones de interacción con el entorno externo, como obtener la apariencia del componente o inicializar la lógica de datos compartidos.\n\n- detached(): Se llama cuando el componente se elimina del documento. En esta etapa, puede realizar tareas de limpieza, cancelar la interacción con el entorno externo y liberar recursos."}],"form-data":[0,{"t":"h","c":"Datos del formulario"},{"t":"p","c":"En muchas aplicaciones, manejar datos del formulario es una tarea común. Para simplificar este proceso, ofa.js proporciona una segunda abstracción para manejar datos de formularios, ofreciendo el método formData. Con este método, puedes mapear fácilmente los valores de los elementos del formulario a un objeto y, cuando los valores de los elementos del formulario cambian, actualizar automáticamente los datos de este objeto y viceversa."},{"t":"p","c":"Usando el atributo shadow, puedes acceder al contenido del Shadow DOM del componente. Esto te permite acceder y manipular los elementos y estilos dentro del Shadow DOM desde el interior del componente."},{"t":"p","c":"En este ejemplo, podemos ver cómo utilizar el método formData para mapear automáticamente los datos del formulario al objeto fdata. Esto le permite obtener o modificar los valores de los elementos del formulario mediante la manipulación del objeto fdata, y estos cambios se sincronizarán automáticamente con los elementos del formulario correspondientes."}],"custom-form-element":[0,{"t":"h","c":"Componentes de formulario personalizados"},{"t":"p","c":"Con ofa.js, puede desarrollar con facilidad componentes de elementos de formulario personalizados con las características estándar de un formulario. Solo necesita agregar el atributo value y configurar el atributo name a su componente personalizado, y este podrá usarse como un elemento de formulario estándar. Al actualizar el atributo value del componente, puede interactuar con el elemento del formulario."},{"t":"p","c":"Al inicializar formData, se debe agregar la característica de selector personalizada al parámetro (aunque el parámetro predeterminado de formData es \"input,select,textarea\"). De esta manera, formData puede interactuar con el componente personalizado."},{"t":"p","c":"En este ejemplo, usamos el componente personalizado custom-input para crear un cuadro de texto editable. Este componente se utiliza como un elemento de formulario y utiliza la propiedad value para la interacción de datos. Al utilizar el método formData, agregamos \"input,custom-input\" como parámetro para inicializar correctamente los datos del formulario."}],"use-page":[0,{"t":"h","c":"Usando componentes de página"},{"t":"p","c":"Una vez que se carga 'ofa.js', se añade automáticamente un componente de página llamado 'o-page'. Este componente se utiliza para cargar módulos de página, que son un tipo especial de módulos de componente y no se registran como etiquetas personalizadas, sino que se cargan a través del componente 'o-page'."},{"t":"p","c":"Los módulos de página son similares a los módulos de componente, pero tienen algunas diferencias. Los módulos de página utilizan la propiedad 'page' para definir la plantilla en lugar de la propiedad 'component'. La lógica de desarrollo de los módulos de página es similar a la de los módulos de componente y utiliza la misma sintaxis y componentes de plantilla. Sin embargo, los módulos de página no pueden utilizar el atributo 'attrs', ya que los parámetros de la página suelen pasarse a través de la URL en lugar de a través de 'data' o 'attrs'."},{"t":"p","c":"En el ejemplo, el componente o-page se utiliza para cargar el módulo de la página page.html. En el módulo de la página, se utiliza el atributo page para definir la plantilla y luego se devuelve un objeto a través de una función de JavaScript para establecer los datos. Los parámetros de consulta count de la URL se pasan al módulo de la página y se utilizan para inicializar los datos. Los eventos de clic en los botones dentro de la página pueden actualizar los datos y mostrarlos en la página."}],"use-app":[0,{"t":"h","c":"Uso del componente app"},{"t":"p","c":"En ofa.js, puede utilizar el componente o-app para crear la estructura de diseño de toda la aplicación y cargar módulos de página dentro de él. Al utilizar los componentes o-app, o-page y módulos de página, puede construir la estructura de página de toda la aplicación e implementar la navegación entre páginas"},{"t":"p","c":"Cuando el componente o-page esté dentro de o-app, puedes usar la etiqueta <a> con el atributo olink para realizar la navegación entre páginas. Esta navegación no afectará a la página actual, en su lugar se realizará dentro de o-app, similar a usar <iframe>."},{"t":"p","c":"Si el componente o-page está dentro de o-app, también puedes utilizar los siguientes métodos:"},{"t":"l","c":"- El método goto para navegar a una página.\n- El método back para regresar a la página anterior.\n- El método replace para realizar una navegación de reemplazo en la página actual."},{"t":"p","c":"Usando el componente o-app, puedes construir la estructura de diseño de toda la aplicación y cargar diferentes módulos de página en ella. Además, la funcionalidad de enrutamiento proporcionada por o-app permite una navegación fácil y flexible entre páginas."},{"t":"p","c":"En este ejemplo, creamos una estructura de aplicación utilizando el componente o-app y luego cargamos un módulo de página llamado page1.html en él."},{"t":"p","c":"En el módulo de página page1.html, definimos un título y un botón. Al hacer clic en el botón, se navegará a otro módulo de página llamado page2.html. También agregamos un enlace con el atributo olink, que navegará a page2.html al hacer clic en él."},{"t":"p","c":"En la página del módulo page2.html, también hemos definido un título y un botón. Al hacer clic en el botón, se regresará a la página anterior, logrando la navegación de la página."}],"app-config":[0,{"t":"h","c":"Configurar parámetros de la aplicación"},{"t":"p","c":"Puede configurar los parámetros de la aplicación proporcionando un módulo externo para la etiqueta o-app.\nEstos parámetros son un módulo ES donde puede configurar los siguientes parámetros:"},{"t":"l","c":"- home: La página de inicio de la aplicación, es decir, la página que se muestra al cargar inicialmente.\n- loading: Contenido que se muestra mientras se carga el módulo cuando se hace clic en un enlace de la página de la aplicación. Puede proporcionar una cadena de texto como contenido de carga.\n- pageAnime: Efecto de animación al cambiar de página, utiliza un objeto que contiene propiedades de estilo CSS.\n  - current: Estilo de la página actual.\n  - next: Estilo de la página que está ingresando.\n  - previous: Estilo de la página que está saliendo."},{"t":"p","c":"De esta manera, puedes personalizar la página de inicio, el estilo de carga y las animaciones de transición de página, entre otros parámetros, según las necesidades de tu aplicación, brindando así una experiencia más personalizada."}],"app-loading":[0,{"t":"h","c":"Personalizar la carga de la aplicación"},{"t":"p","c":"A continuación se muestra un ejemplo de personalización de carga para el componente 'o-app'. En este ejemplo, hemos creado una barra de progreso que aumenta gradualmente durante la carga de la página y alcanza el 100% una vez que se completa la carga, luego se elimina el elemento de carga."},{"t":"p","c":"Puede copiar y utilizar el siguiente código para personalizar el efecto de carga de su aplicación:"},0,{"t":"p","c":"A través de este código, puedes agregar un efecto de carga único a tu aplicación para que los usuarios tengan una mejor experiencia durante el cambio de páginas."}],"set404":[0,{"t":"h","c":"Configuración de la página 404"},{"t":"p","c":"En el módulo de configuración de la aplicación, se puede personalizar el contenido que se muestra cuando la página no se puede cargar mediante la función fail."},{"t":"p","c":"En este ejemplo, cuando la página no se puede cargar, se mostrará la primera línea del mensaje de error."},0],"use-hash-router":[0,{"t":"h","c":"Using hash router"},{"t":"p","c":"Solo necesitas utilizar el componente o-router para asociar las rutas dentro del componente app con la página web actual. Una vez que la página y la ruta estén vinculadas, incluso después de recargar la página, el estado de la ruta se mantendrá."},{"t":"p","c":"En este ejemplo, haz clic en el botón <span style='font-family: \"iconfont\"'>&#xe7cb;</span> para abrirlo en una nueva página y probar."},0],"use-scsr":[0,{"t":"h","c":"Usando el esquema SCSR"},{"t":"p","c":"En este ejemplo, haz clic en el botón <span style='font-family: \"iconfont\"'>&#xe7cb;</span> para abrirlo en una nueva página y probarlo;"},{"t":"p","c":"SCSR, cuyo nombre completo es Representación de Cliente en el lado del Cliente Estático (Static Client-Side Rendering, en inglés), es una variante de RSC en el que, además de mantener la experiencia de usuario de RSC, permite que las páginas sean rastreadas por los motores de búsqueda en su estado estático."},{"t":"p","c":"La web actual está construida utilizando el esquema SCSR;"},{"t":"p","c":"SCSR renderiza el módulo de página en modo de archivo único sin necesidad de utilizar la etiqueta o-page, específicamente anidando el código de plantilla del módulo de página directamente dentro de o-app."},{"t":"h","c":"Consideraciones"},{"t":"p","c":"Para todas las páginas que utilizan el esquema SCSR, aparte del contenido descriptivo de la página (como título, meta: descripción, palabras clave) y el contenido de la plantilla de la página, todos los recursos referenciados deben mantenerse consistentes para asegurar una experiencia de usuario coherente después de la navegación y actualización de la página."}]},"docs":{"introduce":[{"t":"h","c":"ofa.js - Marco progresivo de front-end"},{"t":"h","c":"Qué es ofa.js"},{"t":"p","c":"ofa.js is a progressive front-end framework designed to allow developers to enter front-end development and usage processes with minimal cost. It provides a series of simple and powerful tools and APIs that make front-end development more efficient and convenient."},{"t":"h","c":"razón de ser"},{"t":"h","c":"Sustituye a jQuery"},{"t":"p","c":"In many small projects, we may not need to introduce large frameworks like React and Vue, but prefer to use jQuery for simple front-end operations. ofa.js improves the API of jQuery and replaces many of jQuery's methods with properties, making the use of ofa.js more suitable in many scenarios."},{"t":"h","c":"Streamline front-end development and usage processes"},{"t":"p","c":"The goal of ofa.js is to simplify the cumbersome front-end development process. It allows developers to build front-end applications faster without having to learn complex tools such as Node.js, npm, and scaffolding. With it, you can go back to the experience of developing with just one library."},{"t":"h","c":"Convertirse en un marco de desarrollo front-end"},{"t":"p","c":"ofa.js aims to be a \"silver bullet\" that can solve a variety of front-end development problems and provide comprehensive solutions. It is not just a toolbox, but a comprehensive front-end development framework."},{"t":"h","c":"especificidades"},{"t":"h","c":"Desarrollo de componentes fácil de usar"},{"t":"p","c":"There is almost no learning cost for developing components using ofa.js. ofa.js provides a concise and intuitive API that allows developers to quickly create and integrate components while keeping the code clean and easy to maintain."},{"t":"h","c":"Modularidad incorporada, actualizaciones de estado y soluciones de integración de aplicaciones."},{"t":"p","c":"ofa.js has built-in solutions for modularization, state updates, and application integration, allowing developers to complete complex front-end development tasks without having to look for third-party libraries or tools."},{"t":"h","c":"Se ofrecen soluciones oficiales de enrutamiento y SSG (Static Site Generation)."},{"t":"p","c":"ofa.js also provides official solutions for routing and SSG (static site generation), helping developers better manage front-end routing and generate static sites, improving application performance and SEO friendliness."},{"t":"h","c":"Racionalización del tamaño del código"},{"t":"p","c":"ofa.js's code has been carefully optimized, and the size of the .min file after compression is only 38kb (only 14kb under gzip). This makes ofa.js an efficient front-end framework that can be quickly loaded and used in various network environments."}],"get-started":{"index":[{"t":"h","c":"Primeros pasos"},{"t":"h","c":"Cómo usar"},{"t":"h","c":"Referencia directa"},{"t":"p","c":"Puedes agregar el ofa.js directamente a tu página utilizando la dirección del CDN:"},0,{"t":"h","c":"Instalar mediante npm"},{"t":"p","c":"Primero, instala ofa.js en tu proyecto:"},0,{"t":"p","c":"Luego, importa el módulo ofa.js en tu proyecto:"},0,{"t":"h","c":"Uso"},{"t":"p","c":"Después de agregar los recursos, ofa.js establecerá una propiedad $ en el ámbito global, todas las funciones estarán disponibles en $, y el siguiente tutorial explicará su uso en detalle;"},{"t":"p","c":"En general, recomendamos añadir ofa.js como referencia directa, y utilizar npm para la compatibilidad con frameworks como React y Vue."}],"hello-world":[{"t":"h","c":"Primer caso"},{"t":"p","c":"A continuación se muestra un caso en el que al hacer clic en un botón se cambia el texto a \"Hola mundo\":"},0,{"t":"p","c":"Después de hacer clic en el botón, se mostrará el texto \"Hola Mundo\" en negrita."},{"t":"p","c":"Ahora, vamos a explicar en detalle los conceptos básicos."},{"t":"h","c":"Selector"},{"t":"p","c":"Después de haber importado ofa.js, el símbolo $ estará registrado en el alcance global. Puedes seleccionar el primer elemento que cumpla con la condición utilizando $('xxx'), donde xxx es un selector CSS estándar. Puedes hacer clic en el enlace para ver los detalles específicos del selector."},{"t":"p","c":"A continuación se muestra un ejemplo:"},0,{"t":"p","c":"En el caso anterior, después de abrir la página durante un segundo, se cambiará el contenido de los elementos p, #desk y .logger respectivamente."},{"t":"h","c":"vinculación de eventos"},{"t":"p","c":"Después de seleccionar un elemento con éxito, puedes asignarle eventos. Como se mencionó anteriormente en el ejemplo \"Hello World\", asignamos un evento de clic al elemento con el id \"btn\". Cuando se hace clic en el botón, la función asignada se ejecutará."},{"t":"p","c":"Puedes hacer clic para ver ejemplos de enlaces en el capítulo Ejemplos de eventos y aprender sobre algunos casos de asignación de eventos."},{"t":"p","c":"Todos los eventos disponibles se pueden encontrar en Web Events para obtener la lista completa de eventos."},{"t":"h","c":"Propiedades"},{"t":"p","c":"En los dos casos anteriores, mostramos el uso de las propiedades html y text."},{"t":"p","c":"También puedes obtener el contenido de un elemento utilizando las propiedades html o text, como se muestra a continuación:"},0,{"t":"p","c":"En este ejemplo, asignamos el contenido HTML del elemento #t1 a los elementos #t2 y #t3."}],"basic-concept":[{"t":"h","c":"Conceptos básicos de instancia"},{"t":"p","c":"La instancia $ es un encapsulamiento de los elementos en la página. Además de seleccionar elementos existentes, también puedes crear nuevos elementos y operar sobre ellos. En este capítulo, aprenderemos cómo crear nuevos elementos y realizar algunas operaciones en la instancia $."},{"t":"h","c":"Crear nuevos elementos"},{"t":"p","c":"Con la instancia $, puedes crear directamente nuevos elementos y operar sobre ellos. Por ejemplo:"},0,{"t":"p","c":"En el ejemplo anterior, creamos un nuevo elemento 'div' usando '$('<div style=\"color:red\">I am text</div>')' y lo agregamos al 'body'."},{"t":"h","c":"Obtener elementos secundarios"},{"t":"p","c":"Las instancias creadas con '$' no tienen una propiedad 'children' como los elementos del DOM. Sin embargo, podemos acceder a los elementos secundarios directos de la instancia utilizando índices de matriz:"},0,{"t":"p","c":"En el ejemplo anterior, obtenemos el elemento 'div' y accedemos a los primeros y segundos elementos 'p' utilizando índices. También usamos '$div.length' para obtener la cantidad de elementos secundarios."},{"t":"h","c":"Manipular elementos secundarios"},{"t":"p","c":"Con las instancias de '$', también podemos usar los métodos de matriz para manipular los elementos secundarios, como 'push' y 'pop':"},0,{"t":"p","c":"En el ejemplo anterior, obtuvimos todas las instancias '$' de los elementos 'p' y usamos el método 'push' para agregar un nuevo elemento 'div' como hijo, luego usamos el método 'pop' para eliminar el último hijo."},{"t":"p","c":"A través del ejemplo anterior, puedes aprender algunas operaciones básicas de la instancia '$', incluyendo la creación de nuevos elementos y el acceso y manipulación de los hijos. La instancia '$' proporciona métodos convenientes para operar en los elementos de la página."}],"elements-and-events":[{"t":"h","c":"Obtener elementos y eventos relacionados"},{"t":"p","c":"Esta sección tiene como objetivo fortalecer la comprensión del contenido de la sección anterior, incluyendo la selección de elementos y la vinculación de eventos."},{"t":"h","c":"Selección de elementos"},{"t":"p","c":"En las secciones anteriores, hemos aprendido la forma de obtener un elemento específico globalmente usando el símbolo $. A continuación, presentaremos otras formas de obtener elementos."},{"t":"h","c":"Buscar un elemento dentro de otro elemento"},{"t":"h","c":"Uso de $(\"xxx\").$('xxxx')"},{"t":"p","c":"$(\"xxx\").$('xxxx') es una forma de seleccionar un elemento padre y luego buscar elementos hijos que cumplan cierta condición dentro de ese padre. En este caso, $(\"xxx\") selecciona un elemento padre y luego se utiliza $('xxxx') para buscar elementos hijos que cumplan la condición dentro de ese padre."},{"t":"h","c":"Ejemplo"},0,{"t":"p","c":"En el ejemplo anterior, primero se selecciona el elemento padre con la clase parent usando $(\".parent\"), luego se busca el elemento hijo con la clase child dentro de este padre usando $(\".child\"). Luego se modifica el contenido de texto del elemento hijo a \"Elemento hijo modificado\"."},{"t":"h","c":"Uso de $('xxx xxxx')"},{"t":"p","c":"$('xxx xxxx') permite buscar los elementos que cumplan con la segunda condición del selector en todo el alcance global, y luego buscar los elementos que cumplan con la primera condición del selector dentro de estos elementos. Esta forma permite encontrar directamente los elementos hijos que cumplan con la condición en un solo paso."},{"t":"h","c":"Ejemplo"},0,{"t":"p","c":"En el ejemplo anterior, se usa directamente $('div .child') para encontrar el elemento hijo con la clase child y se modifica su contenido de texto a \"Elemento hijo modificado\"."},{"t":"h","c":"Seleccionar varios elementos"},{"t":"h","c":"Usar $.all('xxx') para buscar elementos globales"},{"t":"p","c":"El método $.all('xxx') se utiliza para buscar todos los elementos que cumplan la condición del selector en la página, y devolverlos como una colección de elementos. Esto permite seleccionar varios elementos en la página para operaciones en lote."},{"t":"h","c":"Ejemplo"},0,{"t":"p","c":"En el ejemplo anterior, se utiliza $.all(\"p\") para buscar todos los elementos de etiqueta p en la página, y se realiza una operación en lote modificando su contenido de texto a \"Párrafo Modificado 1\", \"Párrafo Modificado 2\" y \"Párrafo Modificado 3\"."},{"t":"h","c":"Buscar todos los elementos que cumplan la condición dentro de un elemento"},{"t":"p","c":"Además de buscar elementos a nivel global, también se puede buscar todos los elementos que cumplan la condición dentro de un elemento específico, utilizando la siguiente sintaxis: $('xxx').all('xxxx')."},{"t":"h","c":"Ejemplo"},0,{"t":"p","c":"En el ejemplo anterior, primero se utiliza $(\".container\") para buscar elementos con la clase container, luego se utiliza .all(\".item\") para buscar todos los elementos secundarios con la clase item dentro de ese contenedor y se les realiza una operación en lote para modificar su contenido de texto a \"Elemento Modificado 1\", \"Elemento Modificado 2\" y \"Elemento Modificado 3\"."},{"t":"h","c":"Eventos"},{"t":"p","c":"Anteriormente se ha explicado cómo usar el método on para vincular eventos. A continuación, se presentan algunos métodos relacionados con eventos;"},{"t":"h","c":"Documentación del uso del método off"},{"t":"p","c":"El método off se utiliza para eliminar los controladores de eventos vinculados a través del método on. Cuando no se necesita más un controlador de eventos para un evento en particular, se puede utilizar el método off para eliminarlo del elemento y evitar la ejecución repetida o las fugas de memoria."},{"t":"h","c":"Sintaxis"},0,{"t":"l","c":"- selector: Selector para el elemento donde se eliminará el controlador de eventos. \n- eventName: Nombre del evento que se eliminará. \n- eventHandler: Controlador de eventos que se eliminará."},{"t":"h","c":"Ejemplo"},0,{"t":"p","c":"En el ejemplo anterior, al hacer clic en el botón, aparecerá un cuadro de diálogo con el mensaje \"¡Botón clicado!\". Sin embargo, después de 5 segundos, el controlador de eventos de hacer clic se elimina mediante el método off, por lo que al hacer clic nuevamente en el botón no se mostrará el cuadro de diálogo."},{"t":"h","c":"Documentación del uso del método one"},{"t":"p","c":"El método one se utiliza para vincular un controlador de eventos que solo se ejecutará una vez cuando se active el evento por primera vez. Después de ejecutarse una vez, el controlador de eventos se eliminará automáticamente para evitar activaciones repetidas."},{"t":"h","c":"Sintaxis"},0,{"t":"l","c":"- selector: Selecciona el elemento al que se desea vincular la función de manejo del evento.\n- eventName: Nombre del evento que se desea vincular.\n- eventHandler: Función de manejo del evento a ejecutar."},{"t":"h","c":"Ejemplo"},0,{"t":"p","c":"En el ejemplo anterior, cuando se hace clic en el botón, se muestra una ventana emergente con el mensaje \"¡Botón clickeado una vez!\". Sin embargo, después del primer clic, la función de manejo del evento se eliminará, por lo que los siguientes clics en el botón no mostrarán la ventana emergente."},{"t":"h","c":"Documentación sobre el uso del método emit"},{"t":"p","c":"El método emit se utiliza para activar manualmente eventos específicos vinculados a un elemento. A través del método emit, se puede ejecutar la función de manejo del evento sin realizar ninguna acción real."},{"t":"h","c":"Sintaxis"},0,{"t":"l","c":"- selector: Selecciona el elemento en el que se desea activar el evento.\n- eventName: Nombre del evento que se desea activar."},{"t":"h","c":"Ejemplo"},0,{"t":"p","c":"En el ejemplo anterior, se activa manualmente el evento de clic del botón usando el método emit, lo que resulta en una ventana emergente que muestra el mensaje \"¡Botón clickeado!\", aunque no se haya hecho clic en el botón físicamente."},{"t":"p","c":"Nota: El uso del método emit no simula un clic de mouse u otros eventos reales, solo llama directamente a la función de manejo del evento vinculada. Por lo tanto, si deseas ejecutar un evento en situaciones específicas, puedes utilizar el método emit."},{"t":"p","c":"Cuando hayas enlazado un evento, a veces puedes querer detener la propagación del evento (burbujeo) o cancelar el comportamiento predeterminado del evento. A continuación, se muestra cómo evitar la propagación y cancelar eventos predeterminados después de la activación del evento."},{"t":"h","c":"Detener la propagación del evento"},{"t":"p","c":"La propagación del evento se refiere a cuando se activa un evento en un elemento y se propaga hacia arriba a lo largo del árbol del DOM, activando secuencialmente eventos del mismo tipo en elementos padres. Si deseas detener la propagación después de manejar un evento en un elemento específico, puedes utilizar el método event.stopPropagation()."},{"t":"p","c":"Código de ejemplo:"},0,{"t":"p","c":"En el ejemplo anterior, cuando haces clic en el botón \"Haz clic\", se muestra \"¡Botón pulsado!\", pero no se activa \"¡Div interno pulsado!\" y \"¡Div externo pulsado!\". Esto se debe a que hemos llamado a event.stopPropagation() en el controlador de eventos de clic del botón, lo que evita la propagación del evento."},{"t":"h","c":"Cancelar el comportamiento predeterminado del evento"},{"t":"p","c":"Algunos elementos tienen un comportamiento predeterminado cuando se activa un evento. Por ejemplo, hacer clic en un botón de envío enviará el formulario, hacer clic en un enlace redirigirá a la dirección del enlace, etc. Si deseas evitar el comportamiento predeterminado de un evento, puedes usar el método event.preventDefault()."},{"t":"p","c":"Código de ejemplo:"},0,{"t":"p","c":"En el ejemplo anterior, cuando haces clic en el botón de envío \"Enviar\", mostrará \"¡Hola, {name}! Envío del formulario prevenido.\", pero no mostrará la alerta \"¡Formulario enviado!\". Esto se debe a que llamamos a event.preventDefault() en el controlador de eventos del clic del botón de envío, lo que evita el comportamiento predeterminado de envío del formulario."}],"common-function":[{"t":"h","c":"Métodos comunes"},{"t":"h","c":"attr"},{"t":"p","c":"attr método le permite obtener o establecer los atributos de un elemento."},0,{"t":"p","c":"En el ejemplo anterior, primero seleccionamos un elemento div con id \"ejemplo\". Luego, usamos el método attr para obtener el atributo name de ese elemento y lo imprimimos en la consola. A continuación, usamos el método attr para establecer el atributo title de ese elemento como \"cambiar título\"."}],"common-properties":[{"t":"h","c":"Propiedades comunes"},{"t":"p","c":"En la instancia $, además de seleccionar elementos a través de selectores, también se proporcionan algunas propiedades comunes para facilitar la manipulación y búsqueda de elementos."},{"t":"h","c":"Propiedad tag"},{"t":"p","c":"La propiedad tag se utiliza para obtener el nombre de etiqueta (en minúsculas) del elemento actual, similar a la propiedad tagName del elemento DOM."},0,{"t":"h","c":"ele attribute"},{"t":"p","c":"ele causalidad se utiliza para obtener el elemento DOM real de la instancia $, lo que permite realizar operaciones JavaScript nativas en ese elemento."},0,{"t":"h","c":"atributo index"},{"t":"p","c":"index atributo se utiliza para obtener el índice de clasificación del elemento actual entre los elementos del mismo nivel, comenzando desde 0."},0,{"t":"h","c":"parent y parents atributos"},{"t":"l","c":"- El atributo parent se utiliza para obtener el elemento padre directo del elemento actual. \n- El atributo parents se utiliza para obtener un arreglo de todos los elementos ancestros del elemento actual (incluyendo el padre del padre, el padre del padre del padre, etc.)."},0,{"t":"h","c":"next, nexts, prev, prevs, siblings properties"},{"t":"l","c":"- La propiedad next se utiliza para obtener el siguiente elemento hermano del elemento actual. \n- La propiedad nexts se utiliza para obtener un array de todos los elementos hermanos del elemento actual que se encuentran después de él. \n- La propiedad prev se utiliza para obtener el elemento hermano anterior del elemento actual. \n- La propiedad prevs se utiliza para obtener un array de todos los elementos hermanos del elemento actual que se encuentran antes de él. \n- La propiedad siblings se utiliza para obtener todos los elementos hermanos del elemento actual, sin incluirlo a él mismo."},0],"css":[{"t":"h","c":"Uso de CSS"},{"t":"p","c":"En ofa.js, puedes manipular el estilo CSS de los elementos de la siguiente manera:"},{"t":"h","c":"Obtener estilos CSS específicos de un elemento"},{"t":"p","c":"Puedes usar $ele.css.xxx para obtener estilos CSS específicos de un elemento, donde xxx es el nombre de la propiedad CSS que deseas obtener."},{"t":"h","c":"Ejemplo"},0,{"t":"h","c":"Establecer un estilo específico"},{"t":"p","c":"Puedes usar $ele.css.xxx = '' para establecer un estilo específico de un elemento, donde xxx es el nombre de la propiedad CSS que deseas establecer. Al asignar una cadena vacía como valor de la propiedad, puedes eliminar el estilo específico."},{"t":"h","c":"Ejemplo"},0,{"t":"h","c":"Asignar un objeto"},{"t":"p","c":"Puedes usar $ele.css = {xxx} para establecer el estilo de un elemento, donde xxx es un objeto que contiene los nombres y valores de las propiedades CSS."},{"t":"h","c":"Ejemplo"},0,{"t":"h","c":"Asignación de cadenas"},{"t":"p","c":"Puede usar $ele.css = 'color:red;...' para establecer el estilo de un elemento, donde 'color:red;...' es una cadena que contiene reglas de estilo CSS."},{"t":"h","c":"Ejemplo"},0,{"t":"h","c":"Consejos para establecer CSS"},{"t":"p","c":"Puede modificar una determinada propiedad de estilo de un elemento sin afectar a las demás propiedades utilizando la sintaxis $ele.css = {...$ele.css, color:'red'}. De esta forma, se puede modificar una propiedad sin tener que reescribir todo el estilo."},{"t":"h","c":"Ejemplo"},0,{"t":"p","c":"En el ejemplo anterior, al usar { ...myElement.css, color: 'red' }, solo se modifica el color del elemento y las demás propiedades de estilo se mantienen sin cambios. Este es un consejo útil para modificar de forma flexible el estilo de un elemento."}],"box-model":[{"t":"h","c":"Modelo de caja"},{"t":"p","c":"En el desarrollo front-end, a menudo se utilizan algunas propiedades que representan el tamaño de los elementos. Estas propiedades incluyen width, height, clientWidth, clientHeight, offsetWidth, offsetHeight, outerWidth y outerHeight. Es importante comprender su significado y uso para el desarrollo de diseños responsivos y dinámicos. A continuación, los explicaremos uno por uno y los demostraremos a través de un ejemplo."},{"t":"l","c":"- width: representa el ancho del área de contenido del elemento, sin incluir el padding, el borde y el margen.\n- height: representa la altura del área de contenido del elemento, sin incluir el padding, el borde y el margen.\n- clientWidth: representa el ancho del área de contenido visible del elemento, incluyendo el padding pero sin incluir el borde y el margen.\n- clientHeight: representa la altura del área de contenido visible del elemento, incluyendo el padding pero sin incluir el borde y el margen.\n- offsetWidth: representa el ancho total del elemento, incluyendo el área de contenido, el padding, el borde y el margen.\n- offsetHeight: representa la altura total del elemento, incluyendo el área de contenido, el padding, el borde y el margen.\n- outerWidth: representa el ancho total del elemento, incluyendo el área de contenido, el padding, el borde, el margen pero sin incluir el ancho de la barra de desplazamiento.\n- outerHeight: representa la altura total del elemento, incluyendo el área de contenido, el padding, el borde, el margen pero sin incluir la altura de la barra de desplazamiento."},0],"classlist-and-data":[{"t":"h","c":"classList y datos"},{"t":"h","c":"classList"},{"t":"p","c":"En ofa.js, puedes manipular la propiedad classList del elemento de la siguiente manera: "},{"t":"l","c":"- $ele.classList: Devuelve el objeto classList del elemento, que se utiliza para manipular los nombres de clase del elemento."},{"t":"h","c":"Uso de classList para a��adir y eliminar clases"},{"t":"l","c":"- Añadir una clase: $ele.classList.add('nombreClase'), agrega el nombre de clase especificado a classList del elemento. \n- Eliminar una clase: $ele.classList.remove('nombreClase'), elimina el nombre de clase especificado de classList del elemento. \n- Alternar una clase: $ele.classList.toggle('nombreClase'), si el nombre de clase ya existe en classList del elemento, lo elimina; de lo contrario, lo agrega."},{"t":"h","c":"Ejemplo"},0,{"t":"p","c":"En este ejemplo, hay un elemento <div> con una clase inicial de box y tres botones: Añadir resalte, Eliminar resalte y Alternar resalte."},{"t":"l","c":"- Cuando se hace clic en el botón 'Añadir resalte', se agrega la clase highlight al elemento <div> utilizando el método classList.add(), lo que le da un fondo amarillo.\n- Cuando se hace clic en el botón 'Eliminar resalte', se elimina la clase highlight del nombre de clase del elemento <div> utilizando el método classList.remove(), lo que restaura el estilo original.\n- Cuando se hace clic en el botón 'Alternar resalte', se alterna la presencia de la clase highlight en el elemento <div> utilizando el método classList.toggle(). Si la clase ya estaba presente, se elimina; si no estaba presente, se agrega, logrando así el cambio de estilo."},{"t":"p","c":"De esta manera, puedes controlar dinámicamente el estilo de los elementos a través del objeto classList."},{"t":"h","c":"Uso de data"},{"t":"p","c":"En ofa.js, puedes operar las propiedades data de los elementos de la siguiente manera:"},{"t":"l","c":"- $ele.data: devuelve el objeto dataset del elemento, que se utiliza para operar las propiedades data del elemento."},{"t":"h","c":"Uso específico de dataset"},{"t":"p","c":"Las propiedades data-* de los elementos se pueden utilizar para almacenar datos personalizados en HTML, y se pueden acceder a estas propiedades a través del objeto data."},{"t":"p","c":"Por ejemplo, si un elemento tiene la propiedad data-info definida:"},0,{"t":"p","c":"Puedes acceder a esta propiedad utilizando dataset:"},0,{"t":"p","c":"Ten en cuenta que los nombres de las propiedades en el objeto dataset se convierten a notación camel case eliminando \"data-\" de la propiedad original. Por ejemplo, data-info se convierte en dataset.info. Si deseas establecer una propiedad data-*, también puedes hacerlo a través del objeto dataset:"},0,{"t":"p","c":"Esto agregará una propiedad data-another-info al elemento y establecerá su valor como \"otro valor\"."}],"formdata":[{"t":"h","c":"Funcionalidad de formularios"},{"t":"p","c":"La instancia de $ proporciona algunas funciones de formulario convenientes para simplificar y mejorar el manejo de los elementos de formulario."},{"t":"h","c":"Generar un objeto a partir de formData"},{"t":"p","c":"El método formData se utiliza para generar un objeto que contiene los valores de todos los elementos del formulario. Este objeto reflejará instantáneamente los cambios en los elementos del formulario."},0,{"t":"h","c":"Escuchar elementos específicos del formulario"},{"t":"p","c":"Por defecto, formData() escucha todos los elementos input, select y textarea dentro del elemento de destino. Puedes pasar selectores para escuchar elementos específicos del formulario."},0,{"t":"h","c":"Objetos Stanz"},{"t":"p","c":"El objeto devuelto por el método formData() se conoce como objeto Stanz.Stanz forma parte de la biblioteca de extensiones $ y proporciona un procesamiento y escucha eficientes para los datos de formulario."},{"t":"p","c":"Puede obtener más información sobre los tutoriales y las funciones de Stanz visitando https://github.com/kirakiray/stanz."},{"t":"p","c":"A través de la funcionalidad de formulario anterior, puedes manejar fácilmente los valores y cambios de los elementos del formulario, mejorando la conveniencia y eficiencia de las operaciones del formulario."}]},"create-component":{"index":[{"t":"h","c":"Crear y utilizar componentes"},{"t":"p","c":"ofa.js utiliza archivos HTML y JavaScript básicos para definir componentes, evitando la introducción de nuevos tipos de archivos para reducir los costos de aprendizaje. Si tienes un conocimiento básico de HTML, podrás desarrollar y utilizar componentes de ofa.js rápidamente."},{"t":"h","c":"Pasos previos a la creación de un componente"},{"t":"p","c":"Antes de empezar a crear un componente, hay algunos preparativos que debes tener en cuenta. Dado que la creación de componentes implica operaciones de solicitud de recursos del navegador, si simplemente abres un archivo HTML para verlo, se abrirá en el protocolo \"file\". Bajo el protocolo \"file\", la carga de módulos de JavaScript puede generar errores. Por lo tanto, debes preparar un servidor estático para ver correctamente los componentes."},{"t":"p","c":"Si utilizas el editor Visual Studio Code, puedes instalar fácilmente un complemento compatible con servidores estáticos. Recomendamos utilizar el complemento Live Server."},{"t":"p","c":"Después de instalar el complemento, simplemente haz clic derecho en el archivo demo.html y selecciona \"Open with Live Server\", el complemento abrirá automáticamente el archivo en modo de servidor estático."},{"t":"p","c":"Si utilizas otro editor, también puedes crear un servidor Nginx o Apache que admita la visualización estática de archivos HTML. Esto te permitirá previsualizar y desarrollar tus componentes correctamente."},{"t":"h","c":"Crear un componente de botón"},{"t":"p","c":"A continuación, crearemos un componente de botón simple llamado simple-button que tendrá un estilo más atractivo que un botón nativo."},{"t":"p","c":"Primero, crea un archivo llamado simple-button.html que utilice la etiqueta <template> y añade el atributo component para identificarlo como un componente."},{"t":"p","c":"A continuación, escribe el código del modelo del componente dentro del elemento <template>. Luego, debajo del contenido de la plantilla, agrega una etiqueta <script> donde incluirás el código JavaScript del componente."},0,{"t":"p","c":"Después de haber importado con éxito ofa.js, se registrará automáticamente el componente 'load-module', que es un componente utilizado para referenciar módulos de forma declarativa, similar a la etiqueta script. Este componente carga y procesa los módulos especificados en 'src'. En este ejemplo, se carga una plantilla y se registra el componente 'simple-button'."},{"t":"p","c":"El componente 'load-module' también puede abreviarse como 'l-m' para reducir el código."},0,{"t":"p","c":"El componente 'load-module' es una biblioteca personalizada de carga declarativa que proporciona funciones poderosas para extender y realizar operaciones intermedias en módulos de JavaScript y otros tipos de archivos. Se ha separado como un proyecto independiente y se puede encontrar la documentación de su uso en https://github.com/kirakiray/drill.js."},{"t":"h","c":"Modo de dos archivos"},{"t":"p","c":"El modo de dos archivos separa la 'plantilla estática' y el 'código lógico', lo que hace que el componente sea más claro."},{"t":"p","c":"El código lógico se coloca en un archivo JavaScript que debe incluir la declaración 'export const type = $.COMP;' para notificar a la página que se trata de un módulo de componente. En este modo de separación, se pueden utilizar las sintaxis estándar de los módulos ES como 'import' para el código del módulo."},{"t":"p","c":"El componente de botón está compuesto por dos archivos:"},{"t":"l","c":"1. simple-button.html: plantilla y estilo HTML del componente de botón."},0,{"t":"l","c":"2. simple-button.mjs: código de registro del componente de botón."},0,{"t":"p","c":"En el lugar donde se desea usar este componente, importar este módulo utilizando l-m. A continuación, se muestra un ejemplo de página que utiliza el componente simple-button (modo de dos archivos)."},0],"parameter-description":[{"t":"h","c":"Exploración de los parámetros de registro del componente"},{"t":"p","c":"En ofa.js, puedes definir algunos parámetros de registro específicos en el módulo de componente para configurar el componente de manera más flexible. A continuación, se explica detalladamente cada parámetro de registro con ejemplos correspondientes."},{"t":"h","c":"Parámetros básicos"},{"t":"p","c":"Los parámetros básicos son la configuración más básica para registrar un componente e incluyen las siguientes propiedades:"},{"t":"h","c":"Identificador del componente"},{"t":"p","c":"El módulo del componente debe tener export const type = $.COMP para identificarlo como un módulo de componente."},{"t":"p","c":"Ejemplo:"},0,{"t":"h","c":"tag"},{"t":"p","c":"tag represents the registered component name. When the tag attribute is not defined, the registered component name remains the same as the file name."},{"t":"p","c":"Ejemplo:"},0,{"t":"h","c":"temp"},{"t":"p","c":"temp is a string type attribute used to define the address of the component template. When temp is not defined, the default is to load the HTML file with the same name as the component in the same directory as the current module."},{"t":"p","c":"Ejemplo:"},0,{"t":"h","c":"data"},{"t":"p","c":"data is an object type attribute used to generate custom data that is automatically added after the component is created."},{"t":"p","c":"Ejemplo:"},0,{"t":"h","c":"attrs"},{"t":"p","c":"attrs is an object type attribute, also part of data, but this data is reflected in the attributes of the element. Changes to the attributes will also dynamically change the data of the component. When there is a capitalized key, it will be converted to - camel case in the component attribute."},{"t":"p","c":"Ejemplo:"},0,{"t":"h","c":"proto"},{"t":"p","c":"In the registration parameters of the component, you can add a proto object to define the methods that need to be added to the component prototype. In this way, when creating instances of the component, these attributes and methods will be added to the prototype of the instance, so that all instances can access and share these methods."},0,{"t":"h","c":"watch"},{"t":"p","c":"watch es una propiedad de tipo objeto que se utiliza para escuchar cambios en data. La función de escucha se registra aquí. Una vez registrado con éxito, el valor de escucha se ejecutará inmediatamente una vez."},{"t":"l","c":"- Las funciones registradas con watch solo se activarán una vez durante un cambio de hilo único. Por lo tanto, incluso si el valor de escucha se modifica varias veces en un hilo único, solo se activará una vez.\n- El primer parámetro es el valor actual.\n- El segundo parámetro es un objeto que contendrá un conjunto de datos llamado watchers. En la mayoría de los casos, solo habrá un objeto en watchers, donde se puede obtener el oldValue de este objeto. Si el valor de escucha ha sido modificado varias veces en un hilo único, este conjunto de datos registrará varios cambios."},{"t":"p","c":"Ejemplo:"},0,{"t":"h","c":"Ejemplo de código"},{"t":"p","c":"A continuación se muestra un ejemplo de código completo, que incluye la definición de los parámetros básicos y la plantilla del componente."},0,0,0,{"t":"h","c":"default"},{"t":"p","c":"Puedes usar una función asíncrona para definir los datos 'default' y así retornar de forma dinámica los parámetros de registro del componente."},{"t":"p","c":"La función 'function' traerá un objeto que contiene"},{"t":"p","c":"las propiedades 'load', 'url' y 'query':"},{"t":"l","c":"- El método 'load' es una función de carga asíncrona, se utiliza de manera similar a la carga asíncrona 'import', se puede cargar un módulo asíncrono mediante 'const data = await load(xxx)'.\n- Los módulos cargados a través de 'load' tienen el mismo efecto que los cargados a través de 'load-module'. El método 'load' es una función del componente 'load-module', se puede consultar el método de uso específico en la documentación de https://github.com/kirakiray/drill.js.\n- 'url' es el nombre de archivo del módulo actual.\n- 'query' es un objeto que contiene los parámetros de URL al cargar este módulo."},{"t":"p","c":"A continuación se muestra un ejemplo de uso de 'default':"},0,{"t":"p","c":"En este ejemplo, demostramos cómo utilizar los parámetros de registro de ofa.js para personalizar el comportamiento de los componentes. Al configurar correctamente estos parámetros, puedes adaptarte mejor a diferentes necesidades de los componentes y lograr un desarrollo de componentes más flexible."},{"t":"p","c":"Escribe un documento de uso de proto para los parámetros de registro de componentes."}],"life-cycle":[{"t":"h","c":"Ciclo de vida del componente"},{"t":"p","c":"En ofa.js, el ciclo de vida del componente se activa en momentos específicos mediante funciones gancho. Estas funciones gancho te permiten controlar e interactuar de forma más precisa. ofa.js tiene cinco ganchos de ciclo de vida clave: created, ready, watch, loaded, attached y detached, que se activan en diferentes momentos."},{"t":"h","c":"Ganchos de ciclo de vida"},{"t":"h","c":"created"},{"t":"p","c":"El gancho del ciclo de vida created se activa cuando se crea el componente. En esta fase, los datos del componente aún no se han inicializado y el contenido de la plantilla no se ha renderizado. Puedes realizar algunas operaciones de inicialización en esta fase o preparar datos para su uso posterior."},{"t":"h","c":"ready"},{"t":"p","c":"El gancho del ciclo de vida ready se activa justo después de que se inicializan los datos y la plantilla del componente, lo que significa que el componente está listo. En esta fase, puedes acceder a los datos del componente y la plantilla ya ha sido renderizada, por lo que puedes realizar operaciones relacionadas con la interacción visual."},{"t":"p","c":"Si la plantilla del componente depende de otros componentes, esta fase no esperará a que se carguen las dependencias. Por lo tanto, es adecuado para agregar estilos de carga al componente, pero debes tener en cuenta que debes esperar a que las dependencias se carguen antes de realizar operaciones relacionadas."},{"t":"h","c":"watch"},{"t":"p","c":"Una vez que se completa la fase ready, las funciones de escucha asociadas al objeto watch se activan una vez. Luego, cuando cambie el valor de algún dato, se activará nuevamente la función de escucha asociada a la clave correspondiente."},{"t":"h","c":"loaded"},{"t":"p","c":"El gancho del ciclo de vida loaded se activa después de que se carguen todas las dependencias en la plantilla del componente. Esta fase garantiza que todas las dependencias se hayan cargado antes de renderizar el componente. Es el momento adecuado para eliminar los estilos de carga añadidos en la fase ready. "},{"t":"h","c":"attached"},{"t":"p","c":"attached lifecycle hook is triggered when the component is added to the document. At this stage, it is suitable for obtaining size-related information of the component's elements, performing data binding, and global event operations."},{"t":"h","c":"detached"},{"t":"p","c":"detached lifecycle hook is triggered when the component is removed from the document. At this stage, you can perform some cleanup operations, such as removing event listeners or releasing resources, to prevent memory leaks."},{"t":"h","c":"Example demonstration"},{"t":"p","c":"The following is an example that demonstrates how to use these lifecycle hooks:"},0,0,0,{"t":"p","c":"En el ejemplo anterior, hemos definido un componente llamado lifecycle-demo y hemos colocado un botón en su plantilla. Con diferentes ganchos de ciclo de vida, podemos observar registros de los distintos momentos en la consola."},{"t":"h","c":"Diagrama de flujo del ciclo de vida"},0],"web-components":[{"t":"h","c":"Encapsulación y Componentización: Conocimientos generales de la componentización"},{"t":"p","c":"ofa.js es una biblioteca de encapsulamiento basada en la tecnología de Web Components, con el objetivo de simplificar y acelerar el proceso de desarrollo de componentes. Al ocultar los detalles técnicos complejos, los desarrolladores pueden centrarse más en la construcción de componentes y aplicaciones de alta calidad."},{"t":"p","c":"Para desarrollar componentes de manera más efectiva, es necesario aprender algunos conceptos de Web Components. Los puntos mencionados a continuación no solo se pueden aplicar en ofa.js, sino que también podrían beneficiarte al utilizar otros frameworks que empleen Web Components."},{"t":"h","c":"Contenedor Shadow DOM"},{"t":"p","c":"En Web Components, Shadow DOM proporciona un contenedor aislado para encapsular los estilos y la estructura interna de un componente. Esto significa que los estilos y la estructura DOM internos del componente no interferirán con los estilos y estructuras externas, lo que garantiza la previsibilidad y mantenibilidad del componente."},{"t":"p","c":"En ofa.js, cada componente tiene un contenedor Shadow DOM para aislar su contenido interno. El contenido de la plantilla se renderiza en este contenedor. Además, las instancias de componentes obtenidas a través de $ también tienen acceso al contenedor Shadow DOM interno a través de la propiedad shadow, lo que permite operar y acceder a los elementos internos del componente."},0,{"t":"h","c":"Selectores CSS comunes en componentes web"},{"t":"p","c":"Web Components proporciona algunos selectores CSS especiales para seleccionar y dar estilo a diferentes partes del interior del componente. Estos son algunos de los selectores más utilizados:"},{"t":"h","c":":host recogedor"},{"t":"p","c":"El selector :host se utiliza para seleccionar el contenedor externo del propio componente. El estilo del componente puede definirse a través de este selector."},0,{"t":"h","c":"Selector ::slotted()"},{"t":"p","c":"El selector ::slotted() se utiliza para seleccionar el elemento envuelto por el contenido ranurado. Se puede aplicar estilo al contenido con este selector en los estilos internos del componente."},0,{"t":"h","c":"Uso de las ranuras"},{"t":"p","c":"Las ranuras son el mecanismo utilizado en Web Components para incrustar contenido externo dentro de un componente. Las ranuras permiten a los desarrolladores pasar contenido personalizado dentro de los componentes, lo que posibilita una estructura de componentes más flexible."},{"t":"h","c":"Ranura única"},{"t":"p","c":"Las ranuras pueden definirse en plantillas de componentes utilizando el elemento <slot>. El contenido entrante externo se inserta dentro de la ranura."},0,0,{"t":"h","c":"Varias ranuras con nombre"},{"t":"p","c":"Además de los espacios predeterminados, pueden definirse varios espacios con nombre. Las ranuras con nombre permiten a los desarrolladores insertar contenidos diferentes en las distintas ubicaciones de las ranuras."},0,0,{"t":"h","c":"Uso del evento slotchange"},{"t":"p","c":"El evento slotchange se activa cuando el contenido del slot cambia. Puedes utilizar este evento para realizar operaciones relacionadas con el contenido del slot."},0],"template-syntax":[{"t":"h","c":"Sintaxis de la plantilla"},{"t":"p","c":"ofa.js proporciona una serie de potentes características de sintaxis de plantillas que te permiten manipular de manera más flexible los elementos e datos de interfaz de los componentes. Estas características de sintaxis de plantillas te ayudan a lograr efectos de interfaz ricos y experiencias de interacción."},{"t":"h","c":"Sintaxis para renderizar texto"},{"t":"p","c":"Utilizando la sintaxis de rendimiento de texto {{ key }}, puedes renderizar datos como contenido de texto y agregarlos a la plantilla del componente. Cuando los datos cambian, el contenido de texto correspondiente se actualizará automáticamente."},{"t":"p","c":"A continuación se muestra un ejemplo que utiliza la sintaxis de rendimiento de texto:"},0,0,{"t":"p","c":"En el ejemplo anterior, {{username}} será reemplazado por el valor de la propiedad username en los datos del componente, lo que mostrará \"Bienvenido, JohnDoe!\" en la interfaz."},{"t":"h","c":"Sintaxis de enlace de atributos"},{"t":"p","c":"Utilizando la sintaxis de enlace de atributos :xxx='yyy', puedes vincular las propiedades del componente a los atributos de los elementos dentro de la plantilla. Este enlace es unidireccional, los cambios en las propiedades afectarán a los atributos de los elementos en la plantilla, pero no al revés."},{"t":"p","c":"He aquí algunos ejemplos comunes de vinculación de propiedades:"},0,0,{"t":"p","c":"En el ejemplo anterior, :text=\"greeting\" enlaza el valor de la propiedad greeting del data del componente al contenido de texto del elemento <p>. :value=\"inputValue\" enlaza el valor de la propiedad inputValue del data del componente al atributo value del elemento <input>. Para componentes personalizados, custom-prop es el nombre de la propiedad del componente personalizado, y se pasa el valor de la propiedad customValue del data del componente al componente personalizado."},{"t":"h","c":"vinculación de eventos"},{"t":"p","c":"Usando el formato on:click=\"yyy\", puedes enlazar un evento especificado del elemento objetivo (por ejemplo, click) a una propiedad yyy del componente anfitrión. De esta manera, cuando se acciona el evento especificado en el elemento objetivo, se llama al método de propiedad respectivo en el componente anfitrión."},{"t":"p","c":"A continuación se muestra un ejemplo:"},0,0,{"t":"p","c":"En el ejemplo anterior, cuando se hace clic en el botón, se llama al método increaseCount del componente principal para aumentar el valor del atributo count."},{"t":"h","c":"atributos de enlace"},{"t":"p","c":"Con la forma attr:xxx=\"yyy\", puedes vincular el atributo especificado xxx del elemento objetivo al atributo yyy del componente principal. De esta manera, el atributo del elemento objetivo cambiará a medida que cambie el atributo del componente principal."},0,0,{"t":"p","c":"En el ejemplo anterior, attr:fontcolor=\"val\" vinculará el atributo val del componente principal al atributo fontcolor del elemento <div>."},{"t":"h","c":"Vinculación de nombres de clase dinámicos"},{"t":"p","c":"Usando la forma class:xxx=\"yyy\", puedes agregar o eliminar dinámicamente el nombre de clase al elemento objetivo según el valor del atributo del componente principal. Cuando el atributo yyy del componente principal es true, se agregará el nombre de clase xxx al elemento objetivo; de lo contrario, se eliminará ese nombre de clase."},0,0,{"t":"p","c":"En el ejemplo anterior, si el atributo isActive es true, el botón agregará el nombre de clase active, aplicando un estilo específico."},{"t":"h","c":"Doble enlace de datos"},{"t":"p","c":"A través de sync:xxx='yyy', puedes conseguir el doble enlace de datos. Esto hace que la propiedad xxx del elemento objetivo y la propiedad yyy del componente anfitrión se mantengan sincronizadas, es decir, los cambios en la propiedad objetivo se reflejarán en la propiedad anfitrión, y los cambios en la propiedad anfitrión también se sincronizarán con la propiedad objetivo."},{"t":"p","c":"A continuación se muestra un ejemplo:"},0,0,{"t":"p","c":"En el ejemplo anterior, sync:value=\"inputValue\" logra un doble enlace de datos, cuando el valor del cuadro de texto cambie, inputValue se actualizará automáticamente; por otro lado, cuando inputValue cambie, el valor del cuadro de texto también cambiará."}],"template-component":[{"t":"h","c":"Componente de Renderización de Plantilla"},{"t":"p","c":"Además de poder utilizar la sintaxis de plantillas, ofa.js también proporciona componentes de renderización dedicados para su uso dentro de las plantillas, incluyendo componentes de renderización condicional y de rellenado."},{"t":"h","c":"Componentes de Renderización Condicional"},{"t":"h","c":"Componente x-if"},{"t":"p","c":"El componente x-if se utiliza para renderizar contenido de forma dinámica según condiciones. Acepta una propiedad value que determina si se renderizan sus elementos hijos o no. Si value es true, los elementos hijos se renderizan, de lo contrario no se renderizan."},{"t":"p","c":"A continuación se muestra un ejemplo de uso de x-if para renderizar diferentes contenidos según una condición:"},0,0,{"t":"h","c":"Componente x-else"},{"t":"p","c":"x-if se puede utilizar junto con x-else para alternar la renderización de condiciones."},{"t":"p","c":"A continuación se muestra un ejemplo de uso de x-if y x-else para alternar la renderización de contenido según diferentes condiciones:"},0,0,{"t":"h","c":"x-if + x-else-if + x-else components"},{"t":"p","c":"x-if aún puede combinarse con x-else-if y x-else para lograr una representación condicional múltiple."},{"t":"p","c":"A continuación se muestra un ejemplo de uso de x-if, x-else-if y x-else para alternar el contenido de acuerdo a múltiples condiciones:"},0,0,{"t":"p","c":"En el ejemplo anterior, se renderiza contenido diferente según el valor de condition, logrando así un cambio de representación condicional múltiple."},{"t":"h","c":"Componente de plantilla: x-fill"},{"t":"p","c":"El componente x-fill te permite llenar dinámicamente contenido en una plantilla, y puede generar contenido diferente según los valores de las propiedades del componente anfitrión. El componente x-fill utiliza la propiedad name para especificar la plantilla de llenado que se va a utilizar, y pasa los datos a la plantilla de llenado a través de la propiedad value."},{"t":"h","c":"Ejemplo de llenado de cadenas de un arreglo con x-fill"},{"t":"p","c":"A continuación se muestra un ejemplo de llenado de cadenas de un arreglo utilizando x-fill, y se llena contenido diferente mediante un bucle:"},0,{"t":"p","c":"En el ejemplo anterior, x-fill utiliza una plantilla de relleno llamada fillTemplate y le pasa un objeto. En la plantilla de relleno se utiliza {{ $data }} para renderizar cada elemento del objeto, logrando así un relleno cíclico de diferentes contenidos de cadenas."},{"t":"h","c":"Ejemplo de rellenado de x-fill con capacidad de autocompletado"},{"t":"p","c":"x-fill también puede rellenar objetos con estructuras más complejas y es compatible con el relleno anidado."},{"t":"p","c":"A continuación se muestra un ejemplo de cómo utilizar x-fill para rellenar un objeto con capacidad de relleno anidado, mostrando cómo generar contenido anidado:"},0,0,{"t":"p","c":"En el ejemplo anterior, x-fill utiliza una plantilla de llenado llamada nestedFillTemplate y pasa un objeto anidado complejo a ella. La plantilla de llenado utiliza {{ $data.title }} para renderizar el título del objeto, y también utiliza x-fill anidado para llenar el contenido de los elementos secundarios, logrando así una generación de contenido anidado."},{"t":"h","c":"$data, $ele, $host en el significado de la plantilla"},{"t":"p","c":"Dentro de la plantilla de llenado, puedes utilizar identificadores especiales para acceder a diferentes datos:"},{"t":"l","c":"- {{ $data }}: representa los datos pasados a la plantilla de llenado, es decir, el valor del atributo value.\n- {{ $ele }}: representa el elemento en el que se encuentra la plantilla de llenado y se utiliza para acceder a los atributos y estilos del elemento.\n- {{ $host }}: representa la instancia del componente principal y se utiliza para acceder a los atributos y métodos del componente principal."},{"t":"p","c":"Estos identificadores especiales te ayudan a acceder y renderizar diferentes datos dinámicamente dentro de la plantilla de llenado. En el ejemplo, puedes ver cómo se utiliza {{ $data.title }} para acceder al título de los datos pasados y cómo se utiliza {{ $host.num }} para acceder a los atributos del componente principal."}]},"create-app":{"index":[{"t":"h","c":"Desarrollo de aplicaciones"},{"t":"p","c":"Además de poder desarrollar componentes, ofa.js también se puede utilizar para desarrollar aplicaciones completas."},{"t":"p","c":"ofa.js integra la aplicación como un componente o-app, lo que te permite crear rápidamente aplicaciones utilizando esta etiqueta. Esta forma simplifica y agiliza la creación de aplicaciones."},{"t":"p","c":"Además, ofa.js también ofrece una solución completa de enrutamiento y SSG (Generación de Páginas Estáticas), que ayuda a los desarrolladores a construir aplicaciones más robustas. Estas características aceleran el flujo de desarrollo, permitiéndote centrarte en la lógica de la aplicación y la experiencia del usuario sin tener que preocuparte demasiado por los detalles subyacentes."},0,{"t":"p","c":"Lo anterior es un ejemplo sencillo del código tutorial de la aplicación, seguido de una explicación paso a paso del proceso de desarrollo de la aplicación."}],"page":[{"t":"h","c":"página de desarrollo"},{"t":"p","c":"Dentro de ofa.js, construimos un componente personalizado llamado o-page que está diseñado para facilitar el desarrollo de páginas. Este componente juega un papel clave en el desarrollo de aplicaciones. Cuando quieras utilizar la sintaxis de plantilla de un componente, pero no quieras crear un componente completamente nuevo, el componente o-page será tu mejor opción."},{"t":"h","c":"módulo de página"},{"t":"p","c":"La creación de un módulo de página de un solo archivo es similar a la creación de un módulo de componentes. Utilice la etiqueta template para envolver el código de plantilla de la página y añadir el atributo page. Dentro de esta etiqueta, siéntete libre de utilizar la sintaxis de la plantilla para interactuar con otros componentes o módulos de página."},0,{"t":"p","c":"En el archivo HTML, utilice el atributo src de la etiqueta o-page para especificar la ruta del archivo del módulo de página. El contenido de la página se mostrará dentro de ese componente."},0,{"t":"h","c":"Modo de archivos dobles"},{"t":"p","c":"El modo de archivos dobles separa las plantillas estáticas y el código lógico, lo que hace que el contenido de la página sea más claro."},{"t":"p","c":"A continuación se muestran los pasos para usar el componente o-page y los módulos de página:"},{"t":"l","c":"1. Crear un módulo de página:"},{"t":"p","c":"Similar a crear un módulo de componente, crea un módulo de página, pero establece la propiedad type en $.PAGE. Los parámetros disponibles para el módulo de página incluyen temp, data, proto y watch."},0,{"t":"l","c":"2. Crear una plantilla de página:"},{"t":"p","c":"En el mismo directorio que el módulo de página, crea un archivo de plantilla de página llamado my-page-template.html. En este archivo de plantilla, puedes usar la sintaxis de plantilla para realizar interacciones, similar a la sintaxis de plantilla mencionada anteriormente para los componentes."},0,{"t":"p","c":"En tu archivo HTML, utiliza la etiqueta <o-page> para usar el componente o-page y utiliza el atributo src para hacer referencia a la ruta del archivo del módulo de página. El contenido de la página se renderizará dentro de este componente."},0,{"t":"p","c":"De esta manera, cuando abras la página, el componente o-page cargará dinámicamente el módulo de página my-page.mjs y renderizará el contenido de la página según las plantillas y datos del módulo. El ciclo de vida y la sintaxis de las plantillas del módulo de página se mantienen consistentes con los módulos de componentes, lo que hace que el desarrollo y la gestión de las páginas sean más unificados y flexibles."},{"t":"h","c":"Verificar si la página ha cargado completamente"},{"t":"p","c":"En algunas ocasiones, es posible que necesites verificar si la página ha cargado completamente para realizar algunas operaciones específicas. ofa.js proporciona varias formas de verificar si la página ha cargado completamente."},{"t":"h","c":"Usar la propiedad page._loaded"},{"t":"p","c":"Dentro del módulo de página, page._loaded es una propiedad booleana que se establece en true una vez que el contenido de la página ha cargado. Puedes usar esta propiedad para verificar si la página ha cargado completamente."},0,{"t":"h","c":"Usar la propiedad page._rendered"},{"t":"p","c":"Otra forma de verificar si la página ha cargado completamente es usando la propiedad page.rendered, que es una promesa. Una vez que la página ha cargado, esta promesa entrará en el estado resolve. Puedes esperar a que la página cargue completamente usando await page.rendered y luego realizar las operaciones correspondientes."},0],"app":[{"t":"h","c":"Creando una Aplicación"},{"t":"p","c":"Con la etiqueta o-app puedes crear fácilmente una ventana de aplicación completa. A continuación se muestra cómo crear una aplicación y configurarla:"},{"t":"h","c":"Código Básico"},{"t":"l","c":"1. Crea un archivo HTML y establece la etiqueta o-app como la ventana de visualización de la aplicación. Asegúrate de establecer el estilo de pantalla completa para o-app para que la aplicación ocupe toda la vista."},0,{"t":"l","c":"2. Crea un módulo ES para establecer los datos de configuración de la aplicación. Los datos de configuración incluyen las siguientes opciones:\n\n   - home: Tipo de cadena, dirección del módulo de página de inicio de la aplicación.\n   - loading: Tipo de función, esta función se ejecutará cuando la aplicación cargue una nueva página. El resultado de esta función se insertará en la aplicación como un mensaje de carga y se eliminará automáticamente una vez que se haya cargado la página.\n   - fail: Tipo de función, esta función se ejecutará cuando falle la carga de una página de la aplicación. El valor devuelto se mostrará en la aplicación como un mensaje de carga fallida. La función tendrá la dirección src de la página de carga fallida y el objeto de error.\n   - pageAnime: Configuración de animación al cambiar entre páginas."},{"t":"p","c":"A continuación se muestra un ejemplo de los datos de configuración de la aplicación:"},0,{"t":"l","c":"3. En el archivo HTML, utiliza la etiqueta o-app y referencia los datos de configuración como un módulo es a través del atributo src."},0,{"t":"p","c":"Con los pasos anteriores, has creado exitosamente una ventana de aplicación que utiliza el componente o-app. El componente o-app cargará la página de acuerdo a la configuración de los datos, mostrando una indicación de carga o un mensaje de error, y admite animaciones de cambio de página. Esto te permite construir rápidamente una aplicación con funcionalidad completa e interactiva."},{"t":"h","c":"Navegación por rutas"},{"t":"p","c":"En la aplicación o-app, puedes realizar fácilmente la navegación por rutas, saltando de un módulo de página a otro. A continuación, se presentan diferentes formas de realizar la navegación por rutas."},{"t":"h","c":"Utilizar la etiqueta <a> para la navegación por rutas"},{"t":"p","c":"Puedes utilizar la etiqueta <a> en el HTML de la página para realizar la navegación por rutas. Debes especificar la ruta del módulo de página de destino en el atributo href y agregar el atributo olink para indicar al componente o-app que se trata de un enlace de ruta."},0,{"t":"h","c":"goto"},{"t":"p","c":"Puedes utilizar el atributo on:click en la plantilla de la página para vincular un evento de clic y llamar al método goto en el módulo para realizar la navegación por rutas."},0,{"t":"p","c":"O tal vez descargar directamente en el elemento de destino:"},0,{"t":"h","c":"Sustituir páginas de salto y retorno"},{"t":"p","c":"Además del método goto, o-app también admite los métodos replace y back."},{"t":"l","c":"- El método replace se utiliza para reemplazar un salto, reemplaza la ruta de la página actual, haciendo que la nueva página sea la ruta de la página actual."},0,{"t":"l","c":"- El método back se utiliza para volver a la página anterior."},0,{"t":"p","c":"Tenga en cuenta que el estado de enrutamiento del componente se mantiene dentro de la aplicación, pero los datos de enrutamiento no están vinculados a la pestaña actual del navegador. De este modo, puede saltar y navegar fácilmente entre páginas dentro de la aplicación."},{"t":"p","c":"Si desea implementar el enrutamiento y la vinculación de páginas, puede utilizar el componente o-router, que cubriremos en detalle en una sección posterior."},{"t":"p","c":"Con el método anterior, puedes implementar saltos de ruta flexibles en la aplicación o-app, para que los usuarios puedan navegar fácilmente por los diferentes contenidos de las páginas."},{"t":"h","c":"Acceso a la aplicación y a la página actual"},{"t":"p","c":"Elementos individuales (incluyendo componentes) dentro de la aplicación, se obtiene la instancia o-app en la que se encuentran a través del atributo app. Esto es útil para las operaciones que requieren la interacción con toda la aplicación."},{"t":"p","c":"A través de la propiedad app.current, puedes obtener la dirección del módulo de página actualmente activo."},{"t":"p","c":"Aquí tienes un ejemplo de uso:"},0,{"t":"p","c":"En el ejemplo anterior, se obtiene la etiqueta de la aplicación mediante el selector .app, y luego se accede a la propiedad app.current para obtener la dirección de la página actualmente activa."},{"t":"h","c":"Consejo de uso: Cachear la siguiente página de antemano"},{"t":"p","c":"En algunos casos, es posible que sepas de antemano que el usuario va a navegar a la siguiente página. Para mejorar la experiencia del usuario, puedes cachear de antemano el módulo de página siguiente, de modo que se pueda cargar inmediatamente durante la navegación real, reduciendo así el tiempo de espera del usuario y haciendo que la experiencia sea más fluida."},{"t":"p","c":"En el código JavaScript de la página actual, llama al método load y pasa la ruta del módulo de la siguiente página. Este módulo se cargará y cacheará."},0],"subrouting":[{"t":"h","c":"Modo de subruta"},{"t":"p","c":"En ofa.js, configurar subrutas es ligeramente diferente a otras prácticas en marcos front-end. ofa.js utiliza un enfoque más intuitivo al establecer una página padre como contenedor en el módulo de la página para cumplir con los requisitos de las subrutas."},{"t":"h","c":"Configuración del contenedor de página padre"},{"t":"p","c":"Para crear subrutas, primero se debe establecer el parámetro 'parent' en el módulo de la página secundaria para especificar la dirección del contenedor de la página padre. De esta manera, cuando se carga la página secundaria, ofa.js automáticamente envuelve la página secundaria dentro del contenedor de la página padre."},0,{"t":"p","c":"En el ejemplo anterior, el módulo de la página secundaria especifica la dirección del contenedor de la página padre utilizando el parámetro 'parent'."},{"t":"h","c":"Configuración de la plantilla del contenedor de la página principal"},{"t":"p","c":"La plantilla del contenedor de la página principal necesita tener un elemento <slot> para que las páginas secundarias puedan insertarse en la posición especificada de la página principal. Además, asegúrate de que el elemento contenedor del <slot> esté configurado como position: relative, esto es muy importante, ya que las páginas secundarias se posicionan absolutamente dentro del contenedor de la página principal."},{"t":"p","c":"A continuación se muestra un ejemplo de plantilla del contenedor de la página principal:"},0,{"t":"p","c":"En el ejemplo anterior, al configurar un elemento contenedor con slot, las páginas secundarias se insertarán en ese contenedor. Asegúrate de que el elemento contenedor tenga una posición relativa para que las páginas secundarias se posicionen en relación a él."},{"t":"p","c":"Utilizando este enfoque, puedes configurar de manera más visual las rutas secundarias y lograr la carga y el renderizado de las páginas secundarias mediante la asociación entre el contenedor de la página principal y las páginas secundarias."},{"t":"h","c":"Listener de rutas de la página principal"},{"t":"p","c":"En algunas situaciones, varias páginas comparten la misma página principal como contenedor y cuando se realiza una navegación entre estas páginas, la página principal no se refresca. En este caso, la página principal aún puede escuchar los cambios de ruta para realizar acciones correspondientes sin refrescar la página."},{"t":"h","c":"Escuchar los cambios de ruta"},{"t":"p","c":"El módulo de la página principal puede configurar una función routerChange para escuchar los cambios de ruta. Cuando se produce un cambio de ruta en la página sin actualizar la página principal, se activará el evento routerChange. Este evento pasará la información de la página actual y el tipo de cambio (type)."},{"t":"p","c":"A continuación se muestra un ejemplo de un módulo de página principal que demuestra cómo configurar la función routerChange para escuchar los cambios de ruta:"},0,{"t":"p","c":"En el ejemplo anterior, la función routerChange recibe dos parámetros, current que representa la dirección actual de la página, y type que representa el tipo de redirección. Cuando se produce un cambio de ruta en la página, esta función se activa y muestra la información correspondiente."}],"o-router":[{"t":"h","c":"Uso del componente o-router"},{"t":"p","c":"El componente o-router es un componente utilizado para enlazar rutas dentro de o-app a la pestaña actual del navegador, lo que ayuda a gestionar el enrutamiento y la presentación de la página más fácilmente."},{"t":"h","c":"Referencia al componente o-router"},{"t":"p","c":"Primero, necesitas referenciar el componente o-router en tu página. Puede hacer referencia al archivo router.mjs de la siguiente manera:"},0,{"t":"h","c":"Usando el componente o-router"},{"t":"p","c":"El uso del componente o-router se consigue envolviéndolo en el exterior del componente o-app. Esto vincula las rutas in-app a la pestaña actual del navegador."},0,{"t":"h","c":"atributo fix-body"},{"t":"p","c":"El componente o-router también proporciona el atributo fix-body, cuando estableces este atributo, el componente estiliza automáticamente la etiqueta <html> para que el tamaño de la aplicación sea igual al tamaño de la página de forma que el contenido de la aplicación llene toda la ventana."},0],"scsr":[{"t":"h","c":"Renderizado de cliente estático (SCSR)"},{"t":"h","c":"¿Qué es SCSR?"},{"t":"p","c":"SCSR, cuyo nombre completo es Renderizado de Cliente Estático (Static Client-Side Rendering), es una variante de RSC (Renderizado de Cliente) que, además de ofrecer la experiencia de usuario de RSC, permite que las páginas sean indexadas por los rastreadores web en su estado estático."},{"t":"h","c":"Cómo utilizar SCSR"},{"t":"p","c":"Puedes utilizar una biblioteca de SCSR de la siguiente manera:"},0,{"t":"h","c":"Cómo funciona SCSR"},{"t":"p","c":"SCSR es un módulo de página que se ejecuta directamente en modo de archivo único, sin necesidad de utilizar la etiqueta o-page, lo que permite renderear en la página. Específicamente, se pone el código de plantilla del módulo de página directamente dentro de o-app."},{"t":"p","c":"A continuación se muestra un ejemplo de SCSR que muestra cómo renderear directamente el contenido del módulo de página en la página:"},0,{"t":"p","c":"A través de SCSR, el contenido dentro de la etiqueta 'template' se renderizará directamente en la página, y esta parte del contenido es en realidad el módulo de página en modo de archivo único."},{"t":"p","c":"Continuando con el ejemplo de la página 'home.html', creamos una página 'help':"},0,{"t":"p","c":"Al hacer clic en 'IR A AYUDA' en la página 'home.html', se navegará suavemente a la página 'help.html', logrando un efecto de navegación suave en el renderizado del cliente."},{"t":"h","c":"Consideraciones"},{"t":"p","c":"Todas las páginas que utilicen el esquema SCSR, excepto el contenido descriptivo de la página (como title, meta:description, keywords) y el contenido de la plantilla de la página, deben mantenerse consistentes para garantizar una experiencia consistente después de la redirección y actualización de la página."},{"t":"h","c":"Sobre el esquema SSR"},{"t":"p","c":"El esquema actual de SCSR es más similar a un esquema de SSG (Generación de Sitio Estático) ya que renderiza previamente el contenido de la página como contenido estático y luego lo interactúa a través del cliente. ofa.js ya proporciona un enfoque de encapsulación de componentes relativamente independiente, lo que permite a los desarrolladores front-end encapsular componentes y luego combinarlos con esquemas tradicionales de renderizado de páginas en el backend (como Node.js, Go, Java, PHP u otros lenguajes y marcos de sitios web). Los desarrolladores backend pueden utilizar rápidamente estos componentes encapsulados para construir páginas web de alta calidad."},{"t":"p","c":"Planeamos ofrecer en el futuro un esquema completo de SSR (Renderizado en el Lado del Servidor). Este esquema consiste en obtener primero el contenido de la próxima página y luego compararlo con el contenido de la página actual para realizar operaciones dinámicas, como agregar, eliminar y modificar atributos. Sin embargo, es importante tener en cuenta que este esquema de SSR requerirá más tiempo, ya que implica comparaciones y modificaciones de elementos complejos."},{"t":"p","c":"ofa.js es un marco emergente y el autor tiene tiempo limitado debido a otras responsabilidades. Por el momento, el esquema de SSR no ha sido completamente desarrollado. Sin embargo, si ofa.js gana más usuarios en el futuro y hay una demanda destacada de un esquema de SSR, el autor continuará mejorándolo y desarrollándolo. Actualmente, el autor se enfoca en la estabilidad y expansión de las características del marco, y también da la bienvenida a los comentarios y sugerencias de los usuarios para satisfacer mejor sus necesidades en el futuro."}]},"others":{"data-sharing":[{"t":"h","c":"Compartir datos"},{"t":"p","c":"ofa.js, a diferencia de otros frameworks de terceros, no adopta el modelo de gestión de estado tradicional. El autor considera que las actualizaciones de estado deberían ser imperceptibles, es decir, los cambios en los datos deberían provocar automáticamente una actualización de los mismos."},{"t":"p","c":"ofa.js tiene innata la capacidad de compartir datos de forma excelente, su instancia se ha desarrollado en base a la librería de compartición de datos Stanz. Los objetos en la instancia son sincronizables. Si se desea compartir datos, solo es necesario crear un objeto Stanz independiente y luego hacer que todos los componentes lo referencien directamente."},{"t":"p","c":"A continuación, se muestra un ejemplo de cómo compartir datos:"},0,0,0,0,{"t":"p","c":"En el ejemplo anterior, dos componentes escriben datos en sí mismos durante el ciclo de vida 'attached'. Luego, el objeto 'obj' del componente se convierte en datos compartidos. Después del ciclo de vida 'detached', se establecen los datos compartidos previos como 'null' para asegurar que los datos se recojan. "},{"t":"h","c":"Consideraciones"},{"t":"p","c":"Dado que los datos son compartidos, es importante asegurarse de recolectar los datos en el momento adecuado para evitar fugas de memoria."},0],"about-micro-frontend":[{"t":"h","c":"Sobre Micro Front End"},{"t":"p","c":"Micro front-end is a front-end architectural pattern designed to help teams build and maintain large, complex front-end applications. It draws on the ideas of microservices architecture and divides front-end applications into smaller independent parts, each of which can be developed, tested, and deployed by different teams."},{"t":"p","c":"En el proceso de expansión continua de las aplicaciones tradicionales de frontend monolíticas, puede volverse difícil de mantener y expandir. El objetivo de la microfrontend es dividir la aplicación en módulos más pequeños y más manejables, lo que permite que los equipos de desarrollo puedan desarrollar y implementar estos módulos de manera independiente, mejorando así la eficiencia del equipo y la mantenibilidad de la aplicación."},{"t":"p","c":"ofa.js tiene las características innatas de la microfrontend. A diferencia de otros frameworks, los componentes, páginas y aplicaciones desarrollados con ofa.js no requieren precompilación. En contraste, frameworks como React, Vue y Angular requieren una compilación previa en el entorno de Node.js para generar el código cliente. Sin embargo, el código de desarrollo de ofa.js se puede colocar directamente en un servidor estático sin necesidad de pasos de compilación adicionales, lo que permite ver, utilizar y ejecutar los cambios en tiempo real."},{"t":"p","c":"ofa.js cumple con los cinco aspectos clave de la microfrontend:"},{"t":"l","c":"1. Implementación independiente: cada componente y página se puede desarrollar, probar e implementar de forma independiente, lo que permite al equipo lanzar nuevas funcionalidades y solucionar problemas más rápidamente.\n\n2. Integración: las aplicaciones desarrolladas con ofa.js pueden combinar diferentes módulos en una sola aplicación. Esto se puede lograr compartiendo aplicaciones, páginas, componentes, entre otros.\n\n3. Equipos separados: cada módulo frontend (componente/página/aplicación) puede ser desarrollado y mantenido por equipos separados, lo que fomenta la autonomía y la innovación del equipo.\n\n4. Recursos compartidos: en un proyecto con ofa.js, generalmente existen recursos compartidos como estilos, componentes y páginas, para garantizar la coherencia y la eficiencia.\n\n5. Carga bajo demanda: las aplicaciones desarrolladas con ofa.js pueden cargar módulos según sea necesario, lo que mejora el rendimiento y la velocidad de carga de la aplicación."},{"t":"p","c":"Aunque ofa.js no puede utilizar directamente componentes desarrollados con frameworks como Vue y React, los componentes desarrollados con ofa.js pueden ser utilizados por Vue y React, lo que brinda a los desarrolladores de diferentes tecnologías más flexibilidad y capacidad de extensión."},{"t":"p","c":"Cómo usar Web Components en Vue:"},{"t":"l","c":"- Envoltura de Componente Web de Vue\n- Integración de Vue con Web Components\n- Cómo usar Web Components en Vue"},{"t":"p","c":"En React, usando Web Components:"},{"t":"l","c":"- Usar Web Components con React\n- Usar Web Components en React\n- Integrar Web Components en React"}]}},"others":{"data-sharing":[{"t":"h","c":"Compartir datos"},{"t":"p","c":"ofa.js, a diferencia de otros frameworks de terceros, no adopta el modelo de gestión de estado tradicional. El autor considera que las actualizaciones de estado deberían ser imperceptibles, es decir, los cambios en los datos deberían provocar automáticamente una actualización de los mismos."},{"t":"p","c":"ofa.js tiene innata la capacidad de compartir datos de forma excelente, su instancia se ha desarrollado en base a la librería de compartición de datos Stanz. Los objetos en la instancia son sincronizables. Si se desea compartir datos, solo es necesario crear un objeto Stanz independiente y luego hacer que todos los componentes lo referencien directamente."},{"t":"p","c":"A continuación, se muestra un ejemplo de cómo compartir datos:"},0,0,0,0,{"t":"p","c":"En el ejemplo anterior, dos componentes escriben datos en sí mismos durante el ciclo de vida 'attached'. Luego, el objeto 'obj' del componente se convierte en datos compartidos. Después del ciclo de vida 'detached', se establecen los datos compartidos previos como 'null' para asegurar que los datos se recojan. "},{"t":"h","c":"Consideraciones"},{"t":"p","c":"Dado que los datos son compartidos, es importante asegurarse de recolectar los datos en el momento adecuado para evitar fugas de memoria."},0],"about-micro-frontend":[{"t":"h","c":"Sobre Micro Front End"},{"t":"p","c":"Micro front-end is a front-end architectural pattern designed to help teams build and maintain large, complex front-end applications. It draws on the ideas of microservices architecture and divides front-end applications into smaller independent parts, each of which can be developed, tested, and deployed by different teams."},{"t":"p","c":"En el proceso de expansión continua de las aplicaciones tradicionales de frontend monolíticas, puede volverse difícil de mantener y expandir. El objetivo de la microfrontend es dividir la aplicación en módulos más pequeños y más manejables, lo que permite que los equipos de desarrollo puedan desarrollar y implementar estos módulos de manera independiente, mejorando así la eficiencia del equipo y la mantenibilidad de la aplicación."},{"t":"p","c":"ofa.js tiene las características innatas de la microfrontend. A diferencia de otros frameworks, los componentes, páginas y aplicaciones desarrollados con ofa.js no requieren precompilación. En contraste, frameworks como React, Vue y Angular requieren una compilación previa en el entorno de Node.js para generar el código cliente. Sin embargo, el código de desarrollo de ofa.js se puede colocar directamente en un servidor estático sin necesidad de pasos de compilación adicionales, lo que permite ver, utilizar y ejecutar los cambios en tiempo real."},{"t":"p","c":"ofa.js cumple con las características de los micro frontends:"},{"t":"l","c":"1. Implementación independiente: cada componente y página se puede desarrollar, probar e implementar de forma independiente, lo que permite al equipo lanzar nuevas funcionalidades y solucionar problemas más rápidamente.\n\n2. Integración: las aplicaciones desarrolladas con ofa.js pueden combinar diferentes módulos en una sola aplicación. Esto se puede lograr compartiendo aplicaciones, páginas, componentes, entre otros.\n\n3. Equipos separados: cada módulo frontend (componente/página/aplicación) puede ser desarrollado y mantenido por equipos separados, lo que fomenta la autonomía y la innovación del equipo.\n\n4. Recursos compartidos: en un proyecto con ofa.js, generalmente existen recursos compartidos como estilos, componentes y páginas, para garantizar la coherencia y la eficiencia.\n\n5. Carga bajo demanda: las aplicaciones desarrolladas con ofa.js pueden cargar módulos según sea necesario, lo que mejora el rendimiento y la velocidad de carga de la aplicación."},{"t":"p","c":"Aunque ofa.js no puede utilizar directamente componentes desarrollados con frameworks como Vue y React, los componentes desarrollados con ofa.js pueden ser utilizados por Vue y React, lo que brinda a los desarrolladores de diferentes tecnologías más flexibilidad y capacidad de extensión."},{"t":"p","c":"Cómo usar Web Components en Vue:"},{"t":"l","c":"- Envoltura de Componente Web de Vue\n- Integración de Vue con Web Components\n- Cómo usar Web Components en Vue"},{"t":"p","c":"En React, usando Web Components:"},{"t":"l","c":"- Usar Web Components con React\n- Usar Web Components en React\n- Integrar Web Components en React"}]}}