{"cases":{"index":[0,{"t":"h","c":"Quick Start"},{"t":"p","c":"To get started, simply integrate the ofajs project into your project by importing the CDN address:"},0,{"t":"p","c":"This is a simple example that demonstrates how to modify the content of a DOM element using ofa.js."},{"t":"h","c":"Usage"},{"t":"p","c":"After importing ofa.js, the $ symbol will be registered in the global scope. Use $('xxx') to select the first element that meets the conditions, where xxx is a standard CSS selector."},{"t":"p","c":"In the above example, we used the $ symbol to select three elements with different id values and modify their content by setting the text, html, and value properties."},0],"event":[0,{"t":"h","c":"Event Response"},{"t":"p","c":"You can use the on method to bind events. Events are the most basic concept in development, and applications rely on event triggers to generate feedback and achieve interactivity."},{"t":"p","c":"The following example demonstrates how to bind a click event:"},{"t":"p","c":"In this example, we selected the button element using $ and bound the click event using the on method. When the button is clicked, the callback function is triggered, changing the text content of the target element to \"Hello, world!\"."},{"t":"p","c":"If you want to learn more about available event types, please refer to the Events documentation."}],"simple-component":[0,{"t":"h","c":"Component Creation and Usage"},{"t":"p","c":"Once the loading of ofa.js is completed, a component named 'load-module' will be registered globally, and you can reference it using the abbreviation 'l-m'. Its usage is similar to that of the 'script' tag, where you reference the address of your developed component through the 'src' attribute."},{"t":"p","c":"Now, let's start creating our own component. First, create an HTML file with a name that matches the component name."},{"t":"p","c":"In the component file, first add a template element and add a component attribute. Place the content that the component needs to render inside this template element. Finally, this content will be rendered into the component's Shadow DOM. Shadow DOM is isolated from the external environment to prevent contamination of the external environment."},{"t":"p","c":"Next, simply use the l-m component to reference the component you developed. On the page, use the component tag you defined directly."},{"t":"p","c":"Note that the registered component name can only use lowercase letters and hyphens (-), and must include at least one hyphen. This naming rule must be followed."},{"t":"p","c":"This example shows how to create a component called 'simple-btn'. The component's template contains a slot where content can be inserted. Add styles to the component by using the ':host' selector. In another page, use the 'l-m' component to reference the 'simple-btn' component and insert content into it."}],"slot":[0,{"t":"h","c":"Component Slots"},{"t":"p","c":"By adding <slot></slot> tags in the template, you can place content in the slots inside the corresponding component tags when using the component."},{"t":"p","c":"Custom components do not have the display property defined by default, so it needs to be manually defined for the component. In the component's style, the :host selector can be used to add styles to the component itself."},{"t":"p","c":"This example showcases the usage of the 'use-app' component. It contains multiple links that lead to different pages."}],"render-text":[0,{"t":"h","c":"Text Rendering"},{"t":"p","c":"In the component file, you can add a script tag to write the logic code for the component. The component parameters can be set through the exposed default object."},{"t":"p","c":"Where\n    data parameter is used to define the default data of the component elements. Once instantiated, you can use template syntax."},{"t":"p","c":"Text rendering is wrapped with double curly braces, i.e. {{xxx}}, where xxx represents the attribute name of the component."},{"t":"p","c":"case demonstrates how to render the val data of a component element:"}],"attribute-transmission":[0,{"t":"h","c":"Feature Passing"},{"t":"p","c":"attrs parameter and data parameter are similar in functionality. The data set in attrs will be merged into data, but the data on attrs will be reflected in the component's own features."},0,{"t":"p","c":"When using the component externally, you can also pass data to the component internally through attributes. It should be noted that the data passed through attributes can only be of type string."}],"get-set-comp":[0,{"t":"h","c":"Get and modify component instance values"},{"t":"p","c":"You can also get or modify the data of a component from the outside."},0],"property-transmission":[0,{"t":"h","c":"Property Transmission"},{"t":"p","c":"With the property transmission template syntax, you can apply the component's data to element attributes within the template."},{"t":"p","c":"The method is to add the attribute :name=\"key\" to the element, where name is the name of the target element attribute to be set, and key is the property key you want to pass from your custom component."},{"t":"p","c":"Previously, we mentioned using selectors to set attributes in <a href='./index.html' olink>a link</a>, while what is being introduced here is the attribute-passing syntax for setting attributes."}],"bind-event":[0,{"t":"h","c":"Event Binding"},{"t":"p","c":"Within the component, you can use the on attribute to bind events and make the component interactive. This demonstrates how to bind events within a component to achieve interactive effects."},{"t":"p","c":"The proto parameter is used to define the component's own methods, which can be used internally within the component or externally by selecting the component and running the methods."},{"t":"p","c":"The xxx after on:click=\"xxx\" can be the method name defined within the component or a function expression. If using a function expression, the this keyword does not need to be explicitly written, as the variable scope will be automatically bound to the component itself."},{"t":"p","c":"If you want to learn more about available event types, please refer to the Events documentation."}],"nested-component":[0,{"t":"h","c":"Nested Components"},{"t":"p","c":"Putting all the excessive logic into one component is not a wise choice; we can divide the logic into separate components and import another component using the l-m method."},{"t":"p","c":"The nested component named CompTwo is imported through <l-m src=\"./comp-two.html\"></l-m> in the example case."},{"t":"p","c":"The nested component is used through <comp-two :txt=\"val\"></comp-two> and the val property of the current component is passed as the txt property to the nested component. This way, the nested component can use the passed data for rendering."},{"t":"p","c":"In <comp-two></comp-two>, the nested component is used without passing any properties. The usage here depends on the logic and design of the nested component itself."},{"t":"p","c":"As long as a component loads successfully, it can be used anywhere using its respective name. Even if the l-m component is loaded multiple times in different places, it won't result in the component being loaded multiple times. This mechanism ensures component reusability and consistency."}],"inject-host":[0,{"t":"h","c":"inject-host component"},{"t":"p","c":"Due to the isolation of Web Components, it is difficult to directly modify the styles of elements inside component slots. To address this issue, ofa.js provides a component called inject-host, which injects styles into the host layer to configure the appearance of the component more flexibly."},{"t":"p","c":"It should be noted that using this component may affect the styles of the host layer. Therefore, when intruding on styles, naming conventions should be maintained to avoid affecting the styles of the host."},{"t":"p","c":"In the example, we defined the comp-two component, which internally uses the inject-host component to inject styles. This allows us to style the elements inside the comp-two component using the injected styles without affecting other components."},{"t":"p","c":"At the same time, the following points should also be noted:"},{"t":"l","c":"- By adding <style> tags inside inject-host, we can define specific styles for the component. These styles will only affect the elements of the current component and will not spread to other components.\n- When injecting styles, it is important to avoid using overly generic selectors to prevent affecting the styles of other components. Specificity and uniqueness of selectors should be maintained.\n- inject-host can also inject external style sheet files using the <link rel=\"stylesheet\" href=\"target/style.css\"> approach."},{"t":"p","c":"Throughout the example, by using the inject-host inside the comp-two component, we can flexibly set and apply styles within the component without breaking other component styles."}],"event-passing":[0,{"t":"h","c":"Event Passing"},{"t":"p","c":"In addition to listening for native events, on can also be used to listen for custom events, which is important for event communication between components. Custom events are triggered through the emit method. By triggering custom events, custom data can be passed to the receiver."},{"t":"p","c":"If you need to trigger events across the boundaries of Shadow DOM, you can add the composed attribute."},{"t":"p","c":"In the following example, we will learn how to use the emit method to pass events between nested components."}],"sync":[0,{"t":"h","c":"Two-way data binding"},{"t":"p","c":"By using the sync syntax, you can establish a real-time, two-way relationship between interactive elements (such as input fields or custom components) in the user interface and the data model."},{"t":"p","c":"The following example demonstrates how to use the sync attribute in a component to achieve two-way data binding between an input field and the data model:"},{"t":"l","c":"- In the data parameter, we define a data called testText and set its initial value to \"I am testText\".\n- Using sync:value=\"testText\" indicates that the value of the input field is bound to the testText data. Therefore, when the user enters content in the input field, the testText data will be updated in real-time, and vice versa.\n- Similarly, using sync:txt=\"testText\" indicates that the txt attribute of the custom component is bound to the testText data. When the txt attribute of the component changes, the testText data will be updated in real-time, and vice versa."},{"t":"p","c":"Through two-way data binding, you can easily establish a connection between the user interface and the data model, so that changes in the data can be automatically reflected in the interface, and user input on the interface can immediately affect the data model."},{"t":"p","c":"This example shows how to create a component called 'simple-btn'. The component's template contains a slot where content can be inserted. Add styles to the component by using the ':host' selector. In another page, use the 'l-m' component to reference the 'simple-btn' component and insert content into it."}],"condition":[0,{"t":"h","c":"Conditional Rendering"},{"t":"p","c":"In addition to template syntax, templates also have template components;"},0,{"t":"p","c":"Conditional rendering allows you to dynamically insert different content into a component under specific conditions. Here is an example demonstrating how to use conditional rendering within a component."},{"t":"p","c":"In this example, we create a component called test-demo. The component contains a button that increments the count property. Using the <x-if>, <x-else-if>, and <x-else> tags, we implement the logic for conditional rendering."},{"t":"l","c":"- The <x-if> tag accepts a value attribute to define the condition. If the value of value is true, the content inside <x-if> will be rendered. In this example, if count is an even number, red text will be displayed.\n- The <x-else-if> tag also accepts a value attribute to define the condition. If the previous condition is not met and the value of value is true, the content inside <x-else-if> will be rendered. In this example, if count is a multiple of 3, blue text will be displayed.\n- The <x-else> tag does not require a value attribute. It will render its content when none of the previous conditions are met. In this example, if count is neither an even number nor a multiple of 3, green text will be displayed. <x-else> can also immediately follow <x-if>;"},{"t":"p","c":"Using this approach, you can dynamically render different content based on different conditions, achieving flexible interaction and display effects."}],"fill":[0,{"t":"h","c":"Fill Rendering"},{"t":"p","c":"Fill rendering (x-fill) templates in frontend frameworks are similar to the concept of list rendering. They allow you to dynamically render a set of micro-components based on a data collection."},{"t":"p","c":"During the fill rendering process, you can use the following special variables:"},{"t":"l","c":"- $data: Represents the data of the fill item. By manipulating $data, you can access or modify the data of each fill item.\n- $index: Represents the index of the current data item in the data collection.\n- $host: Represents the current component itself. If you want to get the component's data or call the component's methods, you need to use $host to access the component."}],"fill-temp":[0,{"t":"h","c":"Recursive Fill Rendering"},{"t":"p","c":"Fill rendering allows you to render data using separate templates and add a name attribute to the <template> element for naming. This allows you to render nested data structures and create more complex components."},{"t":"p","c":"When using x-fill for fill rendering, you just need to pass the corresponding template name to the name attribute to render the content of the separate template. In addition, fill rendering also supports recursive filling, which means you can continue to use the same template name inside the template for nested filling."},{"t":"p","c":"In the example, we define a separate template named item and pass the corresponding template name when using x-fill. This way, each item in the data will be rendered using this template, and the template can be recursively filled with the same template name. This allows you to flexibly handle data with nested structures and achieve more complex component rendering."}],"life-cycle":[0,{"t":"h","c":"life cycle"},{"t":"p","c":"Lifecycle hooks provide an opportunity to execute code at different stages of a component. In ofa.js, there are five main lifecycle hooks: created, ready, watch, attached, and detached."},{"t":"l","c":"- created(): Called when the component is created, before the shadow root has started rendering. You can perform some initialization settings here, but you cannot access elements within the shadow root.\n  \n- ready(): Called after the shadow root has finished rendering. It is generally used for component initialization logic. At this stage, you can access and manipulate elements within the shadow root, as well as perform other operations that need to be done after rendering is complete.\n\n- watch: Observes changes in data by defining the watch object. After ready completes, a watch corresponding to the value in data will be triggered. Subsequently, each time the value of the corresponding key changes, the corresponding function within watch will be triggered.\n\n- attached(): Called when the component is added to the document. You can perform operations that interact with the external environment, such as obtaining the appearance of the component or initializing shared data.\n\n- detached(): Called when the component is removed from the document. At this stage, you can perform cleanup, cancel interaction with the external environment, and release resources."}],"form-data":[0,{"t":"h","c":"Form Data"},{"t":"p","c":"Handling form data is a common task in many applications. To simplify this process, ofa.js provides a secondary abstraction for handling form data, through the formData method. With this method, you can easily map the values of form elements to an object and automatically update the data of this object when the values of the form elements change, and vice versa."},{"t":"p","c":"By using the shadow attribute, you can access the content of the Shadow DOM root node of a component. This allows you to access and manipulate elements and styles within the Shadow DOM from within the component."},{"t":"p","c":"In this example, we can see how to use the formData method to automatically map form data to the fdata object. This allows you to access or modify the values of form elements by manipulating the fdata object, and these changes will also be automatically synchronized to the corresponding form elements."}],"custom-form-element":[0,{"t":"h","c":"Custom Form Components"},{"t":"p","c":"With ofa.js, you can easily develop custom form element components with standard form features. Just add a value attribute and set the name attribute for your custom component, and your homemade component can be used as a standard form element. By updating the value property of the component, you can interact with the form element."},{"t":"p","c":"When initializing formData, you need to add the selector feature of the custom component to the parameters (although the default parameter of the formData method is '\"input,select,textarea\"'). This way, formData can interact with custom components."},{"t":"p","c":"In this example, we use a custom component custom-input to create an editable text input. The component is used as a form element and data interaction is done using the value attribute. When using the formData method, we add \"input,custom-input\" as a parameter to correctly initialize form data."}],"use-page":[0,{"t":"h","c":"Using Page Components"},{"t":"p","c":"Once ofa.js is loaded, a page component named o-page will be automatically added globally. This component is used to load page modules, which are a special kind of component module that is not registered as a custom tag, but is loaded through the o-page component."},{"t":"p","c":"Page modules are similar to component modules but with some differences. Page modules use the page attribute to define the template instead of the component attribute. The development logic and template syntax for page modules are the same as component modules. However, page modules cannot use the attrs attribute because page parameters are typically passed through the URL, not through data or attrs."},{"t":"p","c":"In the example, the o-page component is used to load the page.html page module. The page module uses the page attribute to define the template, and then returns an object through a JavaScript function to set the data. The query parameter count in the URL will be passed to the page module and used to initialize the data. The button click event in the page can update the data and render it on the page."}],"use-app":[0,{"t":"h","c":"Using the app component"},{"t":"p","c":"In ofa.js, you can use the o-app component to create the layout structure of the entire application and load different page modules within it. By using the o-app component, o-page component, and page modules, you can build the page structure of the entire application and implement navigation between pages."},{"t":"p","c":"When the o-page component is inside the o-app component, you can use the <a> tag with the olink attribute to achieve page redirection. This redirection will not affect the current page, but will only navigate within the o-app component, similar to using <iframe>."},{"t":"p","c":"If the o-page component is inside the o-app component, you can also use the following methods:"},{"t":"l","c":"- Use the goto method to perform page navigation\n- Use the back method to go back to the previous page\n- Use the replace method to replace the current page with a new one"},{"t":"p","c":"By using the o-app component, you can build the layout structure of the entire application and load different page modules into it. The routing feature provided by o-app makes navigation between pages more convenient and flexible."},{"t":"p","c":"In this example, we created an application layout using the o-app component and loaded a page module page1.html into it."},{"t":"p","c":"In the page1.html page module, we defined a title and a button. Clicking the button will navigate to another page module page2.html. We also added a link with the olink attribute, which will also navigate to page2.html when clicked."},{"t":"p","c":"In the page2.html page module, we also defined a title and a button. Clicking the button will return to the previous page, implementing page navigation."}],"app-config":[0,{"t":"h","c":"Configure app parameters"},{"t":"p","c":"You can configure the parameters of the application by setting external modules for the o-app tag individually."},{"t":"p","c":"These parameters are an ES module, and you can configure the following parameters:"},{"t":"l","c":"- home: The homepage of the application, which is the page displayed when initially loaded.\n- loading: The loading content displayed before the module is fully loaded when clicking on a page transition. You can return a string as the loading content.\n- pageAnime: The animation effect during page transitions, using an object that contains CSS style attributes.\n  - current: Represents the style when the page is the current page.\n  - next: Represents the style when the page is not yet entered.\n  - previous: Represents the style when the page is about to exit."},{"t":"p","c":"By doing so, you can customize parameters such as the homepage, loading style, and page transition animation according to the needs of the application, thereby bringing a more personalized experience to the application."}],"app-loading":[0,{"t":"h","c":"Customize loading for app"},{"t":"p","c":"Here is an example of customizing loading for the o-app component. In this example, we create a beautiful progress bar for loading, which gradually grows during page loading, reaches 100% directly after loading is complete, and then removes the loading element."},{"t":"p","c":"You can copy and use the following code to customize the loading effect for your application:"},0,{"t":"p","c":"Through this code, you can add a unique loading effect to your application, giving users a better experience during page transitions."}],"set404":[0,{"t":"h","c":"Configure 404 page"},{"t":"p","c":"In the application's configuration module, set the fail function to customize the content displayed when the page fails to load."},{"t":"p","c":"In this example, when the page fails to load, the first line of the error message will be displayed."},0],"use-hash-router":[0,{"t":"h","c":"Using hash router"},{"t":"p","c":"You can associate the routes within the app component with the current webpage by using the o-router component. Once the page is bound to the route, even if the page is refreshed, the route state will be maintained."},{"t":"p","c":"In this example, please click the <span style='font-family: \"iconfont\"'>&#xe7cb;</span> button to open and try in a new page."},0],"use-scsr":[0,{"t":"h","c":"Using SCSR Solution"},{"t":"p","c":"In this example, please click the <span style='font-family: \"iconfont\"'>&#xe7cb;</span> button to open and try in a new page;"},{"t":"p","c":"SCSR stands for Static Client-Side Rendering, which is a variant of CSR (Client-Side Rendering). It retains the user experience of CSR while allowing the page to be crawled by search engines in its static state."},{"t":"p","c":"The current website is built using the SCSR solution."},{"t":"p","c":"SCSR achieves rendering on the page by directly running the single-file mode of the page module, without using the 'o-page' tag. Specifically, the template code of the page module is directly nested within 'o-app'."},{"t":"h","c":"Precautions"},{"t":"p","c":"For all pages using the SCSR solution, besides descriptive contents of the page (such as title, meta:description, keywords) and the template content of the page module, other referenced resources must remain consistent to ensure a consistent user experience after page navigation and refreshing."}]},"docs":{"get-started":{"elements-and-events":[{"t":"h","c":"Getting Elements and Events"},{"t":"p","c":"This section aims to enhance understanding of the previous chapter, including selecting elements and binding events."},{"t":"h","c":"Selecting Elements"},{"t":"p","c":"In previous chapters, we have learned how to retrieve a specific element from the global scope using the $ symbol. Now, we will introduce other methods for selecting elements."},{"t":"h","c":"Finding an Element Within Another Element"},{"t":"h","c":"Using the $(\"xxx\").$('xxxx') syntax"},{"t":"p","c":"$(\"xxx\").$('xxxx') is a way to select a parent element first, then find the child element that matches the given condition within it. Here, $(\"xxx\") selects a parent element, and $('xxxx') searches for the child element within that parent element."},{"t":"h","c":"Example"},0,{"t":"p","c":"In the example above, firstly the parent element with the class parent is selected using $(\".parent\"), and then the child element with the class child is found within that parent element using $(\".child\"). Then the text content of the child element is modified to \"Modified child element\"."},{"t":"h","c":"Using the $('xxx xxxx') approach"},{"t":"p","c":"$('xxx xxxx') searches for elements that match the second selector condition in the global scope, and then finds elements that match the first selector condition within those elements. This allows for directly finding the child element that meets the conditions."},{"t":"h","c":"Example"},0,{"t":"p","c":"In the example above, the child element with the class child is directly found using $('div .child'), and then the text content of the child element is modified to \"Modified child element\"."},{"t":"h","c":"Select multiple elements"},{"t":"h","c":"Use $.all('xxx') to find global elements"},{"t":"p","c":"The $.all('xxx') method is used to find all elements in the page that match the selector condition and return them as a collection of elements. This allows you to select multiple elements in the page for batch operations."},{"t":"h","c":"Example"},0,{"t":"p","c":"In the above example, using $.all(\"p\") finds all the p tag elements on the page and performs batch operations on them by modifying their text content to \"Modified Paragraph 1\", \"Modified Paragraph 2\", and \"Modified Paragraph 3\"."},{"t":"h","c":"Find all elements that meet the condition within an element"},{"t":"p","c":"In addition to finding elements globally, you can also find all child elements that meet the condition from a specific element using the following method: $('xxx').all('xxxx')."},{"t":"h","c":"Example"},0,{"t":"p","c":"In the example above, first use $(\".container\") to find elements with the class container, then use .all(\".item\") to find all child elements with the class item within that container, and perform batch operations on them, modifying the text content to \"Modified Item 1\", \"Modified Item 2\", and \"Modified Item 3\"."},{"t":"h","c":"Events"},{"t":"p","c":"We have already discussed the usage of on to bind events. Here are a few other methods related to events;"},{"t":"h","c":"Documentation for the use of the off method"},{"t":"p","c":"The off method is used to remove event handlers bound using the on method. When an event handler is no longer needed, it can be removed from the element using the off method to avoid duplicate execution or memory leaks."},{"t":"h","c":"Syntax"},0,{"t":"l","c":"- selector: The element to remove the event handler from.\n- eventName: The event name to remove.\n- eventHandler: The event handler to remove."},{"t":"h","c":"Example"},0,{"t":"p","c":"In the example above, when the button is clicked, a dialog box displaying \"Button clicked!\" will appear. However, after 5 seconds, the click event handler is removed using the off method, so clicking the button again will not trigger the dialog box."},{"t":"h","c":"Documentation for the use of the one method"},{"t":"p","c":"The one method is used to bind event handlers that will only execute once when the event is triggered for the first time. After executing once, the event handler will be automatically removed, preventing duplicate triggers."},{"t":"h","c":"Syntax"},0,{"t":"l","c":"- selector: Selects the element to bind the event handler to.\n- eventName: The name of the event to bind.\n- eventHandler: The event handler to execute."},{"t":"h","c":"Example"},0,{"t":"p","c":"In the above example, when the button is clicked, a dialog box with the message \"Button clicked once!\" will appear. However, after the first click, the event handler will be removed, so subsequent clicks will not trigger the dialog box."},{"t":"h","c":"Documentation for the emit method"},{"t":"p","c":"The emit method is used to manually trigger a specific event bound to an element. It allows for executing event handler functions without performing any actual operations."},{"t":"h","c":"Syntax"},0,{"t":"l","c":"- selector: Selects the element to trigger the event on.\n- eventName: The name of the event to trigger."},{"t":"h","c":"Example"},0,{"t":"p","c":"In the above example, the emit method is used to manually trigger the click event on the button. This will result in a dialog box with the message \"Button clicked!\" even though the button was not actually clicked."},{"t":"p","c":"Note: The emit method does not simulate a mouse click or any other actual event. It only directly invokes the bound event handler functions. Therefore, if you want to trigger the execution of an event in specific circumstances, you can use the emit method."},{"t":"p","c":"When you bind an event, sometimes you may want to stop the event from further propagation (bubbling) or cancel the default behavior of the event. Below we will explain how to stop bubbling and cancel default events after the event is triggered."},{"t":"h","c":"Stop Event Bubbling"},{"t":"p","c":"Event bubbling refers to when an event on an element is triggered, it will bubble up along the DOM tree, triggering the same type of event on parent elements one by one. If you want to stop it from bubbling further after handling the event on a specific element, you can use the event.stopPropagation() method."},{"t":"p","c":"Example code:"},0,{"t":"p","c":"In the above example, when you click the \"Click Me\" button, it will display \"Button Clicked!\" but will not trigger \"Inner Div Clicked!\" and \"Outer Div Clicked!\". This is because we called event.stopPropagation() in the button's click event handler, stopping the event from further propagation."},{"t":"h","c":"Prevent Default Event"},{"t":"p","c":"Some events on elements have default behaviors when triggered. For example, clicking a submit button will submit the form, clicking a link will redirect to the link's address, and so on. If you want to prevent the default behavior of an event, you can use the event.preventDefault() method."},{"t":"p","c":"Example code:"},0,{"t":"p","c":"In the above example, when you click the submit button \"Submit\", it will display \"Hello, {name}! Form submission prevented.\", but it will not trigger the alert \"Form Submitted!\". This is because we call event.preventDefault() in the click event handler of the submit button to prevent the default submission behavior of the form."}],"css":[{"t":"h","c":"CSS usage"},{"t":"p","c":"In ofa.js, you can manipulate the CSS styles of an element using the following methods;"},{"t":"h","c":"Get specific CSS style of an element"},{"t":"p","c":"You can use $ele.css.xxx to get the specific CSS style of an element, where xxx is the CSS property name you want to retrieve."},{"t":"h","c":"Example"},0,{"t":"h","c":"Set a specific style property"},{"t":"p","c":"You can set the CSS style of an element using the $ele.css.xxx = '' syntax, where xxx is the CSS property name you want to set. By assigning an empty string as the property value, you can remove the specified style property."},{"t":"h","c":"Example"},0,{"t":"h","c":"Assigning an object"},{"t":"p","c":"You can set the element's style using $ele.css = {xxx}, where xxx is an object containing CSS property names and values."},{"t":"h","c":"Example"},0,{"t":"h","c":"Assigning Strings"},{"t":"p","c":"You can set the style of an element using the $ele.css = 'color:red;...' syntax, where 'color:red;...' is a string that contains CSS style rules."},{"t":"h","c":"Example"},0,{"t":"h","c":"Tips for setting CSS"},{"t":"p","c":"You can modify a specific style property of an element without affecting other properties by using $ele.css = {...$ele.css, color:'red'}. This allows you to modify only one property without rewriting the entire style."},{"t":"h","c":"Example"},0,{"t":"p","c":"In the example above, by using { ...myElement.css, color: 'red' }, we only modified the color style of the element while keeping other style properties unchanged. This is a convenient technique that allows flexible modification of element styles."}],"classlist-and-data":[{"t":"h","c":"classList and data"},{"t":"h","c":"classList"},{"t":"p","c":"In ofa.js, you can manipulate an element's classList using the following methods: "},{"t":"l","c":"- $ele.classList: Returns the element's classList object, used for manipulating the element's class names."},{"t":"h","c":"classList usage for adding and removing class names"},{"t":"l","c":"- Adding a class name: $ele.classList.add('className'), adds the specified class name to the element's classList. \n- Removing a class name: $ele.classList.remove('className'), removes the specified class name from the element's classList. \n- Toggling a class name: $ele.classList.toggle('className'), removes it if the element's classList already contains the class name; otherwise, adds it."},{"t":"h","c":"Example"},0,{"t":"p","c":"In this example, there is a <div> element with an initial class name of box, as well as three buttons: Add Highlight, Remove Highlight, and Toggle Highlight. "},{"t":"l","c":"- When the \"Add Highlight\" button is clicked, the highlight class name is added to the <div> element using the classList.add() method, giving it a yellow background color. \n- When the \"Remove Highlight\" button is clicked, the highlight class name is removed from the <div> element's class name using the classList.remove() method, restoring the original style. \n- When the \"Toggle Highlight\" button is clicked, the highlight class name of the <div> element is toggled using the classList.toggle() method. If the class name already exists, it is removed; if it doesn't exist, it is added, achieving a style toggle."},{"t":"p","c":"This way, you can use the classList object to manage the class names of an element, dynamically controlling its styles."},{"t":"h","c":"Usage of data"},{"t":"p","c":"In ofa.js, you can manipulate an element's data attribute in the following ways: "},{"t":"l","c":"- $ele.data: Returns the dataset object of the element, used for manipulating its data attribute."},{"t":"h","c":"Specific usage of dataset"},{"t":"p","c":"An element's data-* attributes can be used to store custom data in HTML and can be accessed using the data object."},{"t":"p","c":"For example, if an element has a data-info attribute:"},0,{"t":"p","c":"You can use dataset to access that attribute:"},0,{"t":"p","c":"Note: The property names in the dataset object are converted to camel case, excluding the \"data-\" part. For example, data-info becomes dataset.info. If you want to set a data-* attribute, you can also achieve it through the dataset object."},0,{"t":"p","c":"This will add a data-another-info attribute to the element and set its value to \"another value\"."}],"box-model":[{"t":"h","c":"Box Model"},{"t":"p","c":"In front-end development, we often use some properties to represent the size of an element. These properties include width, height, clientWidth, clientHeight, offsetWidth, offsetHeight, outerWidth, and outerHeight. Understanding their meanings and usage is very important for developing responsive and dynamic layouts. Let's explain them one by one and demonstrate them with an example."},{"t":"l","c":"- width: represents the width of the content area of an element, excluding padding, border, and margin.\n- height: represents the height of the content area of an element, excluding padding, border, and margin.\n- clientWidth: represents the width of the visible content area of an element, including padding but excluding border and margin.\n- clientHeight: represents the height of the visible content area of an element, including padding but excluding border and margin.\n- offsetWidth: represents the overall width of an element, including the content area, padding, border, and margin.\n- offsetHeight: represents the overall height of an element, including the content area, padding, border, and margin.\n- outerWidth: represents the overall width of an element, including the content area, padding, border, and margin, but excluding the width of the scrollbar.\n- outerHeight: represents the overall height of an element, including the content area, padding, border, and margin, but excluding the height of the scrollbar."},0],"formdata":[{"t":"h","c":"Form Functionality"},{"t":"p","c":"The $ object provides some convenient form functionality, making it easier and more efficient to handle form elements."},{"t":"h","c":"Generating an Object using formData"},{"t":"p","c":"The formData method is used to generate an object containing the values of all form elements within the target element. This object reflects the changes in form elements in real-time."},0,{"t":"h","c":"Listening to Specific Form Elements"},{"t":"p","c":"By default, formData() listens to all input, select, and textarea elements within the target element. You can listen to specific form elements by passing a selector."},0,{"t":"h","c":"Stanz Object"},{"t":"p","c":"The object returned by the formData() method is called the Stanz object. Stanz is part of the $ extension library and provides efficient handling and listening functionality for form data."},{"t":"p","c":"You can learn more about Stanz and its usage tutorials and features by visiting https://github.com/kirakiray/stanz."},{"t":"p","c":"By using the form function above, you can easily handle the values and changes of form elements, thereby improving the convenience and efficiency of form operations."}],"common-function":[{"t":"h","c":"Common Methods"},{"t":"h","c":"attr"},{"t":"p","c":"The attr method allows you to get or set the attribute of an element."},0,{"t":"p","c":"In the above example, we first select a div element with an id of \"example\". Then, we use the attr method to get the name attribute of the element and print it to the console. Next, we use the attr method to set the title attribute of the element to \"change title\"."}],"index":[{"t":"h","c":"Getting Started"},{"t":"h","c":"How to Use"},{"t":"h","c":"Direct Reference"},{"t":"p","c":"You can directly reference ofa.js to your page using CDN like this:"},0,{"t":"h","c":"Installation via npm"},{"t":"p","c":"First, install ofa.js in your project:"},0,{"t":"p","c":"Then import the ofa.js module in your project:"},0,{"t":"h","c":"Usage"},{"t":"p","c":"After referencing the resource, ofa.js will set a $ property on the global scope. All the functionalities will be available on $. The following tutorials will explain its usage in detail."},{"t":"p","c":"Under normal circumstances, we recommend using the direct reference method to add ofa.js, while the use of npm is used to be compatible with frameworks like React and Vue."}],"hello-world":[{"t":"h","c":"First Case"},{"t":"p","c":"The following is an example where the text is changed to \"Hello World\" after clicking the button:"},0,{"t":"p","c":"After clicking the button, the text \"Hello World\" will be displayed in bold."},{"t":"p","c":"Now, let's explain the basic concepts in detail."},{"t":"h","c":"Selector"},{"t":"p","c":"After importing ofa.js, the $ symbol will be registered in the global scope. Use $('xxx') to select the first element that meets the conditions, where xxx is a standard CSS Selector content. You can click the link to view specific selector contents."},{"t":"p","c":"Here is an example:"},0,{"t":"p","c":"In the above example, after opening the page for one second, the text content of p tags, #desk, and .logger will be changed respectively."},{"t":"h","c":"Event Binding"},{"t":"p","c":"After successfully selecting an element, you can bind events to the element. Just like in the \"Hello World\" example mentioned before, we bound a click event to the element with id \"btn\". When the button is clicked, the bound function will be executed."},{"t":"p","c":"You can click to go to the Event Examples section to learn about some examples of event binding."},{"t":"p","c":"For a complete list of available events, you can refer to Web Events."},{"t":"h","c":"Properties"},{"t":"p","c":"In the above two examples, we demonstrated the use of the html and text properties respectively."},{"t":"p","c":"You can also use the html or text properties to retrieve the content of an element, as shown below:"},0,{"t":"p","c":"In this example, we assigned the HTML content of the #t1 element to the #t2 and #t3 elements."}],"basic-concept":[{"t":"h","c":"Basic Concepts of Instances"},{"t":"p","c":"The $ instance is an encapsulation of elements on a page. In addition to selecting existing elements, it can also create new elements and manipulate them. In this chapter, we will introduce how to create new elements and perform some operations on the $ instance."},{"t":"h","c":"Creating New Elements"},{"t":"p","c":"Through the $ instance, we can directly create new elements and manipulate them. For example:"},0,{"t":"p","c":"In the above example, we created a new div element using $('<div style=\"color:red\">I am text</div>') and added it to the body."},{"t":"h","c":"Accessing Child Elements"},{"t":"p","c":"The instances retrieved using $ do not have a children property like DOM elements. However, we can access the direct child elements of an instance using array indexes:"},0,{"t":"p","c":"In the above example, we retrieved the div element and accessed the first and second p elements using indexes. We also used $div.length to get the number of child elements."},{"t":"h","c":"Manipulating Child Elements"},{"t":"p","c":"Using the $ instance, we can directly use array methods to manipulate child elements, such as push and pop:"},0,{"t":"p","c":"In the above example, we obtained instances of '$' for all 'p' elements and used the 'push' method to add a new 'div' element as a child element, and then used the 'pop' method to remove the last child element."},{"t":"p","c":"Through the above example, you can understand some basic operations of the '$' instance, including creating new elements and accessing and manipulating child elements. The '$' instance provides convenient methods for manipulating elements on the page."}],"common-properties":[{"t":"h","c":"Common Properties"},{"t":"p","c":"In a $ instance, in addition to selecting elements using selectors, there are also some common properties provided for easy element manipulation and retrieval."},{"t":"h","c":"tag Property"},{"t":"p","c":"The tag property is used to get the lowercase tag name of the current element, similar to the tagName property of DOM elements."},0,{"t":"h","c":"ele Property"},{"t":"p","c":"The ele property is used to get the actual DOM element of the $ instance, allowing native JavaScript operations on that element."},0,{"t":"h","c":"index Property"},{"t":"p","c":"The index property is used to get the ranking index of the current element among sibling elements, starting from 0."},0,{"t":"h","c":"parent and parents attributes"},{"t":"l","c":"- The parent attribute is used to get the direct parent element of the current element. \n- The parents attribute is used to get an array of all ancestor elements of the current element (including the parent's parent, the parent's parent's parent, and so on)."},0,{"t":"h","c":"next, nexts, prev, prevs, siblings attributes"},{"t":"l","c":"- The next attribute is used to get the next sibling element of the current element. \n- The nexts attribute is used to get an array of all sibling elements that come after the current element. \n- The prev attribute is used to get the previous sibling element of the current element. \n- The prevs attribute is used to get an array of all sibling elements that come before the current element. \n- The siblings attribute is used to get all sibling elements of the current element, excluding itself."},0]},"create-component":{"index":[{"t":"h","c":"Creating and Using Components"},{"t":"p","c":"ofa.js uses basic HTML and JavaScript files to define components, avoiding the need to introduce new file types to reduce learning costs. With a certain understanding of HTML, you can quickly develop and use ofa.js components."},{"t":"h","c":"Steps before creating a component"},{"t":"p","c":"Before creating a component, there are some preparations to be made. Since creating a component involves browser requests for resources, if you simply double-click to open the HTML file for viewing, it will be viewed under the \"file\" protocol. Under the \"file\" protocol, loading JavaScript modules may result in errors. Therefore, you need to prepare a static server to view the components correctly."},{"t":"p","c":"If you are using the Visual Studio Code editor, you can simply install a plugin that supports a static server. We recommend using the Live Server plugin."},{"t":"p","c":"After installing the plugin, simply right-click on the demo.html file and select \"Open with Live Server\", and the plugin will automatically open the file in static server mode."},{"t":"p","c":"If you are using another editor, you can also create an Nginx or Apache server as long as it supports viewing static HTML. This ensures that you can preview and develop your components normally."},{"t":"h","c":"Creating a Button Component"},{"t":"p","c":"Next, we will create a simple button component named simple-button, which will have a more beautiful style than native buttons."},{"t":"p","c":"First, create a file named simple-button.html, which uses the <template> tag and adds the component attribute to identify it as a component."},{"t":"p","c":"Then, write the template code for the component inside the <template> tag. Next, add a <script> tag below the template content to include the component's JavaScript code."},0,{"t":"p","c":"After successfully introducing ofa.js, the load-module component will be automatically registered. This is a component used to declaratively import modules, similar to a script tag. This component acts as a proxy to load the specified src module and preprocess the modules that need to be loaded. In this example, it will load the template and register the simple-button component."},{"t":"p","c":"The load-module component can also be abbreviated as l-m to reduce the amount of code."},0,{"t":"p","c":"The load-module component is a custom declarative loader library that provides powerful functionality and can extend support for various types of files or intermediate processing of JavaScript modules. It has been split into a separate project, and the specific usage documentation is available at https://github.com/kirakiray/drill.js."},{"t":"h","c":"Dual file mode"},{"t":"p","c":"Dual file mode separates the static template and logical code, making the component clearer."},{"t":"p","c":"The logical code is placed in a js file, and this js file needs to indicate export const type = $.COMP; to inform the page that this is a component module. In this split mode, module code can use standard syntax like import of ES Modules."},{"t":"p","c":"The button component consists of two files:"},{"t":"l","c":"1. simple-button.html: HTML template and styles for the button component."},0,{"t":"l","c":"2. simple-button.mjs: Registration code for the button component."},0,{"t":"p","c":"To use this component, import this module using l-m. Here is an example page using simple-button (dual-file mode)."},0],"parameter-description":[{"t":"h","c":"Explanation of Component Registration Parameters"},{"t":"p","c":"In ofa.js, you can define some specific registration parameters in the component module to configure the component more flexibly. The following explains each registration parameter in detail, accompanied by relevant demonstration examples."},{"t":"h","c":"Basic Parameters"},{"t":"p","c":"The basic parameters are the most basic configurations for registering a component and include the following properties:"},{"t":"h","c":"Component Identifier"},{"t":"p","c":"The component module must have 'export const type = $.COMP' to identify it as a component module."},{"t":"p","c":"Example:"},0,{"t":"h","c":"tag"},{"t":"p","c":"tag represents the registered component name. When tag property is not defined, the registered component name remains the same as the file name."},{"t":"p","c":"Example:"},0,{"t":"h","c":"temp"},{"t":"p","c":"temp is a string type property used to define the address of the component template. When temp is not defined, it defaults to loading an HTML file with the same name as the component in the same directory as the current module."},{"t":"p","c":"Example:"},0,{"t":"h","c":"data"},{"t":"p","c":"data is an object type property used to generate default custom data added after the component is created."},{"t":"p","c":"Example:"},0,{"t":"h","c":"attrs"},{"t":"p","c":"attrs is an object type property belonging to data, but this data will be reflected in the element's attributes, and changes to the attributes will dynamically change the component's data. When there is a capital letter key, it will be converted to - camel case naming in the component attribute."},{"t":"p","c":"Example:"},0,{"t":"h","c":"proto"},{"t":"p","c":"In the registration parameter of the component, you can add a proto object to define the methods that need to be added to the component's prototype. This way, when creating an instance of the component, these attributes and methods will be added to the prototype of the instance, allowing all instances to access and share these methods."},0,{"t":"h","c":"watch"},{"t":"p","c":"watch is an object type property used to listen for changes in data. The listener function is placed here. Once registered successfully, the listener function will be immediately executed."},{"t":"l","c":"- The function registered by watch will only be triggered once during a single thread change. Therefore, even if the monitored value is modified multiple times within a thread, it will only be triggered once.\n- The first parameter is the current value.\n- The second parameter is an object that contains a watchers data set. In most cases, the watchers object will only contain one object. You can retrieve the oldValue from this object. When the monitored value has been changed multiple times within a single thread, this data set will record multiple changes."},{"t":"p","c":"Example:"},0,{"t":"h","c":"Example Code"},{"t":"p","c":"The following is a complete example code, including the definition of basic parameters and the component template."},0,0,0,{"t":"h","c":"default"},{"t":"p","c":"You can also use asynchronous functions to define the 'default' data in order to dynamically return the registration parameters of the component."},{"t":"p","c":"The 'function' of the function will bring an object that contains"},{"t":"p","c":" 'load', 'url', and 'query':"},{"t":"l","c":"- The 'load' method is an asynchronous loading function, which can be loaded asynchronously by using the same method as asynchronous 'import', and can load asynchronous modules using 'const data = await load(xxx)'.\n- Modules loaded through 'load' will have the same effect as those loaded by 'load-module'. The 'load' method is a functional version of the 'load-module' component, and specific usage can be found in the documentation of https://github.com/kirakiray/drill.js.\n- 'url' is the filename of the current module.\n- 'query' is an object converted from URL parameters when loading this module."},{"t":"p","c":"Here is an example of using 'default':"},0,{"t":"p","c":"In this example, we demonstrate how to customize the behavior of a component using the registration parameters ofa.js. By configuring these parameters properly, you can better adapt to different component requirements and achieve more flexible component development."},{"t":"p","c":"Write a documentation on how to use the registration parameters of the component proto."}],"life-cycle":[{"t":"h","c":"Component Lifecycle"},{"t":"p","c":"In ofa.js, the component lifecycle is triggered by specific hooks at certain times. These hooks allow you to have finer control and interaction. ofa.js has five key lifecycle hooks: created, ready, watch, loaded, attached, and detached, which are triggered at different moments."},{"t":"h","c":"Lifecycle Hooks"},{"t":"h","c":"created"},{"t":"p","c":"The created lifecycle hook is triggered when the component is created. At this stage, the component's data has not been initialized and the template content has not been rendered. You can perform some initialization operations or prepare data to be used in subsequent stages."},{"t":"h","c":"ready"},{"t":"p","c":"The ready lifecycle hook is triggered right after the component's data and template have been initialized, indicating that the component is ready. At this stage, you can access the component's data and the template has been fully rendered, allowing you to perform some interactions with the interface."},{"t":"p","c":"If the component's template depends on other components, this stage does not wait for the dependencies to be loaded. Therefore, this stage is suitable for adding loading styles to the component, but you need to wait for the dependencies to be loaded before performing any relevant operations."},{"t":"h","c":"watch"},{"t":"p","c":"Once the ready stage is completed, the listener functions in the associated watch object will be triggered once. Afterwards, when a value of the data changes, the corresponding key's listener function will be triggered again."},{"t":"h","c":"loaded"},{"t":"p","c":"The loaded lifecycle hook is triggered after all dependencies within the component template have been loaded. This stage ensures that all dependencies have been loaded before rendering the component. It is suitable for removing the loading styles added in the ready stage."},{"t":"h","c":"attached"},{"t":"p","c":"attached lifecycle hook is triggered when the component is added to the document. In this stage, it is suitable for obtaining size-related information of the component's elements, performing data binding, and global event operations."},{"t":"h","c":"detached"},{"t":"p","c":"detached lifecycle hook is triggered when the component is removed from the document. In this stage, you can perform some cleanup operations, such as canceling event listeners or releasing resources, to prevent memory leaks."},{"t":"h","c":"Example Demonstration"},{"t":"p","c":"Here is an example demonstrating how to use these lifecycle hooks:"},0,0,0,{"t":"p","c":"In the above example, we have defined a component named 'lifecycle-demo' and placed a button in its template. Through different lifecycle hooks, we can observe the logs triggered at each stage in the console."},{"t":"h","c":"Lifecycle Flow Chart"},0],"web-components":[{"t":"h","c":"Encapsulation and Componentization: Basic Knowledge of Componentization"},{"t":"p","c":"ofa.js is a wrapping library based on Web Components technology, aiming to simplify and accelerate the component development process. By hiding the complex technical details behind, it enables developers to focus more on building high-quality components and applications."},{"t":"p","c":"To better develop components, it is necessary to learn some knowledge of Web Components. The knowledge points introduced below can not only be applied in ofa.js, but also benefit you in other frameworks that use Web Components."},{"t":"h","c":"Shadow DOM Container"},{"t":"p","c":"In Web Components, the Shadow DOM provides an isolated container for encapsulating the internal styles and structure of a component. This means that the internal styles and DOM structure of a component will not interfere with the external styles and structure, ensuring the predictability and maintainability of the component."},{"t":"p","c":"In ofa.js, each component has a Shadow DOM container for isolating the internal content of the component. The template content is rendered into this container. The component instance obtained through $ can also access the internal Shadow DOM container through the shadow property, thus achieving operations and access to the internal elements of the component."},0,{"t":"h","c":"Common CSS Selectors in Web Components"},{"t":"p","c":"Web Components provide some special CSS selectors for selecting and styling different parts within the component. Here are some common selectors:"},{"t":"h","c":":host Selector"},{"t":"p","c":":host selector is used to select the outer container of the component itself. This selector can be used to define the style of the component."},0,{"t":"h","c":"::slotted() Selector"},{"t":"p","c":"::slotted() selector is used to select the elements wrapped by slotted content. This selector can be used in internal styles of the component to style the slotted content."},0,{"t":"h","c":"Usage of Slots"},{"t":"p","c":"Slots are mechanisms in Web Components used to embed external content within the component. Slots allow developers to pass custom content into the component, enabling more flexible component structures."},{"t":"h","c":"Single Slot"},{"t":"p","c":"In the component template, the <slot> element can be used to define a slot. The content provided from outside will be inserted into the slot."},0,0,{"t":"h","c":"Multiple Named Slots"},{"t":"p","c":"In addition to the default slot, multiple named slots can also be defined. Named slots allow developers to insert different contents into different slot positions."},0,0,{"t":"h","c":"Usage of slotchange event"},{"t":"p","c":"The slotchange event is triggered when the content of a slot changes. This event can be listened to in order to perform actions related to the slot content."},0],"template-syntax":[{"t":"h","c":"Template Syntax"},{"t":"p","c":"ofa.js provides a series of powerful template syntax that allows you to manipulate component's interface elements and data more flexibly. These template syntax can help you achieve rich interface effects and interactive experiences."},{"t":"h","c":"Text Rendering Syntax"},{"t":"p","c":"By using the rendering text syntax {{key}}, you can render data as text content and embed it into the component's template. The corresponding text content will also be automatically updated when the data changes."},{"t":"p","c":"Here is an example using text rendering syntax:"},0,0,{"t":"p","c":"In the example above, {{username}} will be replaced by the value of the username property in the component's data, thus displaying \"Welcome, JohnDoe!\" on the interface."},{"t":"h","c":"Attribute Binding Syntax"},{"t":"p","c":"Using the attribute binding syntax :xxx='yyy', you can bind a component's property to the attribute of an element within the template. This binding is one-way, where changes in the property will affect the attribute of the element but not vice versa."},{"t":"p","c":"Here are some common examples of property bindings:"},0,0,{"t":"p","c":"In the example above, :text=\"greeting\" binds the value of the greeting property in the component's data to the text content of the <p> element. :value=\"inputValue\" binds the value of the inputValue property in the component's data to the value attribute of the <input> element. For custom components, custom-prop is the name of the property in the custom component that receives the value of the customValue property in the component's data."},{"t":"h","c":"Event Binding"},{"t":"p","c":"Using the format on:click=\"yyy\", you can bind a specified event (e.g., click) of the target element to a property yyy in the host component. This way, when the target element triggers the specified event, it will invoke the corresponding property method in the host component."},{"t":"p","c":"Here is an example:"},0,0,{"t":"p","c":"In the example above, when the button is clicked, it will call the increaseCount method of the host component to increase the value of the count property."},{"t":"h","c":"Attribute binding"},{"t":"p","c":"Using the form attr:xxx=\"yyy\", you can bind the specified attribute xxx of the target element to the property yyy of the host component. This way, the attribute of the target element will change as the property of the host component changes."},0,0,{"t":"p","c":"In the example above, attr:fontcolor=\"val\" will bind the host component's val property to the fontcolor attribute of the <div> element."},{"t":"h","c":"Dynamic class binding"},{"t":"p","c":"Using the form class:xxx=\"yyy\", you can dynamically add or remove class names to the target element based on the property value of the host component. When the host component's yyy property is true, the target element will add the class name xxx; otherwise, it will remove that class name."},0,0,{"t":"p","c":"In the example above, if the isActive property is true, the button will add the active class name to apply specific styles."},{"t":"h","c":"Two-way Data Binding"},{"t":"p","c":"By using the form of sync:xxx='yyy', you can achieve two-way data binding. This keeps the attribute xxx of the target element in sync with the property yyy of the host component, so that changes in the target attribute will be reflected in the host property, and changes in the host property will also be synced to the target attribute."},{"t":"p","c":"Here is an example:"},0,0,{"t":"p","c":"In the example above, sync:value=\"inputValue\" achieves two-way data binding, so when the value of the input box changes, inputValue will be automatically updated; conversely, when inputValue changes, the value of the input box will also change accordingly."}],"template-component":[{"t":"h","c":"Template Rendering Component"},{"t":"p","c":"In addition to using template syntax, ofa.js also provides rendering components dedicated to templates, including conditional rendering components and filling rendering components."},{"t":"h","c":"Conditional Rendering Component"},{"t":"h","c":"x-if Component"},{"t":"p","c":"x-if component is used to dynamically render content based on conditions. It accepts a value attribute to determine whether to render its child elements. If the value is true, the child elements will be rendered; otherwise, they will not be rendered."},{"t":"p","c":"Here is an example using x-if to render different content based on a condition:"},0,0,{"t":"h","c":"x-else Component"},{"t":"p","c":"x-if can be used in conjunction with x-else to achieve conditional switching of rendering."},{"t":"p","c":"Here is an example using x-if and x-else to switch the rendered content based on different conditions:"},0,0,{"t":"h","c":"x-if + x-else-if + x-else component"},{"t":"p","c":"x-if can also be combined with x-else-if and x-else to achieve rendering based on multiple conditions."},{"t":"p","c":"Here is an example using x-if, x-else-if, and x-else to toggle rendering based on multiple conditions:"},0,0,{"t":"p","c":"In the above example, different content will be rendered based on the value of condition, achieving the effect of toggling rendering based on multiple conditions."},{"t":"h","c":"Template Component: x-fill"},{"t":"p","c":"x-fill component allows you to dynamically fill content in a template. It can generate different content based on the attribute values of the host component. x-fill component uses the name attribute to specify the fill template to use and passes data to the fill template through the value attribute."},{"t":"h","c":"Example of filling an array of strings with x-fill"},{"t":"p","c":"Here is an example of using x-fill to fill an array of strings, filling different string content through a loop:"},0,{"t":"p","c":"In the above example, x-fill uses a filling template called fillTemplate and passes an array to it. The filling template uses {{ $data }} to render each element in the array, thus achieving looped filling of different string content."},{"t":"h","c":"Example of x-fill filling an object and being able to self-fill"},{"t":"p","c":"x-fill can also fill objects with more complex structures and supports self-nested filling."},{"t":"p","c":"The following is an example of using x-fill to fill an object and perform self-nested filling, demonstrating how to generate nested content:"},0,0,{"t":"p","c":"In the example above, x-fill uses a filling template called nestedFillTemplate and passes a complex nested object to it. The filling template uses {{ $data.title }} to render the object's title and also uses nested x-fill to fill the contents of the child items, achieving nested content generation."},{"t":"h","c":"The meaning of $data, $ele, and $host in the template"},{"t":"p","c":"Within the filling template, you can use special identifiers to access different data:"},{"t":"l","c":"- {{ $data }}: represents the data passed to the filling template, which is the value of the value attribute.\n- {{ $ele }}: represents the current element in which the filling template is located and can be used to access the element's attributes and styles.\n- {{ $host }}: represents the instance of the host component and can be used to access the host component's properties and methods."},{"t":"p","c":"These special identifiers can help you dynamically access and render different data within the filling template. In the example, you can see how to use {{ $data.title }} to access the title of the passed data and how to use {{ $host.num }} to access the property of the host component."}]},"introduce":[{"t":"h","c":"ofa.js - Progressive Front-end Framework"},{"t":"h","c":"What is ofa.js"},{"t":"p","c":"ofa.js is a progressive front-end framework designed to allow developers to enter the front-end development and usage process at the lowest cost. It provides a series of simple yet powerful tools and APIs to make front-end development more efficient and convenient."},{"t":"h","c":"Purpose of Existence"},{"t":"h","c":"Replace jQuery"},{"t":"p","c":"In many small projects, we may not need to introduce large frameworks like React and Vue, but prefer to use jQuery for simple front-end operations. ofa.js improves the API of jQuery and replaces many of jQuery's methods with properties, making ofa.js more suitable in many scenarios."},{"t":"h","c":"Simplify front-end development and usage process"},{"t":"p","c":"ofa.js aims to simplify the cumbersome front-end development process. It allows developers to build front-end applications more quickly without the need to learn complex tools such as Node.js, npm, and scaffolding. With it, you can go back to the experience of just importing one library to develop."},{"t":"h","c":"Become a Silver Bullet Front-end Development Framework"},{"t":"p","c":"ofa.js aims to be a \"silver bullet\", capable of solving various front-end development problems and providing comprehensive solutions. It is not just a utility library, but a comprehensive front-end development framework."},{"t":"h","c":"Features"},{"t":"h","c":"Easy-to-use component development"},{"t":"p","c":"There is almost no learning cost for components developed using ofa.js. ofa.js provides a concise and intuitive API that allows developers to quickly create and integrate components while keeping the code clean and maintainable."},{"t":"h","c":"Built-in modularization, state update, and application integration solutions"},{"t":"p","c":"ofa.js has integrated solutions for modularization, state updating, and application integration, allowing developers to complete complex front-end development tasks without the need for additional third-party libraries or tools."},{"t":"h","c":"Officially provided routing and SSG (Static Site Generation) solutions"},{"t":"p","c":"ofa.js also provides official solutions for routing and SSG, helping developers better manage front-end routing and generate static websites to improve application performance and SEO friendliness."},{"t":"h","c":"Compact code size"},{"t":"p","c":"ofa.js code has been carefully optimized, and the compressed .min file size is only 38kb (only 14kb under gzip). This makes ofa.js an efficient front-end framework that can be quickly loaded and used in various network environments."}],"create-app":{"index":[{"t":"h","c":"Developing an application"},{"t":"p","c":"In addition to developing components, ofa.js can also be used to develop fully functional applications."},{"t":"p","c":"ofa.js integrates the application as an o-app component, allowing you to quickly create applications by simply using this tag. This simplifies and streamlines the process of application creation."},{"t":"p","c":"Furthermore, ofa.js also provides a complete routing and SSG (Static Site Generation) solution, helping developers build more robust applications. These features accelerate the development process and allow you to focus on the logic and user experience of the application, without having to worry too much about the underlying details."},0,{"t":"p","c":"The above is a simple application tutorial code example, and the development process of the application will be explained gradually next."}],"page":[{"t":"h","c":"Development Page"},{"t":"p","c":"Inside ofa.js, we have created a custom component called 'o-page', which aims to provide convenience for page development. This component plays a key role in application development. When you want to use the component's template syntax but don't want to create a completely new component, the 'o-page' component will be your best choice."},{"t":"h","c":"Page Module"},{"t":"p","c":"When creating a single-file page module, it is similar to creating a component module. Use the template tag to wrap the template code of the page and add the page attribute. Inside this tag, you can freely use template syntax to interact with other components or page modules."},0,{"t":"p","c":"In the HTML file, use the o-page tag's src attribute to specify the file path of the page module. The page content will be rendered inside this component."},0,{"t":"h","c":"Dual-file mode"},{"t":"p","c":"Dual-file mode separates static templates and logic code to make the content of the page more distinct."},{"t":"p","c":"The following are the steps to use the o-page component and page module:"},{"t":"l","c":"1. Create a page module:"},{"t":"p","c":"Similar to creating a component module, create a page module but set the type property to $.PAGE. The available parameters for the page module include temp, data, proto, and watch."},0,{"t":"l","c":"2. Create a page template:"},{"t":"p","c":"In the same directory as the page module, create a page template file named my-page-template.html. In this template file, you can use template syntax for interaction, similar to the component template syntax mentioned earlier."},0,{"t":"p","c":"In your HTML file, use the o-page component with the <o-page> tag and reference the file path of the page module through the src attribute. The content of the page will be rendered inside this component."},0,{"t":"p","c":"In this way, when you open the page, the o-page component will dynamically load the my-page.mjs page module and render the page content based on the template and data in the module. The lifecycle and template syntax of the page module are consistent with the component module, making the development and management of pages more unified and flexible."},{"t":"h","c":"Check if the page has finished loading"},{"t":"p","c":"In some cases, you may need to check if the page has fully loaded in order to perform specific operations. ofa.js provides several ways to check if the page has finished loading."},{"t":"h","c":"Using the page._loaded property"},{"t":"p","c":"In the page module, page._loaded is a boolean property that becomes true after the page content is fully loaded. You can use this property to check if the page has finished loading."},0,{"t":"h","c":"Using the page._rendered property"},{"t":"p","c":"Another way is to use the page.rendered property, which is a Promise. This Promise enters the resolve state after the page is loaded. You can use await page.rendered to wait for the page to finish loading and then perform the corresponding operations."},0],"subrouting":[{"t":"h","c":"Subroute mode"},{"t":"p","c":"In ofa.js, setting subroutes is slightly different from the practices of some frontend frameworks. ofa.js uses a more intuitive approach by setting the parent page as the container on the page module, to achieve the demand for subroutes."},{"t":"h","c":"Setting the parent page container"},{"t":"p","c":"To create subroutes, you first need to set the parent parameter on the page module of the child page, specifying the page module address of the parent page. This way, when the child page is loaded, ofa.js will automatically wrap the child page in the parent page container."},0,{"t":"p","c":"In the above example, the page module of the sub-page specifies the address of the parent page container using the parent parameter."},{"t":"h","c":"Parent Page Container Template Setting"},{"t":"p","c":"The template of the parent page container needs to set a <slot> element so that the sub-page can be inserted into the specified position of the parent page. At the same time, make sure that the container element of the <slot> element is set to position: relative, which is very important because the sub-page will be absolutely positioned within the parent page container."},{"t":"p","c":"Here is an example template of a parent page container:"},0,{"t":"p","c":"In the above example, by setting a container element with a slot, the sub-page will be inserted into that container. Make sure the container element has relative positioning so that the sub-page can be positioned relative to it."},{"t":"p","c":"By using this approach, you can more intuitively configure child routes by establishing the relationship between the parent page container and the sub-page for loading and rendering the sub-page."},{"t":"h","c":"Parent Page Route Listening"},{"t":"p","c":"In some cases, multiple pages share the same parent page as a container. When navigating between these pages, the parent page is not refreshed. In this case, the parent page can still listen to route changes to perform corresponding actions without refreshing the page."},{"t":"h","c":"Listening to Route Changes"},{"t":"p","c":"The parent page module can set a routerChange function to listen to route changes. When the page changes its route without refreshing the parent page, the routerChange event will be triggered. This event will pass the information of the current page and the navigation type (type)."},{"t":"p","c":"Here is an example of a parent page module that demonstrates how to set up a routerChange function to listen to route changes:"},0,{"t":"p","c":"In the above example, the routerChange function takes two parameters: current represents the current page address, and type represents the type of navigation. When the page undergoes a router change, this function is triggered and outputs the corresponding information."}],"app":[{"t":"h","c":"Create an application"},{"t":"p","c":"You can easily create a complete application window using the o-app tag. Here are the steps to create an application and configure it:"},{"t":"h","c":"Basic code"},{"t":"l","c":"1. Create an HTML file and set the o-app tag as the display window for the application. Make sure to set the o-app to fullscreen style to occupy the entire viewport."},0,{"t":"l","c":"2. Create an ES module to set the configuration data for the application. The configuration data includes the following options:"},{"t":"l","c":"- home: A string specifying the page module address for the application's homepage.\n- loading: A function that runs when the application is loading a new page. The content returned by this function will be inserted into the application as a loading indicator, and it will automatically be removed when the page finishes loading.\n- fail: A function that runs when the application fails to load a page. The value returned by this function will be displayed in the application as a loading failure message. The function receives the source address of the failed page and the error object.\n- pageAnime: The animation configuration for page transitions."},{"t":"p","c":"Here is an example of the application's configuration data:"},0,{"t":"l","c":"3. Use the o-app tag in the HTML file and reference the configuration data's ES module using the src attribute."},0,{"t":"p","c":"By following the above steps, you have successfully created an application window that uses the o-app component. The o-app component will load the page based on the settings in the configuration data, displaying a loading indicator or an error message if the loading fails, and supporting page transition animations. This allows you to quickly build a fully functional and interactive application."},{"t":"h","c":"Route Navigation"},{"t":"p","c":"In the o-app application, you can easily implement route navigation, moving from one page module to another. The following describes several different ways to perform route navigation."},{"t":"h","c":"Using <a> Tags for Route Navigation"},{"t":"p","c":"You can use <a> tags in the HTML of the page to implement route navigation. The href attribute should be specified as the path to the target page module, and the olink attribute should be added to inform the o-app component that this is a route link."},0,{"t":"h","c":"goto"},{"t":"p","c":"You can use the on:click attribute in the page template to bind a click event and call the goto method on the module to perform route navigation."},0,{"t":"p","c":"Or directly on the target element:"},0,{"t":"h","c":"Replace Navigation and Back"},{"t":"p","c":"In addition to the goto method, o-app also supports replace and back methods."},{"t":"l","c":"- The replace method is used to replace navigation. It replaces the current page's route with the route of the new page."},0,{"t":"l","c":"- The back method is used to go back to the previous page."},0,{"t":"p","c":"It should be noted that the component's route state is maintained within the application, but the route data is not bound to the current browser tab. This allows for easy navigation and transitions between pages in the application."},{"t":"p","c":"If you want to achieve binding between routes and pages, you can use the o-router component, which will be explained in detail in later chapters."},{"t":"p","c":"Using the above methods, you can implement flexible navigation within an o-app application, allowing users to easily browse different page contents."},{"t":"h","c":"Accessing the Application and Current Page"},{"t":"p","c":"Within various elements (including components) in the application, you can use the app attribute to access the o-app instance they belong to. This is useful for interactions that need to involve the entire application."},{"t":"p","c":"You can get the address of the currently active page module through the app.current property."},{"t":"p","c":"Here is an example of its usage:"},0,{"t":"p","c":"In the example above, the application tag was obtained by using the selector .app, and then the current active page address was accessed through the app.current property."},{"t":"h","c":"Tip: Pre-caching next page"},{"t":"p","c":"In some scenarios, you may already know that the user will be navigating to the next page. To improve user experience, you can pre-cache the page module of the next page so that it can be immediately loaded during actual navigation, reducing the waiting time for the user and making the experience smoother."},{"t":"p","c":"In the JavaScript code of the current page, call the load method and pass the module path of the next page. This module will be loaded and cached."},0],"scsr":[{"t":"h","c":"Static Client-Side Rendering (SCSR)"},{"t":"h","c":"What is SCSR?"},{"t":"p","c":"SCSR, or Static Client-Side Rendering, is a variation of CSR (Client-Side Rendering) that allows pages to be crawled in a static state while maintaining the user experience of CSR."},{"t":"h","c":"How to Use SCSR"},{"t":"p","c":"You can reference the SCSR library using the following method:"},0,{"t":"h","c":"SCSR's working principle"},{"t":"p","c":"SCSR works by directly running the page module in single-file mode, without using the o-page tag, thus enabling rendering on the page. Specifically, it involves placing the template code of the page module directly within the o-app."},{"t":"p","c":"Here is an SCSR example that demonstrates how to directly render the content of a page module on the page:"},0,{"t":"p","c":"The content within the template tag in SCSR is directly rendered onto the page, and this content is actually the page module of the single-file mode."},{"t":"p","c":"Continuing with the example of the home.html page, let's create a help page:"},0,{"t":"p","c":"After clicking \"GO TO HELP\" on the home.html page, it smoothly transitions to the help.html page, achieving a smooth transition effect through client-side rendering."},{"t":"h","c":"Precautions"},{"t":"p","c":"All pages using the SCSR scheme must keep the referenced resources consistent, except for descriptive content (such as title, meta:description, keywords) and page template content, to ensure consistent experience after page navigation and refresh."},{"t":"h","c":"About the SSR scheme"},{"t":"p","c":"The current SCSR scheme is actually more similar to a SSG (Static Site Generation) scheme, as it pre-renders the pages into static content and then interacts with them through the client side. ofa.js already provides a relatively independent component encapsulation scheme, allowing frontend developers to encapsulate components and then combine them with traditional backend rendering page schemes (such as Node.js, Go, Java, PHP, etc.) to quickly create high-quality web pages. "},{"t":"p","c":"We plan to provide a complete SSR (Server-Side Rendering) scheme in the future. The principle of this scheme is to first fetch the element content of the next page, and then compare it with the current page's tag content to dynamically add, delete, and modify attribute values. However, it is important to note that this SSR scheme will be more time-consuming because it involves complex element comparison and modification operations."},{"t":"p","c":"ofa.js is an emerging framework, and the author's spare time is limited, so the SSR scheme has not been fully developed yet. However, if ofa.js can have more users in the future and there is a strong demand for the SSR scheme, the author will continue to improve and develop this scheme. Currently, the author will focus on the stability and functionality expansion of the framework, and also welcomes feedback and suggestions from users in order to better meet their needs in the future."}],"o-router":[{"t":"h","c":"Usage of o-router component"},{"t":"p","c":"The o-router component is used to bind the routes within o-app to the current browser tab. It can help you manage page routing and display more conveniently."},{"t":"h","c":"Importing the o-router component"},{"t":"p","c":"First, you need to import the o-router component into your page. You can do this by referencing the router.mjs file in the following way:"},0,{"t":"h","c":"Using the o-router component"},{"t":"p","c":"To use the o-router component, you need to wrap it outside of the o-app component. This way, you can bind the routes within the application to the current browser tab."},0,{"t":"h","c":"The fix-body attribute"},{"t":"p","c":"The o-router component also provides the fix-body attribute. When you set this attribute, the component will automatically add styles to the <html> tag, making the size of the application equal to the size of the page, so that the content of the application fills the entire window."},0]},"others":{"data-sharing":[{"t":"h","c":"Data Sharing"},{"t":"p","c":"ofa.js is different from other third-party frameworks as it does not use traditional state management patterns. The author believes that state updates should be transparent, meaning that data updates should automatically trigger updates. "},{"t":"p","c":"ofa.js inherently possesses excellent data sharing capabilities, as its instances are developed based on the data sharing library Stanz. Objects on instances are all synchronizable. To achieve data sharing, simply create a separate Stanz object and have all components directly reference it."},{"t":"p","c":"The following example illustrates how to share data:"},0,0,0,0,{"t":"p","c":"In the above example, when the two components are in the attached lifecycle, they write data to the component itself. Then, the obj of the component becomes the shared data. After the detached lifecycle, the previously shared data is set to null to ensure that the data is reclaimed."},{"t":"h","c":"Precautions"},{"t":"p","c":"Since the data is shared, it is necessary to ensure that the data is reclaimed at the appropriate time to avoid memory leaks."},0],"about-micro-frontend":[{"t":"h","c":"About Micro Frontends"},{"t":"p","c":"Micro Frontends is a front-end architecture pattern designed to help teams better build and maintain large, complex front-end applications. It draws on the ideas of microservices architecture, dividing front-end applications into smaller independent parts, each of which can be developed, tested, and deployed by different teams."},{"t":"p","c":"In the process of expanding traditional monolithic front-end applications, it may become difficult to maintain and expand. The goal of micro frontends is to split the application into smaller and more manageable modules, enabling development teams to independently develop and deploy these modules, thereby improving team efficiency and application maintainability."},{"t":"p","c":"ofa.js naturally possesses the characteristics of micro frontends. What sets it apart from other frameworks is that components, pages, and applications developed based on ofa.js do not require pre-compilation. In comparison to frameworks like React, Vue, and Angular, which need to be built in a Node.js environment to generate client-side code, ofa.js development code can be directly placed on a static server, without the need for additional build steps, allowing real-time viewing, usage, and execution."},{"t":"p","c":"ofa.js adheres to the five core characteristics of micro frontends:"},{"t":"l","c":"1. Independent Deployment: Each component and page can be independently developed, tested, and deployed, enabling teams to release new features and address issues more rapidly.\n\n2. Integration: Applications developed based on ofa.js can combine different modules. This can be achieved through sharing combinations of applications, pages, and components, among other methods.\n\n3. Independent Teams: Each front-end module (component/page/application) can be developed and maintained by independent teams, thereby encouraging team autonomy and innovation.\n\n4. Shared Resources: In ofa.js projects, there are usually shared resources such as styles, components, and pages, to ensure consistency and efficiency.\n\n5. On-demand Loading: ofa.js applications can load modules as needed, thereby improving application performance and loading speed."},{"t":"p","c":"Although ofa.js cannot directly use components developed with frameworks like Vue and React, components developed based on ofa.js can be used by Vue and React, providing greater flexibility and extensibility for developers using different technology stacks."},{"t":"p","c":"Using Web Components in Vue:"},{"t":"l","c":"- Vue Web Component Wrapper\n- Integrating Vue with Web Components\n- How to Use Web Components in Vue"},{"t":"p","c":"Using Web Components in React:"},{"t":"l","c":"- Using Web Components with React\n- Using Web Components in React\n- Integrating Web Components into React"}]}},"others":{"data-sharing":[{"t":"h","c":"Data Sharing"},{"t":"p","c":"ofa.js is different from other third-party frameworks as it does not use traditional state management patterns. The author believes that state updates should be transparent, meaning that data updates should automatically trigger updates. "},{"t":"p","c":"ofa.js inherently possesses excellent data sharing capabilities, as its instances are developed based on the data sharing library Stanz. Objects on instances are all synchronizable. To achieve data sharing, simply create a separate Stanz object and have all components directly reference it."},{"t":"p","c":"The following example illustrates how to share data:"},0,0,0,0,{"t":"p","c":"In the above example, when the two components are in the attached lifecycle, they write data to the component itself. Then, the obj of the component becomes the shared data. After the detached lifecycle, the previously shared data is set to null to ensure that the data is reclaimed."},{"t":"h","c":"Precautions"},{"t":"p","c":"Since the data is shared, it is necessary to ensure that the data is reclaimed at the appropriate time to avoid memory leaks."},0],"about-micro-frontend":[{"t":"h","c":"About Micro Frontends"},{"t":"p","c":"Micro Frontends is a front-end architecture pattern designed to help teams better build and maintain large, complex front-end applications. It draws on the ideas of microservices architecture, dividing front-end applications into smaller independent parts, each of which can be developed, tested, and deployed by different teams."},{"t":"p","c":"In the process of expanding traditional monolithic front-end applications, it may become difficult to maintain and expand. The goal of micro frontends is to split the application into smaller and more manageable modules, enabling development teams to independently develop and deploy these modules, thereby improving team efficiency and application maintainability."},{"t":"p","c":"ofa.js naturally possesses the characteristics of micro frontends. What sets it apart from other frameworks is that components, pages, and applications developed based on ofa.js do not require pre-compilation. In comparison to frameworks like React, Vue, and Angular, which need to be built in a Node.js environment to generate client-side code, ofa.js development code can be directly placed on a static server, without the need for additional build steps, allowing real-time viewing, usage, and execution."},{"t":"p","c":"ofa.js conforms to the characteristics of micro frontends:"},{"t":"l","c":"1. Independent Deployment: Each component and page can be independently developed, tested, and deployed, enabling teams to release new features and address issues more rapidly.\n\n2. Integration: Applications developed based on ofa.js can combine different modules. This can be achieved through sharing combinations of applications, pages, and components, among other methods.\n\n3. Independent Teams: Each front-end module (component/page/application) can be developed and maintained by independent teams, thereby encouraging team autonomy and innovation.\n\n4. Shared Resources: In ofa.js projects, there are usually shared resources such as styles, components, and pages, to ensure consistency and efficiency.\n\n5. On-demand Loading: ofa.js applications can load modules as needed, thereby improving application performance and loading speed."},{"t":"p","c":"Although ofa.js cannot directly use components developed with frameworks like Vue and React, components developed based on ofa.js can be used by Vue and React, providing greater flexibility and extensibility for developers using different technology stacks."},{"t":"p","c":"Using Web Components in Vue:"},{"t":"l","c":"- Vue Web Component Wrapper\n- Integrating Vue with Web Components\n- How to Use Web Components in Vue"},{"t":"p","c":"Using Web Components in React:"},{"t":"l","c":"- Using Web Components with React\n- Using Web Components in React\n- Integrating Web Components into React"}]}}