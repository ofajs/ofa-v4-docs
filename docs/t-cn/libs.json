{"others":{"data-sharing":[{"t":"h","c":"數據共享"},{"t":"p","c":"ofa.js與其他第三方框架不同，不采用傳統的狀態管理模式。作者認為狀態更新應該是無感知的，即改變數據後應自動觸發數據更新。"},{"t":"p","c":"ofa.js天生就具備出色的數據共享能力，它的實例基於數據共享庫 Stanz 進行開發。實例上的對象都是可同步的。如果要實現數據共享，只需創建一個獨立的 Stanz 對象，然後讓所有組件直接引用即可。"},{"t":"p","c":"下面的案例展示了如何共享數據："},0,0,0,0,{"t":"p","c":"在上述示例中，兩個組件在 attached 生命周期時，將數據寫入到組件本身。然後，組件的 obj 就成為共享數據。在 detached 生命周期後，將之前共享的數據設置為 null，以確保數據得到回收。"},{"t":"h","c":"注意事項"},{"t":"p","c":"由於數據是共享的，務必要確保在適當的時候回收數據，以避免內存泄漏。"},0],"about-micro-frontend":[{"t":"h","c":"關於微前端"},{"t":"p","c":"微前端是一種前端架構模式，旨在幫助團隊更好地構建和維護大型、復雜的前端應用程序。它借鑒了微服務架構的思想，將前端應用程序拆分為更小的獨立部分，每個部分都可以由不同的團隊開發、測試和部署。"},{"t":"p","c":"在傳統的單體前端應用不斷擴展的過程中，可能會變得難以維護和擴展。微前端的目標是通過將應用拆分成更小、更可管理的模塊，使得開發團隊能夠獨立地開發和部署這些模塊，從而提高團隊的效率和應用的可維護性。"},{"t":"p","c":"ofa.js 天生具備微前端的特性，它與其它框架的不同之處在於，基於 ofa.js 開發的組件、頁面和應用無需預編譯。相比於一些框架如 React、Vue 和 Angular 等，它們需要在 Node.js 環境下進行一次構建，生成用於客戶端的代碼。然而，ofa.js 的開發代碼可以直接放置在靜態服務器上，無需額外的構建步驟，就能實時查看、使用和運行。"},{"t":"p","c":"ofa.js 符合了微前端的特點："},{"t":"l","c":"1. 獨立部署：每個組件和頁面都可以獨立地開發、測試和部署，這使得團隊能夠更迅速地發布新功能和解決問題。\n\n2. 集成：基於 ofa.js 開發的應用，可以將不同的模塊組合在一起。這可以通過應用、頁面、組件等方式共享組合。\n\n3. 獨立團隊：每個前端模塊（組件/頁面/應用）可以由獨立的團隊進行開發和維護，從而鼓勵團隊的自主性和創新。\n\n4. 共享資源：在 ofa.js 項目中，通常會存在一些共享的資源，如樣式、組件、頁面等，以確保一致性和效率。\n\n5. 按需加載：ofa.js 的應用可以根據需要加載模塊，從而提升應用的性能和加載速度。"},{"t":"p","c":"盡管 ofa.js 無法直接使用 Vue 和 React 等框架開發的組件，但基於 ofa.js 開發的組件可以被 Vue 和 React 使用，這為不同技術棧的開發人員提供了更強的靈活性和擴展性。"},{"t":"p","c":"在 Vue 中使用 Web Components："},{"t":"l","c":"- Vue Web Component Wrapper\n- 將 Vue 與 Web Components 集成\n- 如何在 Vue 中使用 Web Components"},{"t":"p","c":"在 React 中使用 Web Components："},{"t":"l","c":"- 與 React 一起使用 Web Components\n- 在 React 中使用 Web Components\n- 將 Web Components 集成到 React 中"}]},"cases":{"index":[0,{"t":"h","c":"快速開始"},{"t":"p","c":"要開始使用，只需通過引入 CDN 地址將項目 ofajs 集成到你的項目中："},0,{"t":"p","c":"這是一個簡單的示例，演示了如何使用 ofa.js 修改 DOM 元素的內容："},{"t":"h","c":"使用方法"},{"t":"p","c":"引入了 ofa.js 後，全局作用域中將注冊 $ 符號。通過 $('xxx') 來選擇符合條件的第一個元素，其中 xxx 是標準的 CSS 選擇器 內容。"},{"t":"p","c":"在上述示例中，我們使用了 $ 符號來選擇三個具有不同 id 的元素，並通過設置 text 、 html 和 value 屬性來修改其內容。"},{"t":"p","c":"要了解更多可用的屬性和方法，請查閱 API 文檔。"}],"event":[0,{"t":"h","c":"事件響應"},{"t":"p","c":"您可以使用 on 方法來綁定事件。事件 是開發中最基礎的概念，應用通過事件的觸發才能產生反饋，從而實現互動性。"},{"t":"p","c":"以下示例演示了如何綁定點擊事件："},{"t":"p","c":"在這個示例中，我們通過使用 $ 選擇了 button 元素，並使用 on 方法綁定了 click 事件。當按鈕被點擊時，會觸發回調函數，將 target 元素的文本內容更改為 \"你好，世界！\"。"},{"t":"p","c":"如果您想了解更多可用的事件類型，請參考 Events 文檔。"}],"simple-component":[0,{"t":"h","c":"組件的創建和使用"},{"t":"p","c":"一旦完成對 ofa.js 的加載，全局會注冊一個名為 load-module 的組件，你可以使用縮寫 l-m 來引用它。其使用方式類似於 script 標簽，通過 src 屬性來引用你開發好的組件地址。"},{"t":"p","c":"現在，讓我們開始制作自己的組件。首先，創建一個 HTML 文件，文件名需要與組件名保持一致。"},{"t":"p","c":"在組件文件中，首先添加一個 template 元素，並添加 component屬性。將組件需要渲染的內容放置在這個 template 元素內。最終，這些內容將被渲染到組件的 Shadow DOM 內，Shadow DOM 與外部環境隔離，以防止汙染外部環境。"},{"t":"p","c":"接下來，只需使用 l-m 組件來引用你開發好的組件。在頁面上，直接使用你定義的組件標簽即可。"},{"t":"p","c":"需要注意的是，注冊的組件名只能使用小寫英文字母和 - 符號，並且必須包含至少一個 -。這個命名規則需要遵循。"},{"t":"p","c":"通過本示例，你可以了解如何創建一個名為 my-comp 的組件，並在另一個頁面中使用它。同時可以通過鏈接外部的 CSS 文件來設置組件的樣式。"}],"slot":[0,{"t":"h","c":"組件插槽"},{"t":"p","c":"通過在模板中添加 <slot></slot> 標簽，可以在使用組件時，將內容放置在對應組件標簽內的插槽中。"},{"t":"p","c":"自定義的組件在默認情況下沒有定義 display 屬性，因此需要手動為組件定義。在組件的樣式中，可以使用 :host 選擇器來添加組件自身的樣式。"},{"t":"p","c":"這個示例展示了如何創建一個名為 simple-btn 的組件。組件的模板中包含一個插槽，可以將內容插入到組件中。通過為組件的樣式添加 :host 選擇器，為組件添加樣式。在另一個頁面中，使用 l-m 組件引用 simple-btn 組件，並在其中插入內容。"}],"render-text":[0,{"t":"h","c":"文本渲染"},{"t":"p","c":"在組件文件中，你可以添加一個 script 標簽來編寫組件的邏輯代碼。通過暴露的 default 對象，可以設置組件參數。"},{"t":"p","c":"其中，data 參數用於定義組件元素的默認數據。一旦實例化完成，你就可以使用模板語法。"},{"t":"p","c":"文本渲染采用雙大括號進行包裹，即 {{xxx}}，其中的 xxx 表示組件的屬性名；"},{"t":"p","c":"案例演示了如何渲染組件元素的 val 屬性："}],"attribute-transmission":[0,{"t":"h","c":"特性傳遞"},{"t":"p","c":"attrs 參數和 data 參數在功能上類似，設置在 attrs 中的數據會合並到 data 中，但是 attrs 上的數據會體現在組件自身的特性上。"},0,{"t":"p","c":"在外部使用組件時，也可以通過特性將數據傳遞到組件內部。需要注意的是，通過特性傳遞的數據只能是字符串類型。"}],"get-set-comp":[0,{"t":"h","c":"獲取和修改組件實例的值"},{"t":"p","c":"從外部也可以獲取或修改組件的數據。"},{"t":"p","c":"示例展示了如何在外部操作組件的數據；"}],"property-transmission":[0,{"t":"h","c":"屬性傳遞"},{"t":"p","c":"通過使用屬性傳遞的模板語法，您可以將組件的數據應用於模板內的元素屬性。"},{"t":"p","c":"使用方法是在元素上添加特性 :name=\"key\"，其中 name 為目標元素要設置的屬性名，key 則為您自定義組件中要傳遞的屬性鍵名。"},{"t":"p","c":"之前在提到了<a href='./index.html' olink>使用選擇器的方式來設置屬性</a>，而這裏介紹的是屬性傳遞語法設置屬性；"}],"bind-event":[0,{"t":"h","c":"事件綁定"},{"t":"p","c":"在組件內部，您可以通過 on 屬性來綁定事件，讓組件具備交互能力。這裏演示了如何在組件中綁定事件以實現交互效果。"},{"t":"p","c":"proto 參數用於定義組件自身的方法，這些方法可以在組件內部使用，也可以在外部通過選擇器獲取組件後運行。"},{"t":"p","c":"on:click=\"xxx\" 後面的 xxx 可以是組件內部定義的方法名，也可以是函數表達式。如果使用函數表達式，無需顯式寫出 this 關鍵字，變量的作用域會自動綁定到組件自身；"},{"t":"p","c":"如果您想了解更多可用的事件類型，請參考 Events 文檔。"}],"nested-component":[0,{"t":"h","c":"嵌套組件"},{"t":"p","c":"全部過多的邏輯放到一個組件上，不是一個明智的選擇；我們可以將邏輯分到另外的組件，在通過 l-m 方式導入另一個組件來使用；"},{"t":"p","c":"案例中通過 <l-m src=\"./comp-two.html\"></l-m> 引入了名為 CompTwo 的嵌套組件。"},{"t":"p","c":"通過 <comp-two :txt=\"val\"></comp-two> 使用了嵌套組件，並將當前組件的 val 屬性作為 txt 屬性傳遞給嵌套組件。這樣，嵌套組件可以使用傳遞過來的數據進行渲染。"},{"t":"p","c":"在 <comp-two></comp-two> 中，我們在不傳遞任何屬性的情況下使用了嵌套組件。這裏的使用方式取決於嵌套組件本身的邏輯和設計。"},{"t":"p","c":"只要一個組件加載成功，無論在何處，都可以使用相應名稱的組件。即使在多個地方多次使用 l-m 組件加載相同的組件，也不會導致組件被多次加載。這種機制保證了組件的重用和一致性。"}],"inject-host":[0,{"t":"h","c":"inject-host 組件"},{"t":"p","c":"鑒於 Web Components 的隔離性，很難直接修改組件插槽內元素的樣式。為了應對這個問題，ofa.js 提供了一個名為 inject-host 的組件；inject-host 組件會向宿主層注入樣式，從而更靈活地配置組件的外觀。"},{"t":"p","c":"需要注意的是，使用此組件可能會影響宿主層的樣式。因此，在侵入樣式時應保持命名的規範性，以避免影響宿主的樣式。"},{"t":"p","c":"示例中，我們定義了 comp-two 組件，內部使用了 inject-host 組件來注入樣式。這使得我們可以通過注入的樣式對 comp-two 組件內的元素進行樣式設置，而不會影響到其他組件。"},{"t":"p","c":"同時，以下內容也需要特別注意："},{"t":"l","c":"- 通過在 inject-host 內添加 <style> 標簽，我們可以定義組件內的特定樣式。這些樣式只會影響到當前組件的元素，而不會波及到其他組件。\n- 在注入樣式時，應當避免使用過於普通的選擇器，以免影響到其他組件的樣式。需要保持選擇器的唯一性和特定性。\n- inject-host 也可以注入外部的樣式表文件，通過 <link rel=\"stylesheet\" href=\"target/style.css\"> 的方式。"},{"t":"p","c":"在整個示例中，通過使用 comp-two 組件內的 inject-host，我們可以在不破壞其他組件樣式的情況下，靈活地設置並應用組件內部的樣式。"}],"event-passing":[0,{"t":"h","c":"事件傳遞"},{"t":"p","c":"除了監聽原生事件，on 還可以用於監聽自定義事件，這在組件間實現事件通信時非常重要。自定義事件通過 emit 方法來觸發。通過觸發自定義事件，可以將自定義數據傳遞給接收方。"},{"t":"p","c":"如果需要跨越組件的 Shadow DOM 邊界，以觸發事件，可以添加 composed 屬性。"},{"t":"p","c":"在下面的案例中，我們將學習如何使用 emit 方法在嵌套的組件之間進行事件傳遞。"}],"sync":[0,{"t":"h","c":"雙向數據綁定"},{"t":"p","c":"通過使用 sync 語法，您可以在用戶界面的交互元素（例如輸入框或自定義組件）與數據模型之間建立實時的雙向關聯。"},{"t":"p","c":"以下示例演示了如何在組件中使用 sync 屬性來實現輸入框與數據模型之間的雙向數據綁定："},{"t":"l","c":"- 在 data 參數中，我們定義了名為 testText 的數據，並為其設置初始值為 \"I am testText\"。\n- 使用 sync:value=\"testText\" 表示輸入框的值與 testText 數據之間建立了雙向數據綁定。因此，當用戶在輸入框中輸入內容時，testText 數據會實時更新，反之亦然。\n- 同樣，使用 sync:txt=\"testText\" 表示自定義組件的 txt 屬性與 testText 數據之間建立了雙向數據綁定。組件的 txt 屬性發生變化時，testText 數據會實時更新，反之亦然。"},{"t":"p","c":"通過雙向數據綁定，您可以輕松地在用戶界面和數據模型之間建立聯系，使得數據的變化能夠自動反映在界面上，同時用戶在界面上的輸入也能立即影響到數據模型。"},{"t":"p","c":"值得注意的是，數據同步只能傳遞 字符串 或 數字，無法傳遞其他數據類型。"}],"condition":[0,{"t":"h","c":"條件渲染"},{"t":"p","c":"模板內除了有模板語法，也有模板組件；"},0,{"t":"p","c":"條件渲染允許您在特定條件下，動態地在組件中插入不同的內容。以下是一個演示如何在組件內使用條件渲染的示例。"},{"t":"p","c":"在這個示例中，我們創建了一個名為 test-demo 的組件。組件內包含一個按鈕，點擊按鈕會使 count 屬性自增。通過 <x-if>、<x-else-if> 和 <x-else> 標簽，我們實現了條件渲染的邏輯。"},{"t":"l","c":"- <x-if> 標簽接受一個 value 屬性，用於定義條件。如果 value 的值為 true，則渲染 <x-if> 內部的內容。在這個示例中，如果 count 為偶數，將顯示紅色文本。\n- <x-else-if> 標簽也接受一個 value 屬性，用於定義條件。如果前面的條件不滿足且 value 的值為 true，則渲染 <x-else-if> 內部的內容。在這個示例中，如果 count 為 3 的倍數，將顯示藍色文本。\n- <x-else> 標簽不需要 value 屬性，它會在前面的條件都不滿足時渲染其內部的內容。在這個示例中，如果 count 既不是偶數也不是 3 的倍數，將顯示綠色文本。使用 x-else 時也可以緊跟在 x-if 後面；"},{"t":"p","c":"通過這種方式，您可以根據不同的條件動態地渲染不同的內容，實現靈活的交互和展示效果。"}],"fill":[0,{"t":"h","c":"填充渲染"},{"t":"p","c":"填充渲染（x-fill）模板在前端框架中類似於列表渲染的概念，它允許您根據數據集合動態地渲染一組微型組件。"},{"t":"p","c":"在填充渲染過程中，您可以使用以下特殊變量："},{"t":"l","c":"- $data：代表填充項的數據。通過操作 $data，您可以獲取或修改每個填充項的數據。\n- $index：代表當前數據項在數據集合中的索引。\n- $host：代表當前組件自身。如果您想要獲取組件的數據或調用組件的方法，需要使用 $host 來訪問組件。"}],"fill-temp":[0,{"t":"h","c":"遞歸填充渲染"},{"t":"p","c":"填充渲染允許您使用獨立的模板來渲染數據，並通過 <template> 元素添加 name 屬性進行命名。這種方式使得您可以實現嵌套結構的數據渲染，從而創建更復雜的組件。"},{"t":"p","c":"在使用 x-fill 進行填充渲染時，只需將對應的模板名稱傳遞給 name 屬性，即可渲染獨立模板的內容。此外，填充渲染還支持遞歸填充，即在模板內部可以繼續使用相同的模板名稱，實現嵌套填充。"},{"t":"p","c":"在示例中，我們定義了一個名為 item 的獨立模板，並在 x-fill 使用時傳遞了相應的模板名稱。這樣，數據中的每個項都將使用這個模板進行渲染，而且模板內部可以再次使用相同的模板名稱進行遞歸填充。這種方式使得您可以靈活地處理具有嵌套結構的數據，實現更加復雜的組件渲染。"}],"life-cycle":[0,{"t":"h","c":"生命周期"},{"t":"p","c":"生命周期鉤子函數提供了在組件不同階段執行代碼的機會。在 ofa.js 中，有五個主要的生命周期鉤子函數，它們分別是：created、ready、watch、attached 和 detached。"},{"t":"l","c":"- created(): 在組件被創建時調用，此時 shadow root 尚未開始渲染。可以在這裏執行一些初始化設置，但不能訪問 shadow root 中的元素。\n  \n- ready(): 在 shadow root 渲染完成後調用，一般用於組件的初始化邏輯。在這個階段，您可以訪問並操作 shadow root 內的元素，以及執行其他需要在渲染完成後執行的操作。\n\n- watch: 通過定義 watch 對象來監聽數據的變化。在 ready 完成後，會觸發一次 watch，對應著 data 上的值。之後，每次對應的鍵的值發生變動後，都會觸發 watch 內對應的函數。\n\n- attached(): 當組件被添加到 document 中時調用，此時可以進行與外部環境交互的操作，如獲取組件外觀或初始化共享數據的邏輯。\n\n- detached(): 當組件從 document 中移除時調用。在這個階段，您可以執行清理工作，取消與外部環境的交互，並釋放資源。"}],"form-data":[0,{"t":"h","c":"表單數據"},{"t":"p","c":"在許多應用中，處理表單數據是一項常見的任務。為了簡化這個過程，ofa.js 對表單數據的處理進行了二次抽象，提供了 formData 方法。通過這個方法，您可以輕松地將表單元素的值映射到一個對象上，並且在表單元素的值發生變化時，自動更新這個對象的數據，反之亦然。"},{"t":"p","c":"通過使用 shadow 屬性，您可以獲取到組件的 Shadow DOM 根節點的內容。這可以讓您在組件內部訪問和操作 Shadow DOM 中的元素和樣式。"},{"t":"p","c":"在這個示例中，我們可以看到如何利用 formData 方法將表單數據自動映射到對象 fdata 上。這使得您可以通過操作 fdata 對象來獲取或修改表單元素的值，而這些變動也會自動同步到對應的表單元素上。"}],"custom-form-element":[0,{"t":"h","c":"自定義表單組件"},{"t":"p","c":"使用 ofa.js，您可以輕松地開發自定義的表單元素組件，使其具有標準的表單特性。只需要為自定義組件添加 value 屬性並設置 name 特性，您的自制組件就能夠作為標準表單元素來使用。通過更新組件的 value 屬性，您就能實現與表單元素的交互。"},{"t":"p","c":"初始化 formData 時，需要將自定義組件的選擇器特征添加到參數中（盡管 formData 方法默認的參數為 \"input,select,textarea\"）。這樣，formData 就能夠與自定義組件進行聯動。"},{"t":"p","c":"在這個示例中，我們通過自定義組件 custom-input 來實現一個可編輯的文本輸入框。該組件被用作表單元素，並使用 value 屬性進行數據交互。使用 formData 方法時，我們將 \"input,custom-input\" 添加為參數，以便正確地初始化表單數據。"}],"use-page":[0,{"t":"h","c":"使用頁面組件"},{"t":"p","c":"一旦加載了 ofa.js，全局會自動添加一個名為 o-page 的頁面組件。這個組件用於加載頁面模塊，頁面模塊是一種特殊的組件模塊，不會注冊為自定義標簽，而是通過 o-page 組件來加載。"},{"t":"p","c":"頁面模塊類似於組件模塊，但是有一些不同之處。頁面模塊使用 page 屬性來定義模板，而不是 component 屬性。頁面模塊的開發邏輯和組件模塊一樣，使用相同的模板語法和模板組件等。然而，頁面模塊不能使用 attrs 特性，因為頁面的參數通常通過 URL 傳遞，而不是通過 data 或 attrs。"},{"t":"p","c":"在示例中，o-page 組件用於加載 page.html 頁面模塊。頁面模塊中使用 page 屬性定義模板，然後通過 JavaScript 函數返回一個對象來設置數據。URL 中的查詢參數 count 會被傳遞到頁面模塊中，並被用於初始化數據。頁面內的按鈕點擊事件可以更新數據並在頁面中呈現。"}],"use-app":[0,{"t":"h","c":"使用 app 組件"},{"t":"p","c":"在 ofa.js 中，您可以使用 o-app 組件來創建整個應用的布局結構，並在其中加載不同的頁面模塊。通過使用 o-app 組件、o-page 組件和頁面模塊，您可以構建整個應用的頁面結構，並實現頁面之間的導航"},{"t":"p","c":"當 o-page 組件位於 o-app 內部時，您可以使用帶有 olink 屬性的 <a> 標簽來實現頁面跳轉。這種跳轉不會影響當前頁面，而是只會在 o-app 內部進行跳轉，類似於使用 <iframe>。"},{"t":"p","c":"如果 o-page 組件在 o-app 內部，您還可以使用以下方法："},{"t":"l","c":"- goto 方法來進行頁面跳轉\n- back 方法返回上一頁\n- replace 方法進行當前頁面的替換式跳轉"},{"t":"p","c":"通過使用 o-app 組件，您可以構建整個應用的布局結構，並在其中加載不同的頁面模塊。同時，o-app 提供的路由功能使得頁面之間的跳轉變得更加方便和靈活。"},{"t":"p","c":"在這個示例中，我們通過 o-app 組件創建了一個應用布局，然後在其中加載了一個頁面模塊 page1.html。"},{"t":"p","c":"在 page1.html 頁面模塊中，我們定義了一個標題和一個按鈕，點擊按鈕會跳轉到另一個頁面模塊 page2.html。我們還添加了一個帶有 olink 屬性的鏈接，點擊鏈接同樣會導航到 page2.html。"},{"t":"p","c":"在 page2.html 頁面模塊中，我們同樣定義了一個標題和一個按鈕，點擊按鈕會返回上一頁，實現頁面導航。"}],"app-config":[0,{"t":"h","c":"配置 app 參數"},{"t":"p","c":"您可以通過為 o-app 標簽單獨設置外部模塊來配置應用的參數。"},{"t":"p","c":"這些參數是一個 ES 模塊，您可以配置以下參數："},{"t":"l","c":"- home: 應用的首頁，即初始加載時顯示的頁面。\n- loading: 在應用頁面點擊跳轉時，在未完成模塊加載前，顯示的加載中內容。您可以通過返回一個字符串作為 loading 內容。\n- pageAnime: 頁面跳轉時的動畫效果，使用的是一個包含 CSS 樣式屬性的對象。\n  - current: 表示頁面處於當前頁時的樣式。\n  - next: 表示頁面在未進場時的樣式。\n  - previous: 表示頁面在要退出時的樣式。"},{"t":"p","c":"通過這種方式，您可以根據應用的需要，自定義首頁、加載中樣式和頁面跳轉動畫等參數，從而為應用帶來更加個性化的體驗。"}],"app-loading":[0,{"t":"h","c":"為 app 定制 loading"},{"t":"p","c":"以下是一個為 o-app 組件定制 loading 的示例。在這個示例中，我們為 loading 創建了一個漂亮的進度條，它會在頁面加載期間逐漸增長，加載完成後會直接到達 100%，然後將 loading 元素刪除。"},{"t":"p","c":"您可以將以下代碼復制並用於定制您的應用的 loading 效果："},0,{"t":"p","c":"通過這段代碼，您可以為您的應用添加一個獨特的加載效果，讓用戶在頁面切換過程中有更好的體驗。"}],"set404":[0,{"t":"h","c":"配置404頁面"},{"t":"p","c":"在應用的配置模塊中，通過設置 fail 函數，以自定義在頁面加載失敗時所展示的內容；"},{"t":"p","c":"在這個示例中，當頁面加載失敗時，將顯示加載錯誤信息的第一行內容；"},0],"use-hash-router":[0,{"t":"h","c":"使用 hash router"},{"t":"p","c":"只需使用 o-router 組件，即可將 app 組件內的路由與當前網頁關聯起來。一旦頁面與路由綁定，即使進行頁面刷新，也能保持頁面的路由狀態。"},{"t":"p","c":"在這個示例中，請點擊  <span style='font-family: \"iconfont\"'>&#xe7cb;</span>  按鈕，以新頁面的方式打開並嘗試。"},0],"use-scsr":[0,{"t":"h","c":"使用 SCSR 方案"},{"t":"p","c":"在這個示例中，請點擊 <span style='font-family: \"iconfont\"'>&#xe7cb;</span> 按鈕，以新頁面的方式打開並嘗試；"},{"t":"p","c":"SCSR 的全稱是 Static Client-Side Rendering，又稱為靜態客戶端渲染。它是 CSR（Client-Side Rendering）的一種變種，在保留了 CSR 用戶體驗的基礎上，還能夠讓頁面在靜態狀態下被搜索引擎爬取。"},{"t":"p","c":"當前網站采用的正是 SCSR 方案構建；"},{"t":"p","c":"SCSR 通過直接運行單文件模式的頁面模塊，無需使用 o-page 標簽，實現在頁面上進行渲染。具體而言，就是將頁面模塊的模板代碼直接嵌套在 o-app 內。"},{"t":"h","c":"注意事項"},{"t":"p","c":"對於所有采用 SCSR 方案的頁面，除了頁面描述性的內容（如 title、meta:description、keywords）和頁面模板內容外，其他引用的資源必須保持一致，以確保在頁面跳轉和刷新後的用戶體驗一致。"}]},"docs":{"introduce":[{"t":"h","c":"ofa.js - 漸進式前端框架"},{"t":"h","c":"什麽是 ofa.js"},{"t":"p","c":"ofa.js是一個漸進式前端框架，旨在讓開發者以最低成本進入前端開發和使用流程。它提供了一系列簡單而強大的工具和API，讓前端開發變得更加高效和便捷。"},{"t":"h","c":"存在目的"},{"t":"h","c":"取代 jQuery"},{"t":"p","c":"在許多小型項目中，我們可能並不需要引入像React和Vue這樣的大型框架，而是傾向於使用jQuery進行簡單的前端操作。ofa.js改進了jQuery的API，並將jQuery的許多方法替代為屬性，使得使用ofa.js在很多場景下更為合適。"},{"t":"h","c":"簡化前端開發和使用流程"},{"t":"p","c":"ofa.js的目標是簡化繁瑣的前端開發流程。它允許開發者無需學習復雜的Node.js、npm和腳手架等工具，從而更快地搭建前端應用。使用它，你可以回歸到只需引入一個庫即可進行開發的體驗。"},{"t":"h","c":"成為銀彈型前端開發框架"},{"t":"p","c":"ofa.js旨在成為一種\"銀彈\"，即能夠解決多種前端開發問題，並提供全面的解決方案。它不僅僅是一個工具庫，更是一種全面的前端開發框架。"},{"t":"h","c":"特點"},{"t":"h","c":"易上手的組件開發"},{"t":"p","c":"使用ofa.js開發的組件幾乎沒有學習成本。ofa.js提供了簡潔而直觀的API，讓開發者可以快速創建和集成組件，同時保持代碼的整潔和易於維護。"},{"t":"h","c":"內置模塊化、狀態更新和應用集成方案"},{"t":"p","c":"ofa.js內部已經集成了模塊化、狀態更新和應用集成等解決方案，使得開發者無需額外尋找第三方庫或工具，就可以完成復雜的前端開發任務。"},{"t":"h","c":"官方提供路由和 SSG（靜態站點生成）方案"},{"t":"p","c":"ofa.js還為路由和SSG提供了官方解決方案，幫助開發者更好地管理前端路由和生成靜態站點，提高應用性能和SEO友好度。"},{"t":"h","c":"精簡的代碼體積"},{"t":"p","c":"ofa.js的代碼經過精心優化，壓縮後的.min文件大小只有38kb(gzip下只有14kb)。這使得ofa.js成為一個高效的前端框架，可以在各種網絡環境下快速加載和使用。"}],"get-started":{"index":[{"t":"h","c":"上手使用"},{"t":"h","c":"如何使用"},{"t":"h","c":"直接引用"},{"t":"p","c":"你可以通過 CDN 的地址直接將 ofa.js 引用到你的頁面上："},0,{"t":"h","c":"通過 npm 安裝"},{"t":"p","c":"首先，在你的項目中安裝 ofa.js："},0,{"t":"p","c":"然後在項目中引入 ofa.js 模塊："},0,{"t":"h","c":"使用"},{"t":"p","c":"在引用資源後，ofa.js 將在全局作用域上設置一個 $ 屬性，所有的功能都在 $ 上，後面的教程會詳細講解其用法；"},{"t":"p","c":"通常情況下，我們建議采用直接引用的方式添加 ofa.js，而使用 npm 的方式則用於與類似 React 和 Vue 等框架進行兼容。"}],"hello-world":[{"t":"h","c":"第一個案例"},{"t":"p","c":"以下是一個案例，點擊按鈕後將文本更改為 \"Hello World\"："},0,{"t":"p","c":"當點擊按鈕後，將會顯示加粗的 \"Hello World\" 文本。"},{"t":"p","c":"現在，讓我們詳細解釋一下基礎概念。"},{"t":"h","c":"選擇器"},{"t":"p","c":"引用了 ofa.js 後，$ 符號將被注冊到全局作用域中。通過 $('xxx') 來選擇符合條件的第一個 元素，其中 xxx 是標準的 CSS Selector  內容。你可以點擊鏈接查看具體的選擇器內容。"},{"t":"p","c":"以下是一個例子："},0,{"t":"p","c":"在上面的案例中，打開頁面一秒後，會分別改變 p標簽 、#desk 和 .logger  的文本內容。"},{"t":"h","c":"事件綁定"},{"t":"p","c":"選擇元素成功後，你可以為元素綁定事件。就像前面提到的 \"Hello World\" 案例中，我們給 id 為 \"btn\" 的元素綁定了點擊事件。當點擊按鈕後，綁定的函數會被執行。"},{"t":"p","c":"你可以點擊跳轉查看 事件示例  章節，了解一些事件綁定的案例；"},{"t":"p","c":"所有可用的事件，可以參考 Web Events 來了解完整的事件列表。"},{"t":"h","c":"屬性"},{"t":"p","c":"在上面的兩個案例中，我們分別展示了 html 和 text 屬性的使用。"},{"t":"p","c":"你還可以通過 html 或 text 屬性來獲取元素的內容，如下所示："},0,{"t":"p","c":"這個例子中，我們將 #t1 元素內的 HTML 內容賦值給了 #t2 和 #t3 元素。"}],"elements-and-events":[{"t":"h","c":"獲取元素和事件相關"},{"t":"p","c":"該章節旨在加強對上一章內容的理解，包括選擇元素 和 事件綁定。"},{"t":"h","c":"選擇元素"},{"t":"p","c":"在之前的章節中，我們已經了解了通過 $ 符號從全局獲取某個元素的方法。接下來，我們將介紹其他獲取元素的方法。"},{"t":"h","c":"從元素內查找某個元素"},{"t":"h","c":"使用 $(\"xxx\").$('xxxx') 的方式"},{"t":"p","c":"$(\"xxx\").$('xxxx') 是通過先選擇一個父元素，然後在其內部查找符合條件的子元素的方式。其中，$(\"xxx\") 選擇了一個父元素，然後使用 $('xxxx') 在該父元素內查找符合條件的子元素。"},{"t":"h","c":"示例"},0,{"t":"p","c":"在上面的示例中，首先通過 $(\".parent\") 選擇了具有 parent 類的父元素，然後使用 $(\".child\") 在該父元素內查找具有 child 類的子元素。然後修改了子元素的文本內容為 \"Modified child element\"。"},{"t":"h","c":"使用 $('xxx xxxx') 的方式"},{"t":"p","c":"$('xxx xxxx') 是通過在全局範圍內查找符合第二個選擇器條件的元素，然後在這些元素內部查找符合第一個選擇器條件的元素。這種方式可以直接一步到位地查找到符合條件的子元素。"},{"t":"h","c":"示例"},0,{"t":"p","c":"在上面的示例中，直接使用 $('div .child') 查找到具有 child 類的子元素，並修改了子元素的文本內容為 \"Modified child element\"。"},{"t":"h","c":"選擇多個元素"},{"t":"h","c":"使用 $.all('xxx') 查找全局的元素"},{"t":"p","c":"$.all('xxx') 方法用於查找頁面中所有符合選擇器條件的元素，並將它們作為一個元素集合返回。這樣可以選擇頁面中的多個元素進行批量操作。"},{"t":"h","c":"示例"},0,{"t":"p","c":"在上面的示例中，使用 $.all(\"p\") 查找到頁面中的所有 p 標簽元素，並對它們進行了批量操作，將文本內容修改為 \"Modified Paragraph 1\"、\"Modified Paragraph 2\" 和 \"Modified Paragraph 3\"。"},{"t":"h","c":"從元素內查找所有符合條件的元素"},{"t":"p","c":"除了可以在全局範圍內查找元素，還可以從某個元素內查找所有符合條件的子元素，使用方式為：$('xxx').all('xxxx')。"},{"t":"h","c":"示例"},0,{"t":"p","c":"在上面的示例中，首先使用 $(\".container\") 查找到具有 container 類的元素，然後通過 .all(\".item\") 在該容器內查找所有帶有 item 類的子元素，並對它們進行了批量操作，將文本內容修改為 \"Modified Item 1\"、\"Modified Item 2\" 和 \"Modified Item 3\"。"},{"t":"h","c":"事件"},{"t":"p","c":"前面已經講過 on 綁定事件的使用方法，後面介紹幾個和事件相關的方法；"},{"t":"h","c":"off 方法的使用文檔"},{"t":"p","c":"off 方法用於移除通過 on 方法綁定的事件處理函數。當不再需要某個事件的處理函數時，可以使用 off 方法將其從元素上移除，以避免重復執行或內存泄漏。"},{"t":"h","c":"語法"},0,{"t":"l","c":"- selector: 選擇要移除事件處理函數的元素。 \n- eventName: 要移除的事件名稱。 \n- eventHandler: 要移除的事件處理函數。"},{"t":"h","c":"示例"},0,{"t":"p","c":"在上面的示例中，當點擊按鈕時，會彈出一個對話框顯示 \"Button clicked!\"。但是在5秒後，通過 off 方法移除了點擊事件處理函數，所以按鈕再次點擊時不會觸發彈出對話框。"},{"t":"h","c":"one 方法的使用文檔"},{"t":"p","c":"one 方法用於綁定事件處理函數，但該處理函數只會在第一次觸發事件時執行一次。在執行一次後，事件處理函數會被自動移除，避免重復觸發。"},{"t":"h","c":"語法"},0,{"t":"l","c":"- selector: 選擇要綁定事件處理函數的元素。 \n- eventName: 要綁定的事件名稱。 \n- eventHandler: 要執行的事件處理函數。"},{"t":"h","c":"示例"},0,{"t":"p","c":"在上面的示例中，當點擊按鈕時，會彈出一個對話框顯示 \"Button clicked once!\"。但是在第一次點擊後，事件處理函數就會被移除，所以後續點擊按鈕不會再觸發彈出對話框。"},{"t":"h","c":"emit 方法的使用文檔"},{"t":"p","c":"emit 方法用於手動觸發元素上綁定的特定事件。通過 emit 方法可以在不進行實際操作的情況下觸發事件處理函數的執行。"},{"t":"h","c":"語法"},0,{"t":"l","c":"- selector: 選擇要觸發事件的元素。 \n- eventName: 要觸發的事件名稱。"},{"t":"h","c":"示例"},0,{"t":"p","c":"在上面的示例中，通過 emit 方法手動觸發了按鈕的點擊事件，結果會彈出一個對話框顯示 \"Button clicked!\"，盡管沒有實際點擊按鈕。"},{"t":"p","c":"注意：使用 emit 方法不會模擬鼠標點擊或其他實際事件，它只會直接調用已綁定的事件處理函數。所以，如果你希望在特定情況下觸發事件的執行，可以使用 emit 方法。"},{"t":"p","c":"當你綁定事件後，有時你可能希望阻止事件的進一步傳播（冒泡）或取消事件的默認行為。下面將介紹如何在事件觸發後禁止冒泡和取消默認事件。"},{"t":"h","c":"禁止事件冒泡"},{"t":"p","c":"事件冒泡是指當一個元素上的事件被觸發時，它會沿著 DOM 樹向上冒泡，依次觸發父元素上的同類型事件。如果你希望在特定元素上處理事件後阻止其繼續冒泡，可以使用 event.stopPropagation() 方法。"},{"t":"p","c":"示例代碼："},0,{"t":"p","c":"在上面的示例中，當你點擊按鈕 \"Click Me\" 後，它會顯示 \"Button Clicked!\"，但不會觸發 \"Inner Div Clicked!\" 和 \"Outer Div Clicked!\"。這是因為我們在按鈕的點擊事件處理程序中調用了 event.stopPropagation()，阻止了事件的進一步傳播。"},{"t":"h","c":"取消事件的默認行為"},{"t":"p","c":"有些元素上的事件在觸發時會有默認的行為。例如，點擊提交按鈕會導致表單提交，點擊鏈接會跳轉到鏈接的地址等。如果你希望阻止事件的默認行為，可以使用 event.preventDefault() 方法。"},{"t":"p","c":"示例代碼："},0,{"t":"p","c":"在上面的示例中，當你點擊提交按鈕 \"Submit\" 後，它會顯示 \"Hello, {name}! Form submission prevented.\"，但不會觸發 \"Form Submitted!\" 的警報。這是因為我們在提交按鈕的點擊事件處理程序中調用了 event.preventDefault()，阻止了表單的提交默認行為。"}],"basic-concept":[{"t":"h","c":"實例的基礎概念"},{"t":"p","c":"$ 實例是對頁面上元素的封裝，除了用於選擇現有的元素外，它還可以直接創建新元素並進行操作。在本章中，我們將介紹如何創建新元素以及對 $ 實例的一些操作。"},{"t":"h","c":"創建新元素"},{"t":"p","c":"通過 $ 實例，我們可以直接創建新的元素並進行操作，例如："},0,{"t":"p","c":"在上面的例子中，我們通過 $('<div style=\"color:red\">I am text</div>') 創建了一個新的 div 元素，並將其添加到了 body 中。"},{"t":"h","c":"獲取子元素"},{"t":"p","c":"通過 $ 獲取的實例，並不像 DOM 元素那樣擁有 children 屬性。但是我們可以通過數組索引來訪問實例的直接子元素："},0,{"t":"p","c":"在上面的例子中，我們獲取了 div 元素，並通過索引來訪問第一個和第二個 p 元素。同時，我們還使用了 $div.length 獲取了子元素的數量。"},{"t":"h","c":"操作子元素"},{"t":"p","c":"通過 $ 實例，我們還可以直接使用數組的方法來操作子元素，例如 push 和 pop："},0,{"t":"p","c":"在上面的例子中，我們獲取了所有 p 元素的 $ 實例，並使用 push 方法添加了一個新的 div 元素作為子元素，然後使用 pop 方法移除了最後一個子元素。"},{"t":"p","c":"通過上述示例，你可以了解 $ 實例的一些基本操作，包括創建新元素和對子元素的訪問與操作。 $ 實例提供了簡便的方法來操作頁面上的元素。"}],"common-properties":[{"t":"h","c":"常用屬性"},{"t":"p","c":"在 $ 實例中，除了可以通過選擇器選擇元素外，還提供了一些常用的屬性來方便元素的操作和查找。"},{"t":"h","c":"tag 屬性"},{"t":"p","c":"tag 屬性用於獲取當前元素的標簽名（小寫形式），類似於 DOM 元素的 tagName 屬性。"},0,{"t":"h","c":"ele 屬性"},{"t":"p","c":"ele 屬性用於獲取 $ 實例的實際 DOM 元素，從而可以對該元素進行原生的 JavaScript 操作。"},0,{"t":"h","c":"index 屬性"},{"t":"p","c":"index 屬性用於獲取當前元素在同級元素中的排名索引，從 0 開始計數。"},0,{"t":"h","c":"parent 和 parents 屬性"},{"t":"l","c":"- parent 屬性用於獲取當前元素的直接父元素。 \n- parents 屬性用於獲取當前元素的所有祖先元素（包括父元素的父元素、父元素的父元素的父元素等）構成的數組。"},0,{"t":"h","c":"next、nexts、prev、prevs、siblings 屬性"},{"t":"l","c":"- next 屬性用於獲取當前元素的下一個兄弟元素。 \n- nexts 屬性用於獲取當前元素後面的所有兄弟元素構成的數組。 \n- prev 屬性用於獲取當前元素的前一個兄弟元素。 \n- prevs 屬性用於獲取當前元素前面的所有兄弟元素構成的數組。 \n- siblings 屬性用於獲取當前元素的所有兄弟元素，不包括自己。"},0],"common-function":[{"t":"h","c":"常用方法"},{"t":"h","c":"attr"},{"t":"p","c":"attr 方法允許您獲取或設置元素的屬性。"},0,{"t":"p","c":"在上面的示例中，我們首先選擇了一個具有 id 為 \"example\" 的 div 元素。然後，我們使用 attr 方法來獲取該元素的 name 屬性，並將其打印到控制台。接下來，我們使用 attr 方法來設置該元素的 title 屬性為 \"change title\"。"}],"css":[{"t":"h","c":"CSS 的用法"},{"t":"p","c":"在 ofa.js 中，你可以通過以下方式來操作元素的 CSS 樣式；"},{"t":"h","c":"獲取元素的具體 CSS 樣式"},{"t":"p","c":"可以使用 $ele.css.xxx 來獲取元素的具體 CSS 樣式，其中 xxx 是你想要獲取的 CSS 屬性名。"},{"t":"h","c":"示例"},0,{"t":"h","c":"設置某個樣式屬性"},{"t":"p","c":"可以使用 $ele.css.xxx = '' 的方式來設置元素的 CSS 樣式，其中 xxx 是你想要設置的 CSS 屬性名。通過將屬性值設為空字符串，可以將指定的樣式屬性移除。"},{"t":"h","c":"示例"},0,{"t":"h","c":"賦值對象"},{"t":"p","c":"可以使用 $ele.css = {xxx} 的方式來設置元素的 style，其中 xxx 是一個包含 CSS 屬性名和屬性值的對象。"},{"t":"h","c":"示例"},0,{"t":"h","c":"賦值字符串"},{"t":"p","c":"可以使用 $ele.css = 'color:red;...' 的方式來設置元素的 style，其中 'color:red;...' 是一個包含 CSS 樣式規則的字符串。"},{"t":"h","c":"示例"},0,{"t":"h","c":"設置 css 的技巧"},{"t":"p","c":"你可以通過 $ele.css = {...$ele.css, color:'red'} 的方式來修改元素的某個樣式屬性，而不影響其他樣式屬性。這種方式可以在不重寫整個樣式的情況下，只修改其中一個屬性。"},{"t":"h","c":"示例"},0,{"t":"p","c":"在上面的示例中，通過使用 { ...myElement.css, color: 'red' }，我們只修改了元素的顏色樣式，而將其他樣式屬性保持不變。這是一個很方便的技巧，可以靈活地修改元素的樣式。"}],"classlist-and-data":[{"t":"h","c":"classList 和 data"},{"t":"h","c":"classList"},{"t":"p","c":"在 ofa.js 中，你可以通過以下方式來操作元素的 classList： "},{"t":"l","c":"- $ele.classList: 返回元素的 classList 對象，用於操作元素的類名。"},{"t":"h","c":"classList 增刪用法"},{"t":"l","c":"- 添加類名：$ele.classList.add('className')，將指定的類名添加到元素的 classList 中。 \n- 移除類名：$ele.classList.remove('className')，從元素的 classList 中移除指定的類名。 \n- 切換類名：$ele.classList.toggle('className')，如果元素的 classList 中已經存在該類名，則移除它；否則添加該類名。"},{"t":"h","c":"示例"},0,{"t":"p","c":"在這個示例中，有一個帶有初始類名 box 的 <div> 元素，以及三個按鈕：Add Highlight、Remove Highlight 和 Toggle Highlight。 "},{"t":"l","c":"- 當點擊 \"Add Highlight\" 按鈕時，通過 classList.add() 方法將 highlight 類名添加到 <div> 元素中，使其具有黃色背景色。 \n- 當點擊 \"Remove Highlight\" 按鈕時，通過 classList.remove() 方法從 <div> 元素的類名中移除 highlight 類名，恢復原始樣式。 \n- 當點擊 \"Toggle Highlight\" 按鈕時，通過 classList.toggle() 方法切換 <div> 元素的 highlight 類名。如果原本有該類名，則移除它，如果原本沒有該類名，則添加它，實現樣式的切換。"},{"t":"p","c":"這樣，你就可以通過 classList 對象來管理元素的類名，從而實現對元素樣式的動態控制。"},{"t":"h","c":"data 的用法"},{"t":"p","c":"在 ofa.js 中，你可以通過以下方式來操作元素的 data 屬性： "},{"t":"l","c":"- $ele.data: 返回元素的 dataset 對象，用於操作元素的 data 屬性。"},{"t":"h","c":"dataset 的具體用法"},{"t":"p","c":"元素的 data-* 屬性可以用於在 HTML 中存儲自定義數據，可以通過 data 對象來訪問這些屬性。"},{"t":"p","c":"例如，如果有一個元素定義了 data-info 屬性："},0,{"t":"p","c":"你可以使用 dataset 來訪問該屬性："},0,{"t":"p","c":"注意：dataset 對象中的屬性名會將 \"data-\" 後面的部分轉換為駝峰式命名。例如，data-info 變成了 dataset.info。如果要設置 data-* 屬性，也可以通過 dataset 對象來實現："},0,{"t":"p","c":"這樣就會在元素上添加一個 data-another-info 屬性，並設置其值為 \"another value\"。"}],"box-model":[{"t":"h","c":"盒模型"},{"t":"p","c":"在前端開發中，經常會用到一些表示元素尺寸的屬性。這些屬性包括 width、height、clientWidth、clientHeight、offsetWidth、offsetHeight、outerWidth 和 outerHeight。了解它們的含義和用法對於開發響應式和動態布局非常重要。下面讓我們一一解釋它們，並通過一個示例來演示。"},{"t":"l","c":"- width：表示元素的內容區域的寬度，不包括內邊距、邊框和外邊距。\n- height：表示元素的內容區域的高度，不包括內邊距、邊框和外邊距。\n- clientWidth：表示元素的可見內容區域的寬度，包括內邊距，但不包括邊框和外邊距。\n- clientHeight：表示元素的可見內容區域的高度，包括內邊距，但不包括邊框和外邊距。\n- offsetWidth：表示元素的整體寬度，包括內容區域、內邊距、邊框和外邊距。\n- offsetHeight：表示元素的整體高度，包括內容區域、內邊距、邊框和外邊距。\n- outerWidth：表示元素的整體寬度，包括內容區域、內邊距、邊框、外邊距，但不包括滾動條的寬度。\n- outerHeight：表示元素的整體高度，包括內容區域、內邊距、邊框、外邊距，但不包括滾動條的高度。"},0],"formdata":[{"t":"h","c":"表單功能"},{"t":"p","c":"$ 實例提供了一些便捷的表單功能，使得處理表單元素更加簡單和高效。"},{"t":"h","c":"通過 formData 生成對象"},{"t":"p","c":"formData 方法用於生成包含目標元素內所有表單元素值的對象。該對象會實時反映表單元素的改動。"},0,{"t":"h","c":"監聽特定表單元素"},{"t":"p","c":"默認情況下，formData() 監聽目標元素內的所有 input、select 和 textarea 元素。你可以通過傳遞選擇器來監聽特定的表單元素。"},0,{"t":"h","c":"Stanz 對象"},{"t":"p","c":"formData() 方法返回的對象被稱為 Stanz 對象。Stanz 是 $ 擴展庫的一部分，提供了對表單數據的高效處理和監聽功能。"},{"t":"p","c":"你可以通過訪問 https://github.com/kirakiray/stanz 來詳細了解 Stanz 的使用教程和功能。"},{"t":"p","c":"通過以上的表單功能，你可以輕松地處理表單元素的值和變化，從而提高表單操作的便捷性和效率。"}]},"create-component":{"index":[{"t":"h","c":"制作和使用組件"},{"t":"p","c":"ofa.js 使用基礎的 HTML 和 JavaScript 文件來定義組件，避免引入新的文件類型以減少學習成本。只要你對 HTML 有一定的了解，就能夠快速開發和使用 ofa.js 組件。"},{"t":"h","c":"準備創建組件前的步驟"},{"t":"p","c":"在開始創建組件之前，需要注意一些準備工作。由於創建組件涉及到瀏覽器請求資源的操作，如果你僅僅是雙擊打開 HTML 文件來查看，會在 \"file\" 協議下進行查看。在 \"file\" 協議下，JavaScript 模塊的加載可能會報錯。因此，你需要準備一個靜態服務器來正確查看組件。"},{"t":"p","c":"如果你使用的是 Visual Studio Code 編輯器，你可以簡單地安裝一個支持靜態服務器的插件。我們推薦使用 Live Server 插件。"},{"t":"p","c":"安裝插件後，只需在 demo.html 文件上右鍵點擊，選擇 \"Open with Live Server\"，插件將會自動以靜態服務器模式打開文件。"},{"t":"p","c":"如果你使用的是其他編輯器，你也可以創建一個 Nginx 或 Apache 服務器，只要能夠支持靜態 HTML 查看即可。這樣做可以確保你能夠正常預覽和開發你的組件。"},{"t":"h","c":"創建一個按鈕組件"},{"t":"p","c":"下面，我們將創建一個簡單的按鈕組件，命名為 simple-button，它將具有比原生按鈕更美觀的樣式。"},{"t":"p","c":"首先，創建一個名為 simple-button.html 的文件，其中使用 <template> 標簽，並添加 component 屬性以標識為組件。"},{"t":"p","c":"然後，在 <template> 內部編寫組件的模板代碼。接著，在模板內容下方，添加一個 <script> 標簽，將組件的 JavaScript 代碼放入其中。"},0,{"t":"p","c":"在成功引入 ofa.js 後，會自動注冊 load-module 組件，這是一個用於聲明式引用模塊的組件，類似於 script 標簽。該組件會代理加載指定 src 的模塊，並對需要加載的模塊進行預處理。在本案例中，會加載模板並注冊 simple-button 組件。"},{"t":"p","c":"load-module 組件還可以使用縮寫 l-m，以減少代碼量。"},0,{"t":"p","c":"load-module 組件是一個定制的聲明式加載器庫，提供了強大的功能，可以擴展支持各種類型的文件，或者對 JavaScript 模塊進行中轉處理。它已經拆分成了一個獨立的項目，具體的使用文檔在 https://github.com/kirakiray/drill.js。"},{"t":"h","c":"雙文件模式"},{"t":"p","c":"雙文件模式將 靜態模板 和 邏輯代碼 分開，使組件更加清晰。"},{"t":"p","c":"邏輯代碼放在 js 文件內，這個 js 需要標識 export const type = $.COMP;，以通知頁面這是一個組件模塊。在這種拆分模式下，模塊代碼可以使用 import 等 ES Module 的標準語法。"},{"t":"p","c":"按鈕組件由兩個文件組成："},{"t":"l","c":"1. simple-button.html：按鈕組件的 HTML 模板和樣式。"},0,{"t":"l","c":"2. simple-button.mjs：按鈕組件的注冊代碼。"},0,{"t":"p","c":"在需要使用該組件的地方，使用 l-m 引入這個模塊。以下是使用 simple-button 的案例頁面（雙文件模式）。"},0],"parameter-description":[{"t":"h","c":"組件的注冊參數詳解"},{"t":"p","c":"在 ofa.js 中，你可以在組件模塊中定義一些特定的注冊參數，以便更靈活地配置組件。下面詳細說明了每個注冊參數，並附帶了相應的示例演示。"},{"t":"h","c":"基礎參數"},{"t":"p","c":"基礎參數是注冊組件的最基本配置，包含以下幾個屬性："},{"t":"h","c":"組件標識"},{"t":"p","c":"組件模塊必須帶有 export const type = $.COMP，用於標識該模塊為組件模塊。"},{"t":"p","c":"示例："},0,{"t":"h","c":"tag"},{"t":"p","c":"tag 代表注冊的組件名。當沒有定義 tag 屬性時，注冊的組件名與文件名保持一致。"},{"t":"p","c":"示例："},0,{"t":"h","c":"temp"},{"t":"p","c":"temp 是字符串類型的屬性，用於定義組件模板的地址。當沒有定義 temp 時，默認載入和當前模塊同目錄下與組件同名的 HTML 文件。"},{"t":"p","c":"示例："},0,{"t":"h","c":"data"},{"t":"p","c":"data 是對象類型屬性，用於生成組件後，默認添加的自定義數據。"},{"t":"p","c":"示例："},0,{"t":"h","c":"attrs"},{"t":"p","c":"attrs 是對象類型屬性，也屬於 data，但是這個數據會反映到 element 的 attributes 上，attributes 上的改動也會動態改動到組件的 data 上。當出現大寫的 key 時，反應到組件 attribute 會變成 - 駝峰的命名。"},{"t":"p","c":"示例："},0,{"t":"h","c":"proto"},{"t":"p","c":"在組件的注冊參數中，你可以添加一個 proto 對象，用於定義需要添加到組件原型上的方法。這樣，在創建組件的實例時，這些屬性和方法就會被添加到實例的原型上，從而所有實例都可以訪問和共享這些方法。"},0,{"t":"h","c":"watch"},{"t":"p","c":"watch 是對象類型屬性，用於監聽 data 變化的監聽函數放在這裏。注冊成功後，監聽的值會被立刻執行一次。"},{"t":"l","c":"- watch 注冊的函數在單次線程改動中，只會被觸發一次。因此，在一次線程中，即使多次修改這個監聽的值，也只會被觸發一次。\n- 第一個參數為當前值。\n- 第二個參數是對象，會帶有 watchers 數據集，一般情況下 watchers 上只會有一個對象，可以從這個對象上獲取到 oldValue。當單次線程的這個被監聽的值被改動過多次，這個數據集會記錄多次的變化。"},{"t":"p","c":"示例："},0,{"t":"h","c":"示例代碼"},{"t":"p","c":"以下為一個完整的示例代碼，包括基礎參數的定義和組件模板。"},0,0,0,{"t":"h","c":"default"},{"t":"p","c":"你還可以使用異步函數來定義 default 數據，以便動態地返回組件的注冊參數。"},{"t":"p","c":"函數的 function 會帶來一個對象，包含"},{"t":"p","c":" load、url 和 query："},{"t":"l","c":"- load 方法是異步加載函數，使用方法和異步 import 加載一致，可以通過 const data = await load(xxx) 加載異步模塊。\n- 通過 load 加載的模塊，會有和 load-module 加載一樣的效果。load 方法相當於 load-module 組件的函數版，具體使用方法可以查閱https://github.com/kirakiray/drill.js的文檔。\n- url 是當前模塊的文件名。\n- query 是加載這個模塊時的 URL 參數轉成的對象。"},{"t":"p","c":"以下是使用 default 的示例："},0,{"t":"p","c":"在這個示例中，我們演示了如何使用 ofa.js 的注冊參數來定制化組件的行為。通過合理地配置這些參數，你可以更好地適應不同的組件需求，實現更靈活的組件開發。"},{"t":"p","c":"寫一下 組件的注冊參數 的 proto 使用文檔"}],"life-cycle":[{"t":"h","c":"組件的生命周期"},{"t":"p","c":"在 ofa.js 中，組件生命周期是在特定時間點觸發的鉤子函數。這些鉤子函數讓你能更精細地控制和交互，ofa.js 有五個關鍵生命周期鉤子：created、ready、watch、loaded、attached 和 detached，分別在不同時刻觸發。"},{"t":"h","c":"生命周期鉤子"},{"t":"h","c":"created"},{"t":"p","c":"created 生命周期鉤子在組件創建時被觸發。在此階段，組件的數據尚未被初始化，模板內容也未被渲染。你可以在這個階段執行一些初始化操作，或者準備在後續階段使用的數據。"},{"t":"h","c":"ready"},{"t":"p","c":"ready 生命周期鉤子會在組件的數據和模板剛被初始化後觸發，表示組件已經準備就緒。在這個階段，你可以訪問組件的數據，並且模板已經渲染完成，可以執行一些與界面交互相關的操作。"},{"t":"p","c":"如果組件模板存在對其他組件的依賴，這個階段不會等待依賴加載完成。因此，這個階段適合為組件添加Loading樣式，但需要注意等待依賴加載完成後再執行相關操作。"},{"t":"h","c":"watch"},{"t":"p","c":"一旦 ready 階段完成，與之關聯的 watch 對象中的監聽函數會被觸發一次。隨後，當數據的某個值發生變動時，會再次觸發相應鍵（key）的監聽函數。"},{"t":"h","c":"loaded"},{"t":"p","c":"loaded 生命周期鉤子在組件模板內的所有依賴都加載完成後觸發。這個階段確保在渲染組件之前，所有的依賴都已經加載完畢。這個時候適合去除在 ready 階段添加的Loading樣式。"},{"t":"h","c":"attached"},{"t":"p","c":"attached 生命周期鉤子會在組件被添加到文檔中時觸發。在這個階段，適合獲取組件內元素的尺寸相關信息，進行數據綁定和全局事件的操作。"},{"t":"h","c":"detached"},{"t":"p","c":"detached 生命周期鉤子會在組件從文檔中移除時觸發。在這個階段，你可以執行一些清理操作，比如取消事件監聽或者釋放資源，以防止內存泄漏。"},{"t":"h","c":"示例演示"},{"t":"p","c":"以下是一個示例，展示了如何使用這些生命周期鉤子："},0,0,0,{"t":"p","c":"在上面的示例中，我們定義了一個名為 lifecycle-demo 的組件，並且在其模板中放置了一個按鈕。通過不同的生命周期鉤子，我們可以在控制台中觀察到各個階段觸發的日誌。"},{"t":"h","c":"生命周期流程圖"},0],"web-components":[{"t":"h","c":"封裝和組件化：組件化常規知識"},{"t":"p","c":"ofa.js 是一個基於 Web Components 技術的封裝庫，旨在簡化和加速組件開發過程。它通過將復雜的技術細節隱藏在背後，讓開發者能夠更專注地構建高質量的組件和應用。"},{"t":"p","c":"為了更好地開發組件，有必要學習一些 Web Components 的知識。下面介紹的知識點不僅可以在 ofa.js 中應用，還可以讓你在其他使用 Web Components 的框架上同樣受益。"},{"t":"h","c":"Shadow DOM 容器"},{"t":"p","c":"在 Web Components 中，Shadow DOM 提供了一種隔離的容器，用於封裝組件內部的樣式和結構。這意味著組件內部的樣式和 DOM 結構不會與外部的樣式和結構相互幹擾，從而確保組件的可預測性和可維護性。"},{"t":"p","c":"在 ofa.js 中，每個組件都有一個 Shadow DOM 容器，用於隔離組件的內部內容。模板內容就是被渲染到這個容器內。通過 $ 獲取的組件實例，也可以使用 shadow 屬性訪問組件內部的 Shadow DOM 容器，從而實現對組件內部元素的操作和訪問。"},0,{"t":"h","c":"Web Components 中的常用 CSS 選擇器"},{"t":"p","c":"Web Components 提供了一些特殊的 CSS 選擇器，用於選擇和樣式化組件內部的不同部分。以下是一些常用的選擇器："},{"t":"h","c":":host 選擇器"},{"t":"p","c":":host 選擇器用於選擇組件自身的外部容器。可以通過這個選擇器來定義組件的樣式。"},0,{"t":"h","c":"::slotted() 選擇器"},{"t":"p","c":"::slotted() 選擇器用於選擇被插槽內容包裹的元素。可以在組件內部的樣式中使用這個選擇器來樣式化被插槽的內容。"},0,{"t":"h","c":"插槽（Slot）的使用"},{"t":"p","c":"插槽是 Web Components 中用於在組件內部嵌入外部內容的機制。插槽允許開發者將自定義的內容傳遞到組件內部，實現更靈活的組件結構。"},{"t":"h","c":"單個插槽"},{"t":"p","c":"在組件模板中，可以使用 <slot> 元素來定義插槽。外部傳入的內容會被插入到插槽內部。"},0,0,{"t":"h","c":"多個命名插槽"},{"t":"p","c":"除了默認插槽外，還可以定義多個命名插槽。命名插槽允許開發者將不同的內容插入到不同的插槽位置。"},0,0,{"t":"h","c":"slotchange 事件的使用"},{"t":"p","c":"slotchange 事件在插槽內容變化時觸發。可以通過監聽這個事件來執行一些與插槽內容相關的操作。"},0],"template-syntax":[{"t":"h","c":"模板語法"},{"t":"p","c":"ofa.js 提供了一系列強大的模板語法，使你能夠更靈活地操作組件的界面元素和數據。這些模板語法能夠幫助你實現豐富的界面效果和交互體驗。"},{"t":"h","c":"渲染文本語法"},{"t":"p","c":"通過使用 {{key}} 的渲染文本語法，你可以將數據渲染為文本內容，並將其嵌入到組件的模板中。當數據發生變化時，對應的文本內容也會自動更新。"},{"t":"p","c":"以下是一個使用文本渲染語法的示例："},0,0,{"t":"p","c":"在上述示例中，{{username}} 將會被組件的 data 中的 username 屬性值所替代，從而在界面上顯示出 \"Welcome, JohnDoe!\"。"},{"t":"h","c":"屬性綁定語法"},{"t":"p","c":"使用 :xxx='yyy' 的屬性綁定語法，你可以將組件的屬性綁定到模板內元素的屬性上。這種綁定是單向的，屬性的變化會影響到模板內元素的屬性，但不會反過來影響組件的屬性。"},{"t":"p","c":"以下是一些常見的屬性綁定示例："},0,0,{"t":"p","c":"在上述示例中，:text=\"greeting\" 將組件的 data 中的 greeting 屬性值綁定到 <p> 元素的文本內容上。:value=\"inputValue\" 將組件的 data 中的 inputValue 屬性值綁定到 <input> 元素的 value 屬性上。對於自定義組件，custom-prop 是自定義組件的屬性名，它將組件的 data 中的 customValue 屬性值傳遞給自定義組件。"},{"t":"h","c":"事件綁定"},{"t":"p","c":"使用 on:click=\"yyy\" 的形式，你可以將目標元素的指定事件（例如 click）綁定到宿主組件的屬性 yyy 上。這樣，當目標元素觸發指定事件時，會調用宿主組件中相應的屬性方法。"},{"t":"p","c":"以下是一個示例："},0,0,{"t":"p","c":"在上述示例中，當按鈕被點擊時，會調用宿主組件的 increaseCount 方法，從而增加 count 屬性的值。"},{"t":"h","c":"attributes 綁定"},{"t":"p","c":"通過 attr:xxx=\"yyy\" 的形式，你可以將目標元素的指定屬性 xxx 綁定到宿主組件的屬性 yyy 上。這樣，目標元素的屬性會隨著宿主組件的屬性變化而變化。"},0,0,{"t":"p","c":"在上述示例中，attr:fontcolor=\"val\" 會將宿主組件的 val 屬性綁定到 <div> 元素的 fontcolor attribute上。"},{"t":"h","c":"動態類名綁定"},{"t":"p","c":"使用 class:xxx=\"yyy\" 的形式，你可以根據宿主組件的屬性值來動態地為目標元素添加或移除類名。當宿主組件的 yyy 屬性為 true 時，目標元素會添加類名 xxx；否則，會移除該類名。"},0,0,{"t":"p","c":"在上述示例中，如果 isActive 屬性為 true，則按鈕會添加 active 類名，從而應用特定的樣式。"},{"t":"h","c":"雙向數據綁定"},{"t":"p","c":"通過 sync:xxx='yyy' 的形式，你可以實現雙向數據綁定。這使得目標元素的屬性 xxx 和宿主組件的屬性 yyy 保持同步，即目標屬性的變化會反映到宿主屬性上，宿主屬性的變化也會同步到目標屬性上。"},{"t":"p","c":"以下是一個示例："},0,0,{"t":"p","c":"在上述示例中，sync:value=\"inputValue\" 實現了一個雙向數據綁定，當輸入框的值發生變化時，inputValue 會自動更新；反之，當 inputValue 發生變化時，輸入框的值也會隨之變化。"}],"template-component":[{"t":"h","c":"模板渲染組件"},{"t":"p","c":"除了能夠使用模板語法，ofa.js 還提供了專用於模板內部的渲染組件，包括條件渲染組件和填充渲染組件。"},{"t":"h","c":"條件渲染組件"},{"t":"h","c":"x-if 組件"},{"t":"p","c":"x-if 組件是用來根據條件動態渲染內容的組件。它接受一個 value 屬性，根據該屬性的值來判斷是否渲染其子元素。如果 value 為 true，則渲染子元素，否則不渲染。"},{"t":"p","c":"以下是一個使用 x-if 的示例，用於根據條件渲染不同的內容："},0,0,{"t":"h","c":"x-else 組件"},{"t":"p","c":"x-if 可以與 x-else 配合使用，實現條件切換渲染。"},{"t":"p","c":"以下是一個使用 x-if 和 x-else 的示例，根據不同的條件切換渲染的內容："},0,0,{"t":"h","c":"x-if + x-else-if + x-else 組件"},{"t":"p","c":"x-if 還可以與 x-else-if 和 x-else 組合使用，實現多條件的渲染。"},{"t":"p","c":"以下是一個使用 x-if、x-else-if 和 x-else 的示例，根據多個條件切換渲染的內容："},0,0,{"t":"p","c":"在上述示例中，根據 condition 的不同值，會渲染不同的內容，實現了多條件切換渲染的效果。"},{"t":"h","c":"模板組件之：x-fill"},{"t":"p","c":"x-fill 組件允許你在模板中動態填充內容，可以根據宿主組件的屬性值來生成不同的內容。x-fill 組件使用 name 屬性來指定要使用的填充模板，並通過 value 屬性傳遞數據給填充模板。"},{"t":"h","c":"x-fill 填充數組字符串的示例"},{"t":"p","c":"以下是一個使用 x-fill 填充數組字符串的示例，通過循環填充不同的字符串內容："},0,{"t":"p","c":"在上述示例中，x-fill 使用名為 fillTemplate 的填充模板，並傳遞一個數組給它。填充模板中使用了 {{ $data }} 來渲染數組中的每個元素，從而實現了循環填充不同的字符串內容。"},{"t":"h","c":"x-fill 填充對象並且能自舉填充的示例"},{"t":"p","c":"x-fill 還可以填充包含更復雜結構的對象，並且支持自嵌套填充。"},{"t":"p","c":"以下是一個使用 x-fill 填充對象並且能自嵌套填充的示例，展示了如何生成嵌套的內容："},0,0,{"t":"p","c":"在上述示例中，x-fill 使用名為 nestedFillTemplate 的填充模板，並傳遞一個復雜的嵌套對象給它。填充模板中使用了 {{ $data.title }} 來渲染對象的標題，同時又使用了嵌套的 x-fill 來填充子項的內容，實現了嵌套的內容生成。"},{"t":"h","c":"$data、$ele、$host 在模板內的含義"},{"t":"p","c":"在填充模板內，你可以使用特殊的標識符來訪問不同的數據："},{"t":"l","c":"- {{ $data }}：表示傳遞給填充模板的數據，即 value 屬性的值。\n- {{ $ele }}：表示當前填充模板所在的元素，可以用於訪問元素的屬性和樣式。\n- {{ $host }}：表示宿主組件的實例，可以用於訪問宿主組件的屬性和方法。"},{"t":"p","c":"這些特殊標識符可以幫助你在填充模板內動態地訪問和渲染不同的數據。在示例中，你可以看到如何使用 {{ $data.title }} 來訪問傳遞的數據的標題，以及如何使用 {{ $host.num }} 來訪問宿主組件的屬性。"}]},"create-app":{"index":[{"t":"h","c":"開發應用"},{"t":"p","c":"除了可以開發組件，ofa.js 還可以用於開發功能完整的應用程序。"},{"t":"p","c":"ofa.js 將應用程序集成為一個 o-app 組件，通過直接使用這個標簽，你就能夠快速創建應用程序。這種方式使應用的創建變得簡單且高效。"},{"t":"p","c":"此外，ofa.js 官方還提供了完整的路由和SSG（靜態頁面生成）方案，幫助開發者構建更健全的應用程序。這些功能能夠加速開發流程，讓你能夠專注於應用程序的邏輯和用戶體驗，而不必過多擔心底層細節。"},0,{"t":"p","c":"上面是一個簡單的應用教程代碼示例，接下來會逐步講解應用的開發過程。"}],"page":[{"t":"h","c":"開發頁面"},{"t":"p","c":"在 ofa.js 內部，我們構建了一個名為 o-page 的自定義組件，旨在為頁面的開發提供便利。這個組件在應用開發中扮演著關鍵的角色。當你想要使用組件的模板語法，但又不想創建全新的組件時，o-page 組件將成為你的最佳選擇。"},{"t":"h","c":"頁面模塊"},{"t":"p","c":"創建一個單文件頁面模塊時，類似於創建組件模塊。使用 template 標簽來包裹頁面的模板代碼，並添加 page 屬性。在該標簽內部，可以自由使用模板語法與其他組件或頁面模塊進行交互。"},0,{"t":"p","c":"在 HTML 文件中，使用 o-page 標簽的 src 屬性指定頁面模塊的文件路徑。頁面內容將在該組件內部進行渲染。"},0,{"t":"h","c":"雙文件模式"},{"t":"p","c":"雙文件模式將 靜態模板 和 邏輯代碼 分開，使頁面的內容更加清晰。"},{"t":"p","c":"以下是使用 o-page 組件和頁面模塊的步驟："},{"t":"l","c":"1. 創建頁面模塊："},{"t":"p","c":"與創建組件模塊類似，創建一個頁面模塊，但將 type 屬性設置為 $.PAGE。頁面模塊可用的參數包括 temp、data、proto 和 watch。"},0,{"t":"l","c":"2. 創建頁面模板："},{"t":"p","c":"在與頁面模塊相同的目錄下，創建一個名為 my-page-template.html 的頁面模板文件。在這個模板文件中，你可以使用模板語法進行交互，用法與前面提到的組件模板語法類似。"},0,{"t":"p","c":"在你的 HTML 文件中，通過 <o-page> 標簽來使用 o-page 組件，通過 src 屬性引用頁面模塊的文件路徑。頁面的內容將會在這個組件內部渲染。"},0,{"t":"p","c":"這樣，當你打開頁面時，o-page 組件會動態加載 my-page.mjs 這個頁面模塊，並根據模塊中的模板和數據渲染頁面內容。頁面模塊的生命周期和模板語法與組件模塊保持一致，使得頁面的開發和管理變得更加統一和靈活。"},{"t":"h","c":"判斷頁面是否加載完成"},{"t":"p","c":"在某些情況下，你可能需要判斷頁面是否已經完全加載完成，以便執行一些特定的操作。ofa.js 提供了幾種方式來判斷頁面是否加載完成。"},{"t":"h","c":"使用 page._loaded 屬性"},{"t":"p","c":"在頁面模塊中，page._loaded 是一個布爾屬性，當頁面內容加載完成後，該屬性會變為 true。你可以使用這個屬性來判斷頁面是否加載完成。"},0,{"t":"h","c":"使用 page._rendered 屬性"},{"t":"p","c":"另一種方式是使用 page.rendered 屬性，它是一個 Promise。當頁面加載完成後，這個 Promise 會進入 resolve 狀態。你可以通過 await page.rendered 來等待頁面加載完成，然後執行相應的操作。"},0],"app":[{"t":"h","c":"制作應用"},{"t":"p","c":"使用 o-app 標簽可以輕松地創建一個完整的應用程序窗口。下面是如何制作一個應用並配置它的步驟："},{"t":"h","c":"基礎代碼"},{"t":"l","c":"1. 創建一個 HTML 文件，設置 o-app 標簽為應用的顯示窗口。確保為 o-app 設置全屏的樣式，以使應用占據整個視口。"},0,{"t":"l","c":"2. 創建一個 es 模塊，用於設置應用的配置數據。配置數據包括以下選項：\n\n   - home：字符串類型，應用的首頁的頁面模塊地址。\n   - loading：函數類型，應用在加載新頁面時，會運行這個函數，得到的內容會插入到應用中，作為加載時的提示，等到頁面加載完成後，會自動去除這個 loading 元素。\n   - fail：函數類型，應用加載頁面失敗時，會運行這個函數，返回得到的值會顯示在應用中作為加載失敗的提示。函數會帶有加載失敗頁面的 src 地址和錯誤報錯對象。\n   - pageAnime：頁面之間切換時的動畫配置。"},{"t":"p","c":"下面是應用的配置數據示例："},0,{"t":"l","c":"3. 在 HTML 文件中使用 o-app 標簽，並通過 src 屬性引用配置數據的 es 模塊。"},0,{"t":"p","c":"通過以上步驟，你已經成功制作了一個使用 o-app 組件的應用程序窗口。o-app 組件會根據配置數據中的設置加載頁面，展示加載中的提示或加載失敗的提示，並支持頁面切換動畫。這樣，你可以快速搭建一個功能完整且具有交互性的應用程序。"},{"t":"h","c":"路由跳轉"},{"t":"p","c":"在 o-app 應用中，你可以輕松地實現路由跳轉，從一個頁面模塊跳轉到另一個頁面模塊。下面介紹幾種不同的方式來進行路由跳轉。"},{"t":"h","c":"使用 <a> 標簽進行路由跳轉"},{"t":"p","c":"你可以在頁面的 HTML 中使用 <a> 標簽來實現路由跳轉。需要將 href 屬性指定為目標頁面模塊的路徑，並添加 olink 屬性，以告知 o-app 組件這是一個路由鏈接。"},0,{"t":"h","c":"goto"},{"t":"p","c":"你可以在頁面模板中使用 on:click 屬性來綁定點擊事件，並調用模塊上的 goto 方法進行路由跳轉。"},0,{"t":"p","c":"又或者直接卸載目標元素上："},0,{"t":"h","c":"替換跳轉和返回頁面"},{"t":"p","c":"除了 goto 方法外，o-app 還支持 replace 和 back 方法。"},{"t":"l","c":"- replace 方法用於替換跳轉，它會取代當前頁面的路由，使新頁面成為當前頁面的路由。"},0,{"t":"l","c":"- back 方法用於返回到前一個頁面。"},0,{"t":"p","c":"需要注意的是，應用內會保持組件的路由狀態，但路由數據不會綁定到當前瀏覽器標簽上。這樣，你可以方便地在應用中實現頁面之間的跳轉和導航。"},{"t":"p","c":"如果你想實現路由和頁面的綁定，可以使用 o-router 組件，我們將在後面的章節中詳細介紹。"},{"t":"p","c":"通過以上方法，你可以在 o-app 應用中實現靈活的路由跳轉，讓用戶能夠方便地瀏覽不同的頁面內容。"},{"t":"h","c":"訪問應用和當前頁面"},{"t":"p","c":"在應用內的各個元素（包括組件），你通過 app 屬性來獲取它們所在的 o-app 實例。這對於需要與整個應用進行交互的操作非常有用。"},{"t":"p","c":"通過 app.current 屬性，你可以獲取當前激活的頁面模塊的地址。"},{"t":"p","c":"以下是一個使用示例："},0,{"t":"p","c":"在上面的示例中，通過選擇器 .app 獲取了應用標簽，然後通過訪問 app.current 屬性獲取了當前激活的頁面地址。"},{"t":"h","c":"使用技巧：提前緩存下一頁"},{"t":"p","c":"在一些場景下，你可能已經預知用戶即將跳轉到下一頁。為了提高用戶體驗，你可以提前緩存下一頁的頁面模塊，這樣在實際跳轉時可以立即加載，減少用戶等待的時間，讓用戶體驗更加流暢。。"},{"t":"p","c":"在當前頁面的 JavaScript 代碼中，調用 load 方法並傳入下一頁的模塊路徑，該模塊將被加載並緩存。"},0],"subrouting":[{"t":"h","c":"子路由模式"},{"t":"p","c":"在 ofa.js 中，設置子路由與一些前端框架的做法略有不同。ofa.js 使用一種更加直觀的方式，通過在頁面模塊上設置父頁面來作為容器，從而實現子路由的需求。"},{"t":"h","c":"設置父頁面容器"},{"t":"p","c":"要創建子路由，首先需要在子頁面的頁面模塊上設置 parent 參數，指定父頁面的頁面模塊地址。這樣，在子頁面加載時，ofa.js 會自動將子頁面包裹在父頁面容器中。"},0,{"t":"p","c":"在上述示例中，子頁面的頁面模塊通過 parent 參數指定了父頁面容器的地址。"},{"t":"h","c":"父頁面容器模板設置"},{"t":"p","c":"父頁面容器的模板需要設置一個 <slot> 元素，以便子頁面能夠插入到父頁面的指定位置。同時，確保 <slot> 元素的容器元素設置為 position: relative，這是非常重要的，因為子頁面會在父頁面容器中絕對定位。"},{"t":"p","c":"以下是一個父頁面容器的示例模板："},0,{"t":"p","c":"在上述示例中，通過設置一個帶有 slot 的容器元素，子頁面會被插入到該容器中。確保容器元素具有相對定位，這樣子頁面可以根據容器定位。"},{"t":"p","c":"通過使用這種方式，你可以更直觀地配置子路由，通過設置父頁面容器和子頁面的關聯，來實現子頁面的加載和渲染。"},{"t":"h","c":"父頁面的路由監聽"},{"t":"p","c":"在某些情況下，多個頁面共用同一個父頁面作為容器，當這些頁面之間進行跳轉時，父頁面不會被刷新。這種情況下，父頁面仍然可以監聽路由的變動，以便在不刷新頁面的情況下執行相應的操作。"},{"t":"h","c":"監聽路由變動"},{"t":"p","c":"父頁面模塊可以設置一個 routerChange 函數，用於監聽路由的變動。當頁面發生路由切換且不刷新父頁面時，將觸發 routerChange 事件。這個事件會傳遞當前頁面的信息，以及跳轉的方式（type）。"},{"t":"p","c":"以下是一個父頁面模塊的示例，展示了如何設置 routerChange 函數來監聽路由變動："},0,{"t":"p","c":"在上述示例中，routerChange 函數接收兩個參數，current 表示當前頁面的地址，type 表示跳轉的方式。當頁面發生路由切換時，該函數會被觸發，並輸出相應的信息。"}],"o-router":[{"t":"h","c":"o-router 組件的使用"},{"t":"p","c":"o-router 組件是一個用於將 o-app 內的路由綁定到當前瀏覽器標簽頁的組件，它能夠幫助你更方便地管理頁面路由和展示。"},{"t":"h","c":"引用 o-router 組件"},{"t":"p","c":"首先，你需要在頁面中引用 o-router 組件。你可以通過以下方式引用 router.mjs 文件："},0,{"t":"h","c":"使用 o-router 組件"},{"t":"p","c":"使用 o-router 組件是通過將其包裹在 o-app 組件外部來實現的。這樣可以將應用內的路由綁定到當前瀏覽器標簽上。"},0,{"t":"h","c":"fix-body 屬性"},{"t":"p","c":"o-router 組件還提供了 fix-body 屬性，當你設置了該屬性後，組件會自動為 <html> 標簽添加樣式，使應用的尺寸等於頁面的大小，從而讓應用的內容充滿整個窗口。"},0],"scsr":[{"t":"h","c":"靜態客戶端渲染(SCSR)"},{"t":"h","c":"什麽是 SCSR？"},{"t":"p","c":"SCSR 全名 Static Client-Side Rendering，稱為靜態客戶端渲染；靜態客戶端渲染（SCSR）是 CSR（Client-Side Rendering）的一種變種，它在保留了 CSR 用戶體驗的基礎上，還能夠讓頁面在靜態狀態下被爬蟲獲取。"},{"t":"h","c":"如何使用 SCSR"},{"t":"p","c":"你可以通過以下方式引用 SCSR 庫："},0,{"t":"h","c":"SCSR 的工作原理"},{"t":"p","c":"SCSR 是通過直接運行單文件模式的頁面模塊，而無需使用 o-page 標簽，從而實現在頁面上進行渲染。具體來說，就是將頁面模塊的模板代碼直接放在 o-app 內。"},{"t":"p","c":"以下是一個 SCSR 示例，展示了如何在頁面上直接渲染頁面模塊的內容："},0,{"t":"p","c":"通過 SCSR，template 標簽內的內容會被直接渲染到頁面上，而這部分內容實際上就是單文件模式的頁面模塊。"},{"t":"p","c":"繼續以上面的 home.html 頁面為例，我們創建一個 help 頁面："},0,{"t":"p","c":"在 home.html 頁面中點擊 \"GO TO HELP\" 後，將平滑跳轉到 help.html 頁面，實現了客戶端渲染的平滑跳轉效果。"},{"t":"h","c":"注意事項"},{"t":"p","c":"所有采用 SCSR 方案的頁面，除頁面描述性的內容（如 title、meta:description、keywords）和頁面模板內容外，其他引用資源必須保持一致，以確保在頁面跳轉和刷新後的體驗一致。"},{"t":"h","c":"關於 SSR 方案"},{"t":"p","c":"當前的 SCSR 方案實際上更類似於一種 SSG（Static Site Generation）方案，因為它將頁面預先渲染成靜態內容，然後再通過客戶端進行交互。ofa.js 已經提供了相對獨立的組件封裝方案，使得前端開發人員可以將組件封裝好，然後結合傳統的後端渲染頁面方案（如 Node.js、Go、Java、PHP 等語言的網站渲染框架），後端開發人員可以快速使用這些封裝好的組件來構建優質的網頁。"},{"t":"p","c":"我們計劃在未來提供一個完整的 SSR（Server-Side Rendering）方案。這個方案的原理大致是先獲取下一頁的元素內容，然後與當前頁的標簽內容進行對比，從而進行動態的增加、刪除和修改屬性值等操作。不過需要注意的是，這個 SSR 方案會比較耗費時間，因為這個過程涉及到復雜的元素比較和修改操作。"},{"t":"p","c":"ofa.js 是一個新興的框架，而且作者的業余時間也有限，暫時還沒有完整開發出這個 SSR 方案。但如果未來 ofa.js 能夠得到更多的用戶使用，並且出現了對於 SSR 方案的強烈需求時，作者會繼續完善並開發這個方案。目前，作者會專注於框架的穩定性和功能擴展，同時也歡迎用戶的反饋和建議，以便未來更好地滿足用戶的需求。"}]},"others":{"data-sharing":[{"t":"h","c":"數據共享"},{"t":"p","c":"ofa.js與其他第三方框架不同，不采用傳統的狀態管理模式。作者認為狀態更新應該是無感知的，即改變數據後應自動觸發數據更新。"},{"t":"p","c":"ofa.js天生就具備出色的數據共享能力，它的實例基於數據共享庫 Stanz 進行開發。實例上的對象都是可同步的。如果要實現數據共享，只需創建一個獨立的 Stanz 對象，然後讓所有組件直接引用即可。"},{"t":"p","c":"下面的案例展示了如何共享數據："},0,0,0,0,{"t":"p","c":"在上述示例中，兩個組件在 attached 生命周期時，將數據寫入到組件本身。然後，組件的 obj 就成為共享數據。在 detached 生命周期後，將之前共享的數據設置為 null，以確保數據得到回收。"},{"t":"h","c":"注意事項"},{"t":"p","c":"由於數據是共享的，務必要確保在適當的時候回收數據，以避免內存泄漏。"},0],"about-micro-frontend":[{"t":"h","c":"關於微前端"},{"t":"p","c":"微前端是一種前端架構模式，旨在幫助團隊更好地構建和維護大型、復雜的前端應用程序。它借鑒了微服務架構的思想，將前端應用程序拆分為更小的獨立部分，每個部分都可以由不同的團隊開發、測試和部署。"},{"t":"p","c":"在傳統的單體前端應用不斷擴展的過程中，可能會變得難以維護和擴展。微前端的目標是通過將應用拆分成更小、更可管理的模塊，使得開發團隊能夠獨立地開發和部署這些模塊，從而提高團隊的效率和應用的可維護性。"},{"t":"p","c":"ofa.js 天生具備微前端的特性，它與其它框架的不同之處在於，基於 ofa.js 開發的組件、頁面和應用無需預編譯。相比於一些框架如 React、Vue 和 Angular 等，它們需要在 Node.js 環境下進行一次構建，生成用於客戶端的代碼。然而，ofa.js 的開發代碼可以直接放置在靜態服務器上，無需額外的構建步驟，就能實時查看、使用和運行。"},{"t":"p","c":"ofa.js 符合了微前端的五個核心特點："},{"t":"l","c":"1. 獨立部署：每個組件和頁面都可以獨立地開發、測試和部署，這使得團隊能夠更迅速地發布新功能和解決問題。\n\n2. 集成：基於 ofa.js 開發的應用，可以將不同的模塊組合在一起。這可以通過應用、頁面、組件等方式共享組合。\n\n3. 獨立團隊：每個前端模塊（組件/頁面/應用）可以由獨立的團隊進行開發和維護，從而鼓勵團隊的自主性和創新。\n\n4. 共享資源：在 ofa.js 項目中，通常會存在一些共享的資源，如樣式、組件、頁面等，以確保一致性和效率。\n\n5. 按需加載：ofa.js 的應用可以根據需要加載模塊，從而提升應用的性能和加載速度。"},{"t":"p","c":"盡管 ofa.js 無法直接使用 Vue 和 React 等框架開發的組件，但基於 ofa.js 開發的組件可以被 Vue 和 React 使用，這為不同技術棧的開發人員提供了更強的靈活性和擴展性。"},{"t":"p","c":"在 Vue 中使用 Web Components："},{"t":"l","c":"- Vue Web Component Wrapper\n- 將 Vue 與 Web Components 集成\n- 如何在 Vue 中使用 Web Components"},{"t":"p","c":"在 React 中使用 Web Components："},{"t":"l","c":"- 與 React 一起使用 Web Components\n- 在 React 中使用 Web Components\n- 將 Web Components 集成到 React 中"}]}}}